
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Torch.Internal.Unmanaged.Native where


import Foreign.C.String
import Foreign.C.Types
import Foreign
import Torch.Internal.Type
import Torch.Internal.Class

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<vector>"
C.include "<ATen/ATen.h>"


_cast_Byte_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Byte_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Byte(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Byte_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Byte_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Byte(
    *$(at::Tensor* _self)));
  }|]

_cast_Char_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Char_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Char(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Char_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Char_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Char(
    *$(at::Tensor* _self)));
  }|]

_cast_Double_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Double_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Double(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Double_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Double_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Double(
    *$(at::Tensor* _self)));
  }|]

_cast_Float_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Float_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Float(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Float_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Float_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Float(
    *$(at::Tensor* _self)));
  }|]

_cast_Int_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Int_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Int(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Int_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Int_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Int(
    *$(at::Tensor* _self)));
  }|]

_cast_Long_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Long_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Long(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Long_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Long_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Long(
    *$(at::Tensor* _self)));
  }|]

_cast_Short_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Short_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Short(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Short_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Short_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Short(
    *$(at::Tensor* _self)));
  }|]

_cast_Half_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Half_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Half(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Half_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Half_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Half(
    *$(at::Tensor* _self)));
  }|]

align_tensors_l
  :: Ptr TensorList
  -> IO (Ptr TensorList)
align_tensors_l _tensors =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::align_tensors(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

_use_cudnn_ctc_loss_ttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (CBool)
_use_cudnn_ctc_loss_ttlll _log_probs _targets _input_lengths _target_lengths _blank =
  [C.throwBlock| bool { return (at::_use_cudnn_ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , $(int64_t _blank)));
  }|]

_cudnn_ctc_loss_ttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_cudnn_ctc_loss_ttlllbb _log_probs _targets _input_lengths _target_lengths _blank _deterministic _zero_infinity =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_cudnn_ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , $(int64_t _blank)
  , $(bool _deterministic)
  , $(bool _zero_infinity)));
  }|]

_cudnn_rnn_flatten_weight_llllllbb
  :: Ptr TensorList
  -> Int64
  -> Int64
  -> Int64
  -> Int64
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
_cudnn_rnn_flatten_weight_llllllbb _weight_arr _weight_stride0 _input_size _mode _hidden_size _num_layers _batch_first _bidirectional =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cudnn_rnn_flatten_weight(
    *$(std::vector<at::Tensor>* _weight_arr)
  , $(int64_t _weight_stride0)
  , $(int64_t _input_size)
  , $(int64_t _mode)
  , $(int64_t _hidden_size)
  , $(int64_t _num_layers)
  , $(bool _batch_first)
  , $(bool _bidirectional)));
  }|]

_cudnn_rnn_tlltttlllbdbblt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> CBool
  -> CDouble
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor,Tensor)))
_cudnn_rnn_tlltttlllbdbblt _input _weight _weight_stride0 _weight_buf _hx _cx _mode _hidden_size _num_layers _batch_first _dropout _train _bidirectional _batch_sizes _dropout_state =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_cudnn_rnn(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _weight)
  , $(int64_t _weight_stride0)
  , *$(at::Tensor* _weight_buf)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _cx)
  , $(int64_t _mode)
  , $(int64_t _hidden_size)
  , $(int64_t _num_layers)
  , $(bool _batch_first)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , *$(std::vector<int64_t>* _batch_sizes)
  , *$(at::Tensor* _dropout_state)));
  }|]

_cudnn_rnn_backward_tlltttttttlllbdbbltta
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> CBool
  -> CDouble
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray '(CBool,4))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,TensorList)))
_cudnn_rnn_backward_tlltttttttlllbdbbltta _input _weight _weight_stride0 _weight_buf _hx _cx _output _grad_output _grad_hy _grad_cy _mode _hidden_size _num_layers _batch_first _dropout _train _bidirectional _batch_sizes _dropout_state _reserve _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,std::vector<at::Tensor>>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,std::vector<at::Tensor>>(at::_cudnn_rnn_backward(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _weight)
  , $(int64_t _weight_stride0)
  , *$(at::Tensor* _weight_buf)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _output)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _grad_cy)
  , $(int64_t _mode)
  , $(int64_t _hidden_size)
  , $(int64_t _num_layers)
  , $(bool _batch_first)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , *$(std::vector<int64_t>* _batch_sizes)
  , *$(at::Tensor* _dropout_state)
  , *$(at::Tensor* _reserve)
  , *$(std::array<bool,4>* _output_mask)));
  }|]

_cudnn_init_dropout_state_dblo
  :: CDouble
  -> CBool
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_cudnn_init_dropout_state_dblo _dropout _train _dropout_seed _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cudnn_init_dropout_state(
    $(double _dropout)
  , $(bool _train)
  , $(int64_t _dropout_seed)
  , *$(at::TensorOptions* _options)));
  }|]

_debug_has_internal_overlap_t
  :: Ptr Tensor
  -> IO (Int64)
_debug_has_internal_overlap_t _self =
  [C.throwBlock| int64_t { return (at::_debug_has_internal_overlap(
    *$(at::Tensor* _self)));
  }|]

_fused_dropout_tdp
  :: Ptr Tensor
  -> CDouble
  -> Ptr Generator
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_fused_dropout_tdp _self _p _generator =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_fused_dropout(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(at::Generator * _generator)));
  }|]

_fused_dropout_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_fused_dropout_td _self _p =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_fused_dropout(
    *$(at::Tensor* _self)
  , $(double _p)));
  }|]

_masked_scale_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
_masked_scale_ttd _self _mask _scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_masked_scale(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , $(double _scale)));
  }|]

_sobol_engine_draw_tltlls
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> ScalarType
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_sobol_engine_draw_tltlls _quasi _n _sobolstate _dimension _num_generated _dtype =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_sobol_engine_draw(
    *$(at::Tensor* _quasi)
  , $(int64_t _n)
  , *$(at::Tensor* _sobolstate)
  , $(int64_t _dimension)
  , $(int64_t _num_generated)
  , $(at::ScalarType _dtype)));
  }|]

_sobol_engine_ff__tltll
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
_sobol_engine_ff__tltll _self _n _sobolstate _dimension _num_generated =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sobol_engine_ff_(
    *$(at::Tensor* _self)
  , $(int64_t _n)
  , *$(at::Tensor* _sobolstate)
  , $(int64_t _dimension)
  , $(int64_t _num_generated)));
  }|]

_sobol_engine_scramble__ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_sobol_engine_scramble__ttl _self _ltm _dimension =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sobol_engine_scramble_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _ltm)
  , $(int64_t _dimension)));
  }|]

_sobol_engine_initialize_state__tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_sobol_engine_initialize_state__tl _self _dimension =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sobol_engine_initialize_state_(
    *$(at::Tensor* _self)
  , $(int64_t _dimension)));
  }|]

_reshape_from_tensor_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_reshape_from_tensor_tt _self _shape =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_reshape_from_tensor(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _shape)));
  }|]

_shape_as_tensor_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_shape_as_tensor_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_shape_as_tensor(
    *$(at::Tensor* _self)));
  }|]

dropout_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
dropout_tdb _input _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::dropout(
    *$(at::Tensor* _input)
  , $(double _p)
  , $(bool _train)));
  }|]

dropout__tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
dropout__tdb _self _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::dropout_(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(bool _train)));
  }|]

feature_dropout_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
feature_dropout_tdb _input _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::feature_dropout(
    *$(at::Tensor* _input)
  , $(double _p)
  , $(bool _train)));
  }|]

feature_dropout__tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
feature_dropout__tdb _self _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::feature_dropout_(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(bool _train)));
  }|]

alpha_dropout_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
alpha_dropout_tdb _input _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::alpha_dropout(
    *$(at::Tensor* _input)
  , $(double _p)
  , $(bool _train)));
  }|]

alpha_dropout__tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
alpha_dropout__tdb _self _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::alpha_dropout_(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(bool _train)));
  }|]

feature_alpha_dropout_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
feature_alpha_dropout_tdb _input _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::feature_alpha_dropout(
    *$(at::Tensor* _input)
  , $(double _p)
  , $(bool _train)));
  }|]

feature_alpha_dropout__tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
feature_alpha_dropout__tdb _self _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::feature_alpha_dropout_(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(bool _train)));
  }|]

abs_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
abs_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::abs(
    *$(at::Tensor* _self)));
  }|]

abs__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
abs__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::abs_(
    *$(at::Tensor* _self)));
  }|]

abs_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
abs_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::abs_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

angle_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
angle_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::angle(
    *$(at::Tensor* _self)));
  }|]

angle_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
angle_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::angle_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

real_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
real_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::real(
    *$(at::Tensor* _self)));
  }|]

imag_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
imag_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::imag(
    *$(at::Tensor* _self)));
  }|]

conj_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
conj_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conj(
    *$(at::Tensor* _self)));
  }|]

conj_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conj_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conj_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

acos_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
acos_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::acos(
    *$(at::Tensor* _self)));
  }|]

acos__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
acos__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::acos_(
    *$(at::Tensor* _self)));
  }|]

acos_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
acos_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::acos_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

avg_pool1d_tlllbb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool1d_tlllbb _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool1d_tlllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
avg_pool1d_tlllb _self _kernel_size _stride _padding _ceil_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)));
  }|]

avg_pool1d_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool1d_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

avg_pool1d_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool1d_tll _self _kernel_size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

avg_pool1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool1d_tl _self _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

adaptive_avg_pool1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool1d_tl _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
adaptive_max_pool1d_tl _self _output_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

add_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_tts _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::add(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

add_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
add_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::add(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

add_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_out_ttts _out _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::add_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

add_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
add_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::add_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

add_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_tss _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::add(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

add_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::add(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

addmv_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv_tttss _self _mat _vec _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmv_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv_ttts _self _mat _vec _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)));
  }|]

addmv_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addmv_ttt _self _mat _vec =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)));
  }|]

addmv__tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv__tttss _self _mat _vec _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmv__ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv__ttts _self _mat _vec _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)));
  }|]

addmv__ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addmv__ttt _self _mat _vec =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)));
  }|]

addmv_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv_out_ttttss _out _self _mat _vec _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmv_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv_out_tttts _out _self _mat _vec _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)));
  }|]

addmv_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addmv_out_tttt _out _self _mat _vec =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)));
  }|]

addr_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addr_tttss _self _vec1 _vec2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addr_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addr_ttts _self _vec1 _vec2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)));
  }|]

addr_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addr_ttt _self _vec1 _vec2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)));
  }|]

addr_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addr_out_ttttss _out _self _vec1 _vec2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addr_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addr_out_tttts _out _self _vec1 _vec2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)));
  }|]

addr_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addr_out_tttt _out _self _vec1 _vec2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)));
  }|]

affine_grid_generator_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
affine_grid_generator_tlb _theta _size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::affine_grid_generator(
    *$(at::Tensor* _theta)
  , *$(std::vector<int64_t>* _size)
  , $(bool _align_corners)));
  }|]

affine_grid_generator_backward_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
affine_grid_generator_backward_tlb _grad _size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::affine_grid_generator_backward(
    *$(at::Tensor* _grad)
  , *$(std::vector<int64_t>* _size)
  , $(bool _align_corners)));
  }|]

all_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
all_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

all_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
all_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

all_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
all_out_ttlb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

all_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
all_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

all_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr Tensor)
all_tnb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

all_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
all_tn _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

all_out_ttnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr Tensor)
all_out_ttnb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

all_out_ttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
all_out_ttn _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

allclose_ttddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (CBool)
allclose_ttddb _self _other _rtol _atol _equal_nan =
  [C.throwBlock| bool { return (at::allclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)
  , $(double _atol)
  , $(bool _equal_nan)));
  }|]

allclose_ttdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> IO (CBool)
allclose_ttdd _self _other _rtol _atol =
  [C.throwBlock| bool { return (at::allclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)
  , $(double _atol)));
  }|]

allclose_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (CBool)
allclose_ttd _self _other _rtol =
  [C.throwBlock| bool { return (at::allclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)));
  }|]

allclose_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (CBool)
allclose_tt _self _other =
  [C.throwBlock| bool { return (at::allclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

any_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
any_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

any_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
any_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

any_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
any_out_ttlb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

any_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
any_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

any_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr Tensor)
any_tnb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

any_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
any_tn _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

any_out_ttnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr Tensor)
any_out_ttnb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

any_out_ttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
any_out_ttn _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

arange_so
  :: Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_so _end _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _end)
  , *$(at::TensorOptions* _options)));
  }|]

arange_s
  :: Ptr Scalar
  -> IO (Ptr Tensor)
arange_s _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _end)));
  }|]

arange_sso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_sso _start _end _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::TensorOptions* _options)));
  }|]

arange_ss
  :: Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_ss _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

arange_ssso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_ssso _start _end _step _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)
  , *$(at::TensorOptions* _options)));
  }|]

arange_sss
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_sss _start _end _step =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)));
  }|]

arange_out_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_out_ts _out _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _end)));
  }|]

arange_out_tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_out_tsss _out _start _end _step =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)));
  }|]

arange_out_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_out_tss _out _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

_dim_arange_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_dim_arange_tl _like _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_dim_arange(
    *$(at::Tensor* _like)
  , $(int64_t _dim)));
  }|]

argmax_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
argmax_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

argmax_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
argmax_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

argmax_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
argmax_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argmax(
    *$(at::Tensor* _self)));
  }|]

argmin_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
argmin_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argmin(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

argmin_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
argmin_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argmin(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

argmin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
argmin_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argmin(
    *$(at::Tensor* _self)));
  }|]

as_strided_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
as_strided_tlll _self _size _stride _storage_offset =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::as_strided(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)
  , $(int64_t _storage_offset)));
  }|]

as_strided_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
as_strided_tll _self _size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::as_strided(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

as_strided__tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
as_strided__tlll _self _size _stride _storage_offset =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::as_strided_(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)
  , $(int64_t _storage_offset)));
  }|]

as_strided__tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
as_strided__tll _self _size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::as_strided_(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

asin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
asin_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::asin(
    *$(at::Tensor* _self)));
  }|]

asin__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
asin__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::asin_(
    *$(at::Tensor* _self)));
  }|]

asin_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
asin_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::asin_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

atan_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
atan_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::atan(
    *$(at::Tensor* _self)));
  }|]

atan__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
atan__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::atan_(
    *$(at::Tensor* _self)));
  }|]

atan_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
atan_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::atan_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

baddbmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
baddbmm_tttss _self _batch1 _batch2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::baddbmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

baddbmm_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
baddbmm_ttts _self _batch1 _batch2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::baddbmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)));
  }|]

baddbmm_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
baddbmm_ttt _self _batch1 _batch2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::baddbmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)));
  }|]

_baddbmm_mkl__tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_baddbmm_mkl__tttss _self _batch1 _batch2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_baddbmm_mkl_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

_baddbmm_mkl__ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_baddbmm_mkl__ttts _self _batch1 _batch2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_baddbmm_mkl_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)));
  }|]

_baddbmm_mkl__ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_baddbmm_mkl__ttt _self _batch1 _batch2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_baddbmm_mkl_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)));
  }|]

baddbmm_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
baddbmm_out_ttttss _out _self _batch1 _batch2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::baddbmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

baddbmm_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
baddbmm_out_tttts _out _self _batch1 _batch2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::baddbmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)));
  }|]

baddbmm_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
baddbmm_out_tttt _out _self _batch1 _batch2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::baddbmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)));
  }|]

bartlett_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
bartlett_window_lo _window_length _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bartlett_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

bartlett_window_l
  :: Int64
  -> IO (Ptr Tensor)
bartlett_window_l _window_length =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bartlett_window(
    $(int64_t _window_length)));
  }|]

bartlett_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
bartlett_window_lbo _window_length _periodic _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bartlett_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

bartlett_window_lb
  :: Int64
  -> CBool
  -> IO (Ptr Tensor)
bartlett_window_lb _window_length _periodic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bartlett_window(
    $(int64_t _window_length)
  , $(bool _periodic)));
  }|]

batch_norm_tttttbddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
batch_norm_tttttbddb _input _weight _bias _running_mean _running_var _training _momentum _eps _cudnn_enabled =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::batch_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(double _momentum)
  , $(double _eps)
  , $(bool _cudnn_enabled)));
  }|]

quantized_batch_norm_tttttddl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
quantized_batch_norm_tttttddl _input _weight _bias _mean _var _eps _output_scale _output_zero_point =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantized_batch_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _var)
  , $(double _eps)
  , $(double _output_scale)
  , $(int64_t _output_zero_point)));
  }|]

_batch_norm_impl_index_tttttbddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor,Int64)))
_batch_norm_impl_index_tttttbddb _input _weight _bias _running_mean _running_var _training _momentum _eps _cudnn_enabled =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,int64_t>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,int64_t>(at::_batch_norm_impl_index(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(double _momentum)
  , $(double _eps)
  , $(bool _cudnn_enabled)));
  }|]

_batch_norm_impl_index_backward_ltttttttbdat
  :: Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> Ptr (StdArray '(CBool,3))
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_batch_norm_impl_index_backward_ltttttttbdat _impl_index _input _grad_output _weight _running_mean _running_var _save_mean _save_var_transform _train _eps _output_mask _reservedSpace =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_batch_norm_impl_index_backward(
    $(int64_t _impl_index)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , *$(at::Tensor* _save_mean)
  , *$(at::Tensor* _save_var_transform)
  , $(bool _train)
  , $(double _eps)
  , *$(std::array<bool,3>* _output_mask)
  , *$(at::Tensor* _reservedSpace)));
  }|]

bernoulli_tp
  :: Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_tp _self _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bernoulli(
    *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

bernoulli_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
bernoulli_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bernoulli(
    *$(at::Tensor* _self)));
  }|]

bernoulli_out_ttp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_out_ttp _out _self _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bernoulli_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

bernoulli_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bernoulli_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bernoulli_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

bernoulli_tdp
  :: Ptr Tensor
  -> CDouble
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_tdp _self _p _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bernoulli(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(at::Generator * _generator)));
  }|]

bernoulli_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
bernoulli_td _self _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bernoulli(
    *$(at::Tensor* _self)
  , $(double _p)));
  }|]

bilinear_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bilinear_tttt _input1 _input2 _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bilinear(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

binary_cross_entropy_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_tttl _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_ttt _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

binary_cross_entropy_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

binary_cross_entropy_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_out_ttttl _out _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_out_tttt _out _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

binary_cross_entropy_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

binary_cross_entropy_backward_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_ttttl _grad_output _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_backward_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_tttt _grad_output _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

binary_cross_entropy_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_ttt _grad_output _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

binary_cross_entropy_backward_out_tttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_out_tttttl _grad_input _grad_output _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_backward_out_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_out_ttttt _grad_input _grad_output _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

binary_cross_entropy_backward_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_out_tttt _grad_input _grad_output _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

binary_cross_entropy_with_logits_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_ttttl _self _target _weight _pos_weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _pos_weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_with_logits_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_tttt _self _target _weight _pos_weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _pos_weight)));
  }|]

binary_cross_entropy_with_logits_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_ttt _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

binary_cross_entropy_with_logits_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

binary_cross_entropy_with_logits_backward_tttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_backward_tttttl _grad_output _self _target _weight _pos_weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _pos_weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_with_logits_backward_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_backward_ttttt _grad_output _self _target _weight _pos_weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _pos_weight)));
  }|]

binary_cross_entropy_with_logits_backward_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_backward_tttt _grad_output _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

binary_cross_entropy_with_logits_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_backward_ttt _grad_output _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

bincount_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
bincount_ttl _self _weights _minlength =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bincount(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weights)
  , $(int64_t _minlength)));
  }|]

bincount_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bincount_tt _self _weights =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bincount(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weights)));
  }|]

bincount_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
bincount_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bincount(
    *$(at::Tensor* _self)));
  }|]

bitwise_not_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
bitwise_not_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_not(
    *$(at::Tensor* _self)));
  }|]

bitwise_not_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bitwise_not_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_not_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

logical_not_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
logical_not_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_not(
    *$(at::Tensor* _self)));
  }|]

logical_not_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_not_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_not_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

logical_xor_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_xor_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_xor(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

logical_xor_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_xor_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_xor_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

logical_and_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_and_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_and(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

logical_and_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_and_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_and_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

logical_or_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_or_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_or(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

logical_or_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_or_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_or_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

blackman_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
blackman_window_lo _window_length _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::blackman_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

blackman_window_l
  :: Int64
  -> IO (Ptr Tensor)
blackman_window_l _window_length =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::blackman_window(
    $(int64_t _window_length)));
  }|]

blackman_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
blackman_window_lbo _window_length _periodic _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::blackman_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

blackman_window_lb
  :: Int64
  -> CBool
  -> IO (Ptr Tensor)
blackman_window_lb _window_length _periodic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::blackman_window(
    $(int64_t _window_length)
  , $(bool _periodic)));
  }|]

bmm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bmm_tt _self _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

bmm_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bmm_out_ttt _out _self _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

broadcast_tensors_l
  :: Ptr TensorList
  -> IO (Ptr TensorList)
broadcast_tensors_l _tensors =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::broadcast_tensors(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

cat_ll
  :: Ptr TensorList
  -> Int64
  -> IO (Ptr Tensor)
cat_ll _tensors _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cat(
    *$(std::vector<at::Tensor>* _tensors)
  , $(int64_t _dim)));
  }|]

cat_l
  :: Ptr TensorList
  -> IO (Ptr Tensor)
cat_l _tensors =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cat(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

cat_out_tll
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> IO (Ptr Tensor)
cat_out_tll _out _tensors _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cat_out(
    *$(at::Tensor* _out)
  , *$(std::vector<at::Tensor>* _tensors)
  , $(int64_t _dim)));
  }|]

cat_out_tl
  :: Ptr Tensor
  -> Ptr TensorList
  -> IO (Ptr Tensor)
cat_out_tl _out _tensors =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cat_out(
    *$(at::Tensor* _out)
  , *$(std::vector<at::Tensor>* _tensors)));
  }|]

cat_ln
  :: Ptr TensorList
  -> Ptr Dimname
  -> IO (Ptr Tensor)
cat_ln _tensors _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cat(
    *$(std::vector<at::Tensor>* _tensors)
  , *$(at::Dimname* _dim)));
  }|]

cat_out_tln
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Dimname
  -> IO (Ptr Tensor)
cat_out_tln _out _tensors _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cat_out(
    *$(at::Tensor* _out)
  , *$(std::vector<at::Tensor>* _tensors)
  , *$(at::Dimname* _dim)));
  }|]

ceil_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
ceil_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ceil(
    *$(at::Tensor* _self)));
  }|]

ceil__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
ceil__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ceil_(
    *$(at::Tensor* _self)));
  }|]

ceil_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ceil_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ceil_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

chain_matmul_l
  :: Ptr TensorList
  -> IO (Ptr Tensor)
chain_matmul_l _matrices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::chain_matmul(
    *$(std::vector<at::Tensor>* _matrices)));
  }|]

chunk_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr TensorList)
chunk_tll _self _chunks _dim =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::chunk(
    *$(at::Tensor* _self)
  , $(int64_t _chunks)
  , $(int64_t _dim)));
  }|]

chunk_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr TensorList)
chunk_tl _self _chunks =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::chunk(
    *$(at::Tensor* _self)
  , $(int64_t _chunks)));
  }|]

clamp_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_tss _self _min _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

clamp_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_ts _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clamp_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
clamp_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp(
    *$(at::Tensor* _self)));
  }|]

clamp__tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp__tss _self _min _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

clamp__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp__ts _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clamp__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
clamp__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_(
    *$(at::Tensor* _self)));
  }|]

clamp_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_out_ttss _out _self _min _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

clamp_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_out_tts _out _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clamp_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
clamp_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

clamp_max_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_max_ts _self _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_max(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _max)));
  }|]

clamp_max__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_max__ts _self _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_max_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _max)));
  }|]

clamp_max_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_max_out_tts _out _self _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_max_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _max)));
  }|]

clamp_min_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_min_ts _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_min(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clamp_min__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_min__ts _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_min_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clamp_min_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_min_out_tts _out _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_min_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

cudnn_is_acceptable_t
  :: Ptr Tensor
  -> IO (CBool)
cudnn_is_acceptable_t _self =
  [C.throwBlock| bool { return (at::cudnn_is_acceptable(
    *$(at::Tensor* _self)));
  }|]

constant_pad_nd_tls
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Scalar
  -> IO (Ptr Tensor)
constant_pad_nd_tls _self _pad _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::constant_pad_nd(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _pad)
  , *$(at::Scalar* _value)));
  }|]

constant_pad_nd_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
constant_pad_nd_tl _self _pad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::constant_pad_nd(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _pad)));
  }|]

convolution_tttlllbll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
convolution_tttlllbll _input _weight _bias _stride _padding _dilation _transposed _output_padding _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::convolution(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)));
  }|]

convolution_overrideable_tttlllbll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
convolution_overrideable_tttlllbll _input _weight _bias _stride _padding _dilation _transposed _output_padding _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::convolution_overrideable(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)));
  }|]

convolution_backward_overrideable_tttlllblla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
convolution_backward_overrideable_tttlllblla _grad_output _input _weight _stride _padding _dilation _transposed _output_padding _groups _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::convolution_backward_overrideable(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

_convolution_tttlllbllbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
_convolution_tttlllbllbbb _input _weight _bias _stride _padding _dilation _transposed _output_padding _groups _benchmark _deterministic _cudnn_enabled =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_convolution(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , $(bool _cudnn_enabled)));
  }|]

_convolution_nogroup_tttlllbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_convolution_nogroup_tttlllbl _input _weight _bias _stride _padding _dilation _transposed _output_padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_convolution_nogroup(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)));
  }|]

_convolution_double_backward_ttttttlllbllbbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> CBool
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_convolution_double_backward_ttttttlllbllbbba _ggI _ggW _ggb _gO _weight _self _stride _padding _dilation _transposed _output_padding _groups _benchmark _deterministic _cudnn_enabled _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_convolution_double_backward(
    *$(at::Tensor* _ggI)
  , *$(at::Tensor* _ggW)
  , *$(at::Tensor* _ggb)
  , *$(at::Tensor* _gO)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , $(bool _cudnn_enabled)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

conv1d_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
conv1d_tttllll _input _weight _bias _stride _padding _dilation _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)));
  }|]

conv1d_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv1d_tttlll _input _weight _bias _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

conv1d_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv1d_tttll _input _weight _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

conv1d_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv1d_tttl _input _weight _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

conv1d_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv1d_ttt _input _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

conv1d_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv1d_tt _input _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)));
  }|]

conv2d_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
conv2d_tttllll _input _weight _bias _stride _padding _dilation _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)));
  }|]

conv2d_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv2d_tttlll _input _weight _bias _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

conv2d_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv2d_tttll _input _weight _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

conv2d_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv2d_tttl _input _weight _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

conv2d_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv2d_ttt _input _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

conv2d_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv2d_tt _input _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)));
  }|]

conv3d_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
conv3d_tttllll _input _weight _bias _stride _padding _dilation _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)));
  }|]

conv3d_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv3d_tttlll _input _weight _bias _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

conv3d_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv3d_tttll _input _weight _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

conv3d_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv3d_tttl _input _weight _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

conv3d_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv3d_ttt _input _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

conv3d_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv3d_tt _input _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)));
  }|]

conv_tbc_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
conv_tbc_tttl _self _weight _bias _pad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_tbc(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(int64_t _pad)));
  }|]

conv_tbc_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv_tbc_ttt _self _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_tbc(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

conv_tbc_backward_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
conv_tbc_backward_ttttl _self _input _weight _bias _pad =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::conv_tbc_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(int64_t _pad)));
  }|]

conv_transpose1d_tttlllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose1d_tttlllll _input _weight _bias _stride _padding _output_padding _groups _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

conv_transpose1d_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
conv_transpose1d_tttllll _input _weight _bias _stride _padding _output_padding _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)));
  }|]

conv_transpose1d_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose1d_tttlll _input _weight _bias _stride _padding _output_padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)));
  }|]

conv_transpose1d_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose1d_tttll _input _weight _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

conv_transpose1d_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose1d_tttl _input _weight _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

conv_transpose1d_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv_transpose1d_ttt _input _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

conv_transpose1d_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv_transpose1d_tt _input _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)));
  }|]

conv_transpose2d_tttlllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose2d_tttlllll _input _weight _bias _stride _padding _output_padding _groups _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

conv_transpose2d_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
conv_transpose2d_tttllll _input _weight _bias _stride _padding _output_padding _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)));
  }|]

conv_transpose2d_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose2d_tttlll _input _weight _bias _stride _padding _output_padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)));
  }|]

conv_transpose2d_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose2d_tttll _input _weight _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

conv_transpose2d_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose2d_tttl _input _weight _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

conv_transpose2d_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv_transpose2d_ttt _input _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

conv_transpose2d_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv_transpose2d_tt _input _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)));
  }|]

conv_transpose3d_tttlllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose3d_tttlllll _input _weight _bias _stride _padding _output_padding _groups _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

conv_transpose3d_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
conv_transpose3d_tttllll _input _weight _bias _stride _padding _output_padding _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)));
  }|]

conv_transpose3d_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose3d_tttlll _input _weight _bias _stride _padding _output_padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)));
  }|]

conv_transpose3d_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose3d_tttll _input _weight _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

conv_transpose3d_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose3d_tttl _input _weight _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

conv_transpose3d_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv_transpose3d_ttt _input _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

conv_transpose3d_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv_transpose3d_tt _input _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv_transpose3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)));
  }|]

_copy_from_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_copy_from_ttb _self _dst _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_copy_from(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _dst)
  , $(bool _non_blocking)));
  }|]

_copy_from_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_copy_from_tt _self _dst =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_copy_from(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _dst)));
  }|]

cos_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cos_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cos(
    *$(at::Tensor* _self)));
  }|]

cos__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cos__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cos_(
    *$(at::Tensor* _self)));
  }|]

cos_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cos_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cos_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

cosh_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cosh_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cosh(
    *$(at::Tensor* _self)));
  }|]

cosh__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cosh__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cosh_(
    *$(at::Tensor* _self)));
  }|]

cosh_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cosh_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cosh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

cosine_embedding_loss_tttdl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
cosine_embedding_loss_tttdl _input1 _input2 _target _margin _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cosine_embedding_loss(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _target)
  , $(double _margin)
  , $(int64_t _reduction)));
  }|]

cosine_embedding_loss_tttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
cosine_embedding_loss_tttd _input1 _input2 _target _margin =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cosine_embedding_loss(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _target)
  , $(double _margin)));
  }|]

cosine_embedding_loss_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cosine_embedding_loss_ttt _input1 _input2 _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cosine_embedding_loss(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _target)));
  }|]

cudnn_affine_grid_generator_tllll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
cudnn_affine_grid_generator_tllll _theta _N _C _H _W =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cudnn_affine_grid_generator(
    *$(at::Tensor* _theta)
  , $(int64_t _N)
  , $(int64_t _C)
  , $(int64_t _H)
  , $(int64_t _W)));
  }|]

cudnn_affine_grid_generator_backward_tllll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
cudnn_affine_grid_generator_backward_tllll _grad _N _C _H _W =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cudnn_affine_grid_generator_backward(
    *$(at::Tensor* _grad)
  , $(int64_t _N)
  , $(int64_t _C)
  , $(int64_t _H)
  , $(int64_t _W)));
  }|]

cudnn_batch_norm_tttttbdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
cudnn_batch_norm_tttttbdd _input _weight _bias _running_mean _running_var _training _exponential_average_factor _epsilon =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::cudnn_batch_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(double _exponential_average_factor)
  , $(double _epsilon)));
  }|]

cudnn_batch_norm_backward_tttttttdt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
cudnn_batch_norm_backward_tttttttdt _input _grad_output _weight _running_mean _running_var _save_mean _save_var _epsilon _reserveSpace =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::cudnn_batch_norm_backward(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , *$(at::Tensor* _save_mean)
  , *$(at::Tensor* _save_var)
  , $(double _epsilon)
  , *$(at::Tensor* _reserveSpace)));
  }|]

cudnn_convolution_tttllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_tttllllbb _self _weight _bias _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cudnn_convolution(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_convolution_ttllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_ttllllbb _self _weight _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cudnn_convolution(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_convolution_backward_input_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_backward_input_lttllllbb _self_size _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cudnn_convolution_backward_input(
    *$(std::vector<int64_t>* _self_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_convolution_backward_tttllllbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> Ptr (StdArray '(CBool,2))
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
cudnn_convolution_backward_tttllllbba _self _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::cudnn_convolution_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , *$(std::array<bool,2>* _output_mask)));
  }|]

cudnn_convolution_backward_weight_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_backward_weight_lttllllbb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cudnn_convolution_backward_weight(
    *$(std::vector<int64_t>* _weight_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_convolution_transpose_tttlllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_transpose_tttlllllbb _self _weight _bias _padding _output_padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cudnn_convolution_transpose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_convolution_transpose_ttlllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_transpose_ttlllllbb _self _weight _padding _output_padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cudnn_convolution_transpose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_convolution_transpose_backward_tttlllllbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> Ptr (StdArray '(CBool,2))
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
cudnn_convolution_transpose_backward_tttlllllbba _self _grad_output _weight _padding _output_padding _stride _dilation _groups _benchmark _deterministic _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::cudnn_convolution_transpose_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , *$(std::array<bool,2>* _output_mask)));
  }|]

cudnn_convolution_transpose_backward_input_ttllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_transpose_backward_input_ttllllbb _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cudnn_convolution_transpose_backward_input(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_convolution_transpose_backward_weight_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_transpose_backward_weight_lttllllbb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cudnn_convolution_transpose_backward_weight(
    *$(std::vector<int64_t>* _weight_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_grid_sampler_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cudnn_grid_sampler_tt _self _grid =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cudnn_grid_sampler(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grid)));
  }|]

cudnn_grid_sampler_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
cudnn_grid_sampler_backward_ttt _self _grid _grad_output =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::cudnn_grid_sampler_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grid)
  , *$(at::Tensor* _grad_output)));
  }|]

cummax_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
cummax_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::cummax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

cummax_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
cummax_out_tttl _values _indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::cummax_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

cummax_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
cummax_tn _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::cummax(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

cummax_out_tttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
cummax_out_tttn _values _indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::cummax_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

_cummax_helper_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (())
_cummax_helper_tttl _self _values _indices _dim =
  [C.throwBlock| void {  (at::_cummax_helper(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , $(int64_t _dim)));
  }|]

cummin_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
cummin_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::cummin(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

cummin_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
cummin_out_tttl _values _indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::cummin_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

cummin_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
cummin_tn _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::cummin(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

cummin_out_tttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
cummin_out_tttn _values _indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::cummin_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

_cummin_helper_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (())
_cummin_helper_tttl _self _values _indices _dim =
  [C.throwBlock| void {  (at::_cummin_helper(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , $(int64_t _dim)));
  }|]

cumprod_tls
  :: Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
cumprod_tls _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumprod(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

cumprod_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cumprod_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumprod(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

cumprod_out_ttls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
cumprod_out_ttls _out _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumprod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

cumprod_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cumprod_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumprod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

cumprod_tns
  :: Ptr Tensor
  -> Ptr Dimname
  -> ScalarType
  -> IO (Ptr Tensor)
cumprod_tns _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumprod(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(at::ScalarType _dtype)));
  }|]

cumprod_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
cumprod_tn _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumprod(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

cumprod_out_ttns
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> ScalarType
  -> IO (Ptr Tensor)
cumprod_out_ttns _out _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumprod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(at::ScalarType _dtype)));
  }|]

cumprod_out_ttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
cumprod_out_ttn _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumprod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

cumsum_tls
  :: Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
cumsum_tls _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumsum(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

cumsum_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cumsum_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumsum(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

cumsum_out_ttls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
cumsum_out_ttls _out _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumsum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

cumsum_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cumsum_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumsum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

cumsum_tns
  :: Ptr Tensor
  -> Ptr Dimname
  -> ScalarType
  -> IO (Ptr Tensor)
cumsum_tns _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumsum(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(at::ScalarType _dtype)));
  }|]

cumsum_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
cumsum_tn _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumsum(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

cumsum_out_ttns
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> ScalarType
  -> IO (Ptr Tensor)
cumsum_out_ttns _out _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumsum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(at::ScalarType _dtype)));
  }|]

cumsum_out_ttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
cumsum_out_ttn _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cumsum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

ctc_loss_ttllllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
ctc_loss_ttllllb _log_probs _targets _input_lengths _target_lengths _blank _reduction _zero_infinity =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , $(int64_t _blank)
  , $(int64_t _reduction)
  , $(bool _zero_infinity)));
  }|]

ctc_loss_ttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
ctc_loss_ttllll _log_probs _targets _input_lengths _target_lengths _blank _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , $(int64_t _blank)
  , $(int64_t _reduction)));
  }|]

ctc_loss_ttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
ctc_loss_ttlll _log_probs _targets _input_lengths _target_lengths _blank =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , $(int64_t _blank)));
  }|]

ctc_loss_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
ctc_loss_ttll _log_probs _targets _input_lengths _target_lengths =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)));
  }|]

ctc_loss_ttttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
ctc_loss_ttttllb _log_probs _targets _input_lengths _target_lengths _blank _reduction _zero_infinity =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(at::Tensor* _input_lengths)
  , *$(at::Tensor* _target_lengths)
  , $(int64_t _blank)
  , $(int64_t _reduction)
  , $(bool _zero_infinity)));
  }|]

ctc_loss_ttttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
ctc_loss_ttttll _log_probs _targets _input_lengths _target_lengths _blank _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(at::Tensor* _input_lengths)
  , *$(at::Tensor* _target_lengths)
  , $(int64_t _blank)
  , $(int64_t _reduction)));
  }|]

ctc_loss_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
ctc_loss_ttttl _log_probs _targets _input_lengths _target_lengths _blank =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(at::Tensor* _input_lengths)
  , *$(at::Tensor* _target_lengths)
  , $(int64_t _blank)));
  }|]

ctc_loss_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ctc_loss_tttt _log_probs _targets _input_lengths _target_lengths =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(at::Tensor* _input_lengths)
  , *$(at::Tensor* _target_lengths)));
  }|]

_ctc_loss_ttlllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_ctc_loss_ttlllb _log_probs _targets _input_lengths _target_lengths _blank _zero_infinity =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , $(int64_t _blank)
  , $(bool _zero_infinity)));
  }|]

_ctc_loss_ttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_ctc_loss_ttlll _log_probs _targets _input_lengths _target_lengths _blank =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , $(int64_t _blank)));
  }|]

_ctc_loss_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_ctc_loss_ttll _log_probs _targets _input_lengths _target_lengths =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)));
  }|]

_ctc_loss_backward_tttllttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
_ctc_loss_backward_tttllttlb _grad _log_probs _targets _input_lengths _target_lengths _neg_log_likelihood _log_alpha _blank _zero_infinity =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_ctc_loss_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , *$(at::Tensor* _neg_log_likelihood)
  , *$(at::Tensor* _log_alpha)
  , $(int64_t _blank)
  , $(bool _zero_infinity)));
  }|]

_ctc_loss_backward_tttllttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_ctc_loss_backward_tttllttl _grad _log_probs _targets _input_lengths _target_lengths _neg_log_likelihood _log_alpha _blank =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_ctc_loss_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , *$(at::Tensor* _neg_log_likelihood)
  , *$(at::Tensor* _log_alpha)
  , $(int64_t _blank)));
  }|]

det_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
det_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::det(
    *$(at::Tensor* _self)));
  }|]

diag_embed_tlll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
diag_embed_tlll _self _offset _dim1 _dim2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diag_embed(
    *$(at::Tensor* _self)
  , $(int64_t _offset)
  , $(int64_t _dim1)
  , $(int64_t _dim2)));
  }|]

diag_embed_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
diag_embed_tll _self _offset _dim1 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diag_embed(
    *$(at::Tensor* _self)
  , $(int64_t _offset)
  , $(int64_t _dim1)));
  }|]

diag_embed_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
diag_embed_tl _self _offset =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diag_embed(
    *$(at::Tensor* _self)
  , $(int64_t _offset)));
  }|]

diag_embed_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
diag_embed_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diag_embed(
    *$(at::Tensor* _self)));
  }|]

diagflat_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
diagflat_tl _self _offset =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diagflat(
    *$(at::Tensor* _self)
  , $(int64_t _offset)));
  }|]

diagflat_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
diagflat_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diagflat(
    *$(at::Tensor* _self)));
  }|]

diagonal_tlll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
diagonal_tlll _self _offset _dim1 _dim2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diagonal(
    *$(at::Tensor* _self)
  , $(int64_t _offset)
  , $(int64_t _dim1)
  , $(int64_t _dim2)));
  }|]

diagonal_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
diagonal_tll _self _offset _dim1 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diagonal(
    *$(at::Tensor* _self)
  , $(int64_t _offset)
  , $(int64_t _dim1)));
  }|]

diagonal_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
diagonal_tl _self _offset =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diagonal(
    *$(at::Tensor* _self)
  , $(int64_t _offset)));
  }|]

diagonal_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
diagonal_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diagonal(
    *$(at::Tensor* _self)));
  }|]

diagonal_tnnnl
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Dimname
  -> Ptr Dimname
  -> Int64
  -> IO (Ptr Tensor)
diagonal_tnnnl _self _outdim _dim1 _dim2 _offset =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diagonal(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _outdim)
  , *$(at::Dimname* _dim1)
  , *$(at::Dimname* _dim2)
  , $(int64_t _offset)));
  }|]

diagonal_tnnn
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Dimname
  -> Ptr Dimname
  -> IO (Ptr Tensor)
diagonal_tnnn _self _outdim _dim1 _dim2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diagonal(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _outdim)
  , *$(at::Dimname* _dim1)
  , *$(at::Dimname* _dim2)));
  }|]

div_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
div_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::div(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

div_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
div_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::div_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

div_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
div_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::div(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

dot_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
dot_tt _self _tensor =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::dot(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor)));
  }|]

dot_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
dot_out_ttt _out _self _tensor =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::dot_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor)));
  }|]

einsum_sl
  :: Ptr StdString
  -> Ptr TensorList
  -> IO (Ptr Tensor)
einsum_sl _equation _tensors =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::einsum(
    *$(std::string* _equation)
  , *$(std::vector<at::Tensor>* _tensors)));
  }|]

embedding_ttlbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
embedding_ttlbb _weight _indices _padding_idx _scale_grad_by_freq _sparse =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::embedding(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , $(int64_t _padding_idx)
  , $(bool _scale_grad_by_freq)
  , $(bool _sparse)));
  }|]

embedding_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
embedding_ttlb _weight _indices _padding_idx _scale_grad_by_freq =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::embedding(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , $(int64_t _padding_idx)
  , $(bool _scale_grad_by_freq)));
  }|]

embedding_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
embedding_ttl _weight _indices _padding_idx =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::embedding(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , $(int64_t _padding_idx)));
  }|]

embedding_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
embedding_tt _weight _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::embedding(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)));
  }|]

embedding_backward_ttllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
embedding_backward_ttllbb _grad _indices _num_weights _padding_idx _scale_grad_by_freq _sparse =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::embedding_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , $(int64_t _num_weights)
  , $(int64_t _padding_idx)
  , $(bool _scale_grad_by_freq)
  , $(bool _sparse)));
  }|]

embedding_dense_backward_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
embedding_dense_backward_ttllb _grad_output _indices _num_weights _padding_idx _scale_grad_by_freq =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::embedding_dense_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _indices)
  , $(int64_t _num_weights)
  , $(int64_t _padding_idx)
  , $(bool _scale_grad_by_freq)));
  }|]

embedding_renorm__ttdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
embedding_renorm__ttdd _self _indices _max_norm _norm_type =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::embedding_renorm_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , $(double _max_norm)
  , $(double _norm_type)));
  }|]

embedding_sparse_backward_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
embedding_sparse_backward_ttllb _grad _indices _num_weights _padding_idx _scale_grad_by_freq =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::embedding_sparse_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , $(int64_t _num_weights)
  , $(int64_t _padding_idx)
  , $(bool _scale_grad_by_freq)));
  }|]

embedding_bag_tttblbtb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Int64
  -> CBool
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
embedding_bag_tttblbtb _weight _indices _offsets _scale_grad_by_freq _mode _sparse _per_sample_weights _include_last_offset =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)
  , $(bool _sparse)
  , *$(at::Tensor* _per_sample_weights)
  , $(bool _include_last_offset)));
  }|]

embedding_bag_tttblbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Int64
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
embedding_bag_tttblbt _weight _indices _offsets _scale_grad_by_freq _mode _sparse _per_sample_weights =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)
  , $(bool _sparse)
  , *$(at::Tensor* _per_sample_weights)));
  }|]

embedding_bag_tttblb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
embedding_bag_tttblb _weight _indices _offsets _scale_grad_by_freq _mode _sparse =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)
  , $(bool _sparse)));
  }|]

embedding_bag_tttbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
embedding_bag_tttbl _weight _indices _offsets _scale_grad_by_freq _mode =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)));
  }|]

embedding_bag_tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
embedding_bag_tttb _weight _indices _offsets _scale_grad_by_freq =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)));
  }|]

embedding_bag_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
embedding_bag_ttt _weight _indices _offsets =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)));
  }|]

_embedding_bag_tttblbtb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Int64
  -> CBool
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
_embedding_bag_tttblbtb _weight _indices _offsets _scale_grad_by_freq _mode _sparse _per_sample_weights _include_last_offset =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)
  , $(bool _sparse)
  , *$(at::Tensor* _per_sample_weights)
  , $(bool _include_last_offset)));
  }|]

_embedding_bag_tttblbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Int64
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
_embedding_bag_tttblbt _weight _indices _offsets _scale_grad_by_freq _mode _sparse _per_sample_weights =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)
  , $(bool _sparse)
  , *$(at::Tensor* _per_sample_weights)));
  }|]

_embedding_bag_tttblb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
_embedding_bag_tttblb _weight _indices _offsets _scale_grad_by_freq _mode _sparse =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)
  , $(bool _sparse)));
  }|]

_embedding_bag_tttbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
_embedding_bag_tttbl _weight _indices _offsets _scale_grad_by_freq _mode =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)));
  }|]

_embedding_bag_tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
_embedding_bag_tttb _weight _indices _offsets _scale_grad_by_freq =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)));
  }|]

_embedding_bag_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
_embedding_bag_ttt _weight _indices _offsets =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)));
  }|]

_embedding_bag_backward_ttttttlblbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> Int64
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_embedding_bag_backward_ttttttlblbt _grad _indices _offsets _offset2bag _bag_size _maximum_indices _num_weights _scale_grad_by_freq _mode _sparse _per_sample_weights =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_embedding_bag_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , *$(at::Tensor* _offset2bag)
  , *$(at::Tensor* _bag_size)
  , *$(at::Tensor* _maximum_indices)
  , $(int64_t _num_weights)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)
  , $(bool _sparse)
  , *$(at::Tensor* _per_sample_weights)));
  }|]

_embedding_bag_sparse_backward_tttttlblt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_embedding_bag_sparse_backward_tttttlblt _grad _indices _offsets _offset2bag _bag_size _num_weights _scale_grad_by_freq _mode _per_sample_weights =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_embedding_bag_sparse_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , *$(at::Tensor* _offset2bag)
  , *$(at::Tensor* _bag_size)
  , $(int64_t _num_weights)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)
  , *$(at::Tensor* _per_sample_weights)));
  }|]

_embedding_bag_dense_backward_ttttttlblt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_embedding_bag_dense_backward_ttttttlblt _grad _indices _offsets _offset2bag _bag_size _maximum_indices _num_weights _scale_grad_by_freq _mode _per_sample_weights =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_embedding_bag_dense_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , *$(at::Tensor* _offset2bag)
  , *$(at::Tensor* _bag_size)
  , *$(at::Tensor* _maximum_indices)
  , $(int64_t _num_weights)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)
  , *$(at::Tensor* _per_sample_weights)));
  }|]

_embedding_bag_per_sample_weights_backward_tttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_embedding_bag_per_sample_weights_backward_tttttl _grad _weight _indices _offsets _offset2bag _mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_embedding_bag_per_sample_weights_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , *$(at::Tensor* _offset2bag)
  , $(int64_t _mode)));
  }|]

empty_lNoM
  :: Ptr IntArray
  -> Ptr DimnameList
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
empty_lNoM _size _names _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::empty(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

empty_lNo
  :: Ptr IntArray
  -> Ptr DimnameList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_lNo _size _names _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::empty(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)
  , *$(at::TensorOptions* _options)));
  }|]

empty_lN
  :: Ptr IntArray
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
empty_lN _size _names =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::empty(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)));
  }|]

empty_loM
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
empty_loM _size _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::empty(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

empty_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::empty(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

empty_l
  :: Ptr IntArray
  -> IO (Ptr Tensor)
empty_l _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::empty(
    *$(std::vector<int64_t>* _size)));
  }|]

_empty_affine_quantized_lodlM
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> CDouble
  -> Int64
  -> MemoryFormat
  -> IO (Ptr Tensor)
_empty_affine_quantized_lodlM _size _options _scale _zero_point _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_empty_affine_quantized(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)
  , $(double _scale)
  , $(int64_t _zero_point)
  , $(at::MemoryFormat _memory_format)));
  }|]

_empty_affine_quantized_lodl
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
_empty_affine_quantized_lodl _size _options _scale _zero_point =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_empty_affine_quantized(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)
  , $(double _scale)
  , $(int64_t _zero_point)));
  }|]

_empty_affine_quantized_lod
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> CDouble
  -> IO (Ptr Tensor)
_empty_affine_quantized_lod _size _options _scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_empty_affine_quantized(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)
  , $(double _scale)));
  }|]

_empty_affine_quantized_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_empty_affine_quantized_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_empty_affine_quantized(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

_empty_affine_quantized_l
  :: Ptr IntArray
  -> IO (Ptr Tensor)
_empty_affine_quantized_l _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_empty_affine_quantized(
    *$(std::vector<int64_t>* _size)));
  }|]

_empty_per_channel_affine_quantized_lttloM
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
_empty_per_channel_affine_quantized_lttloM _size _scales _zero_points _axis _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_empty_per_channel_affine_quantized(
    *$(std::vector<int64_t>* _size)
  , *$(at::Tensor* _scales)
  , *$(at::Tensor* _zero_points)
  , $(int64_t _axis)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

_empty_per_channel_affine_quantized_lttlo
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_empty_per_channel_affine_quantized_lttlo _size _scales _zero_points _axis _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_empty_per_channel_affine_quantized(
    *$(std::vector<int64_t>* _size)
  , *$(at::Tensor* _scales)
  , *$(at::Tensor* _zero_points)
  , $(int64_t _axis)
  , *$(at::TensorOptions* _options)));
  }|]

_empty_per_channel_affine_quantized_lttl
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_empty_per_channel_affine_quantized_lttl _size _scales _zero_points _axis =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_empty_per_channel_affine_quantized(
    *$(std::vector<int64_t>* _size)
  , *$(at::Tensor* _scales)
  , *$(at::Tensor* _zero_points)
  , $(int64_t _axis)));
  }|]

empty_out_tlM
  :: Ptr Tensor
  -> Ptr IntArray
  -> MemoryFormat
  -> IO (Ptr Tensor)
empty_out_tlM _out _size _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::empty_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)
  , $(at::MemoryFormat _memory_format)));
  }|]

empty_out_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
empty_out_tl _out _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::empty_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)));
  }|]

empty_like_toM
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
empty_like_toM _self _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::empty_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

empty_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_like_to _self _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::empty_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

empty_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
empty_like_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::empty_like(
    *$(at::Tensor* _self)));
  }|]

empty_strided_llo
  :: Ptr IntArray
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_strided_llo _size _stride _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::empty_strided(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)
  , *$(at::TensorOptions* _options)));
  }|]

empty_strided_ll
  :: Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
empty_strided_ll _size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::empty_strided(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

erf_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erf_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::erf(
    *$(at::Tensor* _self)));
  }|]

erf__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erf__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::erf_(
    *$(at::Tensor* _self)));
  }|]

erf_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
erf_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::erf_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

erfc_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erfc_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::erfc(
    *$(at::Tensor* _self)));
  }|]

erfc__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erfc__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::erfc_(
    *$(at::Tensor* _self)));
  }|]

erfc_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
erfc_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::erfc_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

exp_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
exp_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::exp(
    *$(at::Tensor* _self)));
  }|]

exp__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
exp__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::exp_(
    *$(at::Tensor* _self)));
  }|]

exp_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
exp_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::exp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

expm1_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
expm1_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::expm1(
    *$(at::Tensor* _self)));
  }|]

expm1__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
expm1__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::expm1_(
    *$(at::Tensor* _self)));
  }|]

expm1_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
expm1_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::expm1_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

eye_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
eye_lo _n _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::eye(
    $(int64_t _n)
  , *$(at::TensorOptions* _options)));
  }|]

eye_l
  :: Int64
  -> IO (Ptr Tensor)
eye_l _n =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::eye(
    $(int64_t _n)));
  }|]

eye_llo
  :: Int64
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
eye_llo _n _m _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::eye(
    $(int64_t _n)
  , $(int64_t _m)
  , *$(at::TensorOptions* _options)));
  }|]

eye_ll
  :: Int64
  -> Int64
  -> IO (Ptr Tensor)
eye_ll _n _m =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::eye(
    $(int64_t _n)
  , $(int64_t _m)));
  }|]

eye_out_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
eye_out_tl _out _n =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::eye_out(
    *$(at::Tensor* _out)
  , $(int64_t _n)));
  }|]

eye_out_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
eye_out_tll _out _n _m =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::eye_out(
    *$(at::Tensor* _out)
  , $(int64_t _n)
  , $(int64_t _m)));
  }|]

flatten_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
flatten_tll _self _start_dim _end_dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::flatten(
    *$(at::Tensor* _self)
  , $(int64_t _start_dim)
  , $(int64_t _end_dim)));
  }|]

flatten_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
flatten_tl _self _start_dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::flatten(
    *$(at::Tensor* _self)
  , $(int64_t _start_dim)));
  }|]

flatten_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
flatten_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::flatten(
    *$(at::Tensor* _self)));
  }|]

flatten_tlln
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr Dimname
  -> IO (Ptr Tensor)
flatten_tlln _self _start_dim _end_dim _out_dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::flatten(
    *$(at::Tensor* _self)
  , $(int64_t _start_dim)
  , $(int64_t _end_dim)
  , *$(at::Dimname* _out_dim)));
  }|]

flatten_tnnn
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Dimname
  -> Ptr Dimname
  -> IO (Ptr Tensor)
flatten_tnnn _self _start_dim _end_dim _out_dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::flatten(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _start_dim)
  , *$(at::Dimname* _end_dim)
  , *$(at::Dimname* _out_dim)));
  }|]

flatten_tNn
  :: Ptr Tensor
  -> Ptr DimnameList
  -> Ptr Dimname
  -> IO (Ptr Tensor)
flatten_tNn _self _dims _out_dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::flatten(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dims)
  , *$(at::Dimname* _out_dim)));
  }|]

fill__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
fill__ts _self _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fill_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _value)));
  }|]

fill__tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fill__tt _self _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fill_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _value)));
  }|]

floor_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
floor_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::floor(
    *$(at::Tensor* _self)));
  }|]

floor__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
floor__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::floor_(
    *$(at::Tensor* _self)));
  }|]

floor_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
floor_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::floor_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

floor_divide_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
floor_divide_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::floor_divide(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

floor_divide_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
floor_divide_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::floor_divide_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

floor_divide_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
floor_divide_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::floor_divide(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

frac_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
frac_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::frac(
    *$(at::Tensor* _self)));
  }|]

frac__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
frac__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::frac_(
    *$(at::Tensor* _self)));
  }|]

frac_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
frac_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::frac_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

full_lsNo
  :: Ptr IntArray
  -> Ptr Scalar
  -> Ptr DimnameList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
full_lsNo _size _fill_value _names _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::full(
    *$(std::vector<int64_t>* _size)
  , *$(at::Scalar* _fill_value)
  , *$(std::vector<at::Dimname>* _names)
  , *$(at::TensorOptions* _options)));
  }|]

full_lsN
  :: Ptr IntArray
  -> Ptr Scalar
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
full_lsN _size _fill_value _names =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::full(
    *$(std::vector<int64_t>* _size)
  , *$(at::Scalar* _fill_value)
  , *$(std::vector<at::Dimname>* _names)));
  }|]

full_lso
  :: Ptr IntArray
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
full_lso _size _fill_value _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::full(
    *$(std::vector<int64_t>* _size)
  , *$(at::Scalar* _fill_value)
  , *$(at::TensorOptions* _options)));
  }|]

full_ls
  :: Ptr IntArray
  -> Ptr Scalar
  -> IO (Ptr Tensor)
full_ls _size _fill_value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::full(
    *$(std::vector<int64_t>* _size)
  , *$(at::Scalar* _fill_value)));
  }|]

full_out_tls
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Scalar
  -> IO (Ptr Tensor)
full_out_tls _out _size _fill_value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::full_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)
  , *$(at::Scalar* _fill_value)));
  }|]

full_like_tsoM
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
full_like_tsoM _self _fill_value _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::full_like(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _fill_value)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

full_like_tso
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
full_like_tso _self _fill_value _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::full_like(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _fill_value)
  , *$(at::TensorOptions* _options)));
  }|]

full_like_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
full_like_ts _self _fill_value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::full_like(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _fill_value)));
  }|]

from_file_sblo
  :: Ptr StdString
  -> CBool
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
from_file_sblo _filename _shared _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::from_file(
    *$(std::string* _filename)
  , $(bool _shared)
  , $(int64_t _size)
  , *$(at::TensorOptions* _options)));
  }|]

from_file_sbl
  :: Ptr StdString
  -> CBool
  -> Int64
  -> IO (Ptr Tensor)
from_file_sbl _filename _shared _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::from_file(
    *$(std::string* _filename)
  , $(bool _shared)
  , $(int64_t _size)));
  }|]

from_file_sb
  :: Ptr StdString
  -> CBool
  -> IO (Ptr Tensor)
from_file_sb _filename _shared =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::from_file(
    *$(std::string* _filename)
  , $(bool _shared)));
  }|]

from_file_s
  :: Ptr StdString
  -> IO (Ptr Tensor)
from_file_s _filename =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::from_file(
    *$(std::string* _filename)));
  }|]

grid_sampler_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
grid_sampler_ttllb _input _grid _interpolation_mode _padding_mode _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::grid_sampler(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int64_t _interpolation_mode)
  , $(int64_t _padding_mode)
  , $(bool _align_corners)));
  }|]

grid_sampler_2d_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
grid_sampler_2d_ttllb _input _grid _interpolation_mode _padding_mode _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::grid_sampler_2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int64_t _interpolation_mode)
  , $(int64_t _padding_mode)
  , $(bool _align_corners)));
  }|]

grid_sampler_2d_backward_tttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
grid_sampler_2d_backward_tttllb _grad_output _input _grid _interpolation_mode _padding_mode _align_corners =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::grid_sampler_2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int64_t _interpolation_mode)
  , $(int64_t _padding_mode)
  , $(bool _align_corners)));
  }|]

grid_sampler_3d_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
grid_sampler_3d_ttllb _input _grid _interpolation_mode _padding_mode _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::grid_sampler_3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int64_t _interpolation_mode)
  , $(int64_t _padding_mode)
  , $(bool _align_corners)));
  }|]

grid_sampler_3d_backward_tttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
grid_sampler_3d_backward_tttllb _grad_output _input _grid _interpolation_mode _padding_mode _align_corners =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::grid_sampler_3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int64_t _interpolation_mode)
  , $(int64_t _padding_mode)
  , $(bool _align_corners)));
  }|]

hann_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hann_window_lo _window_length _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hann_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

hann_window_l
  :: Int64
  -> IO (Ptr Tensor)
hann_window_l _window_length =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hann_window(
    $(int64_t _window_length)));
  }|]

hann_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hann_window_lbo _window_length _periodic _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hann_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

hann_window_lb
  :: Int64
  -> CBool
  -> IO (Ptr Tensor)
hann_window_lb _window_length _periodic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hann_window(
    $(int64_t _window_length)
  , $(bool _periodic)));
  }|]

hamming_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_lo _window_length _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hamming_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_l
  :: Int64
  -> IO (Ptr Tensor)
hamming_window_l _window_length =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hamming_window(
    $(int64_t _window_length)));
  }|]

hamming_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_lbo _window_length _periodic _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hamming_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_lb
  :: Int64
  -> CBool
  -> IO (Ptr Tensor)
hamming_window_lb _window_length _periodic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hamming_window(
    $(int64_t _window_length)
  , $(bool _periodic)));
  }|]

hamming_window_lbdo
  :: Int64
  -> CBool
  -> CDouble
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_lbdo _window_length _periodic _alpha _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hamming_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , $(double _alpha)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_lbd
  :: Int64
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
hamming_window_lbd _window_length _periodic _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hamming_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , $(double _alpha)));
  }|]

hamming_window_lbddo
  :: Int64
  -> CBool
  -> CDouble
  -> CDouble
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_lbddo _window_length _periodic _alpha _beta _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hamming_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , $(double _alpha)
  , $(double _beta)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_lbdd
  :: Int64
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
hamming_window_lbdd _window_length _periodic _alpha _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hamming_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , $(double _alpha)
  , $(double _beta)));
  }|]

hinge_embedding_loss_ttdl
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
hinge_embedding_loss_ttdl _self _target _margin _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hinge_embedding_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(double _margin)
  , $(int64_t _reduction)));
  }|]

hinge_embedding_loss_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
hinge_embedding_loss_ttd _self _target _margin =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hinge_embedding_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(double _margin)));
  }|]

hinge_embedding_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hinge_embedding_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hinge_embedding_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

ger_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ger_tt _self _vec2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ger(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec2)));
  }|]

ger_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ger_out_ttt _out _self _vec2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ger_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec2)));
  }|]

group_norm_tlttdb
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
group_norm_tlttdb _input _num_groups _weight _bias _eps _cudnn_enabled =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::group_norm(
    *$(at::Tensor* _input)
  , $(int64_t _num_groups)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(double _eps)
  , $(bool _cudnn_enabled)));
  }|]

group_norm_tlttd
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
group_norm_tlttd _input _num_groups _weight _bias _eps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::group_norm(
    *$(at::Tensor* _input)
  , $(int64_t _num_groups)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(double _eps)));
  }|]

group_norm_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
group_norm_tltt _input _num_groups _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::group_norm(
    *$(at::Tensor* _input)
  , $(int64_t _num_groups)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

group_norm_tlt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
group_norm_tlt _input _num_groups _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::group_norm(
    *$(at::Tensor* _input)
  , $(int64_t _num_groups)
  , *$(at::Tensor* _weight)));
  }|]

group_norm_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
group_norm_tl _input _num_groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::group_norm(
    *$(at::Tensor* _input)
  , $(int64_t _num_groups)));
  }|]

fft_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
fft_tlb _self _signal_ndim _normalized =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)
  , $(bool _normalized)));
  }|]

fft_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
fft_tl _self _signal_ndim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)));
  }|]

ifft_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
ifft_tlb _self _signal_ndim _normalized =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ifft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)
  , $(bool _normalized)));
  }|]

ifft_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
ifft_tl _self _signal_ndim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ifft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)));
  }|]

rfft_tlbb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
rfft_tlbb _self _signal_ndim _normalized _onesided =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rfft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)
  , $(bool _normalized)
  , $(bool _onesided)));
  }|]

rfft_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
rfft_tlb _self _signal_ndim _normalized =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rfft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)
  , $(bool _normalized)));
  }|]

rfft_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
rfft_tl _self _signal_ndim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rfft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)));
  }|]

irfft_tlbbl
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> IO (Ptr Tensor)
irfft_tlbbl _self _signal_ndim _normalized _onesided _signal_sizes =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::irfft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)
  , $(bool _normalized)
  , $(bool _onesided)
  , *$(std::vector<int64_t>* _signal_sizes)));
  }|]

irfft_tlbb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
irfft_tlbb _self _signal_ndim _normalized _onesided =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::irfft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)
  , $(bool _normalized)
  , $(bool _onesided)));
  }|]

irfft_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
irfft_tlb _self _signal_ndim _normalized =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::irfft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)
  , $(bool _normalized)));
  }|]

irfft_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
irfft_tl _self _signal_ndim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::irfft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)));
  }|]

_fft_with_size_tlbbblbbl
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_fft_with_size_tlbbblbbl _self _signal_ndim _complex_input _complex_output _inverse _checked_signal_sizes _normalized _onesided _output_sizes =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_fft_with_size(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)
  , $(bool _complex_input)
  , $(bool _complex_output)
  , $(bool _inverse)
  , *$(std::vector<int64_t>* _checked_signal_sizes)
  , $(bool _normalized)
  , $(bool _onesided)
  , *$(std::vector<int64_t>* _output_sizes)));
  }|]

_cufft_get_plan_cache_size_l
  :: Int64
  -> IO (Int64)
_cufft_get_plan_cache_size_l _device_index =
  [C.throwBlock| int64_t { return (at::_cufft_get_plan_cache_size(
    $(int64_t _device_index)));
  }|]

_cufft_get_plan_cache_max_size_l
  :: Int64
  -> IO (Int64)
_cufft_get_plan_cache_max_size_l _device_index =
  [C.throwBlock| int64_t { return (at::_cufft_get_plan_cache_max_size(
    $(int64_t _device_index)));
  }|]

_cufft_set_plan_cache_max_size_ll
  :: Int64
  -> Int64
  -> IO (())
_cufft_set_plan_cache_max_size_ll _device_index _max_size =
  [C.throwBlock| void {  (at::_cufft_set_plan_cache_max_size(
    $(int64_t _device_index)
  , $(int64_t _max_size)));
  }|]

_cufft_clear_plan_cache_l
  :: Int64
  -> IO (())
_cufft_clear_plan_cache_l _device_index =
  [C.throwBlock| void {  (at::_cufft_clear_plan_cache(
    $(int64_t _device_index)));
  }|]

index_tl
  :: Ptr Tensor
  -> Ptr TensorList
  -> IO (Ptr Tensor)
index_tl _self _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Tensor>* _indices)));
  }|]

index_copy_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_copy_tltt _self _dim _index _source =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_copy(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

index_copy_tntt
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_copy_tntt _self _dim _index _source =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_copy(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

index_put__tltb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
index_put__tltb _self _indices _values _accumulate =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_put_(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Tensor>* _indices)
  , *$(at::Tensor* _values)
  , $(bool _accumulate)));
  }|]

index_put__tlt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_put__tlt _self _indices _values =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_put_(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Tensor>* _indices)
  , *$(at::Tensor* _values)));
  }|]

index_put_tltb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
index_put_tltb _self _indices _values _accumulate =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_put(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Tensor>* _indices)
  , *$(at::Tensor* _values)
  , $(bool _accumulate)));
  }|]

index_put_tlt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_put_tlt _self _indices _values =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_put(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Tensor>* _indices)
  , *$(at::Tensor* _values)));
  }|]

_index_put_impl__tltbb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
_index_put_impl__tltbb _self _indices _values _accumulate _unsafe =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_index_put_impl_(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Tensor>* _indices)
  , *$(at::Tensor* _values)
  , $(bool _accumulate)
  , $(bool _unsafe)));
  }|]

_index_put_impl__tltb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_index_put_impl__tltb _self _indices _values _accumulate =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_index_put_impl_(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Tensor>* _indices)
  , *$(at::Tensor* _values)
  , $(bool _accumulate)));
  }|]

_index_put_impl__tlt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_index_put_impl__tlt _self _indices _values =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_index_put_impl_(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Tensor>* _indices)
  , *$(at::Tensor* _values)));
  }|]

instance_norm_tttttbddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
instance_norm_tttttbddb _input _weight _bias _running_mean _running_var _use_input_stats _momentum _eps _cudnn_enabled =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::instance_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _use_input_stats)
  , $(double _momentum)
  , $(double _eps)
  , $(bool _cudnn_enabled)));
  }|]

inverse_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
inverse_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::inverse(
    *$(at::Tensor* _self)));
  }|]

inverse_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
inverse_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::inverse_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_inverse_helper_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_inverse_helper_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_inverse_helper(
    *$(at::Tensor* _self)));
  }|]

isclose_ttddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
isclose_ttddb _self _other _rtol _atol _equal_nan =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::isclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)
  , $(double _atol)
  , $(bool _equal_nan)));
  }|]

isclose_ttdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
isclose_ttdd _self _other _rtol _atol =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::isclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)
  , $(double _atol)));
  }|]

isclose_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
isclose_ttd _self _other _rtol =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::isclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)));
  }|]

isclose_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
isclose_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::isclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

isnan_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
isnan_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::isnan(
    *$(at::Tensor* _self)));
  }|]

is_distributed_t
  :: Ptr Tensor
  -> IO (CBool)
is_distributed_t _self =
  [C.throwBlock| bool { return (at::is_distributed(
    *$(at::Tensor* _self)));
  }|]

is_floating_point_t
  :: Ptr Tensor
  -> IO (CBool)
is_floating_point_t _self =
  [C.throwBlock| bool { return (at::is_floating_point(
    *$(at::Tensor* _self)));
  }|]

is_complex_t
  :: Ptr Tensor
  -> IO (CBool)
is_complex_t _self =
  [C.throwBlock| bool { return (at::is_complex(
    *$(at::Tensor* _self)));
  }|]

is_nonzero_t
  :: Ptr Tensor
  -> IO (CBool)
is_nonzero_t _self =
  [C.throwBlock| bool { return (at::is_nonzero(
    *$(at::Tensor* _self)));
  }|]

is_same_size_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (CBool)
is_same_size_tt _self _other =
  [C.throwBlock| bool { return (at::is_same_size(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

is_signed_t
  :: Ptr Tensor
  -> IO (CBool)
is_signed_t _self =
  [C.throwBlock| bool { return (at::is_signed(
    *$(at::Tensor* _self)));
  }|]

kl_div_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
kl_div_ttl _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::kl_div(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

kl_div_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
kl_div_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::kl_div(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

kl_div_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
kl_div_backward_tttl _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::kl_div_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

kl_div_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
kl_div_backward_ttt _grad_output _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::kl_div_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

kthvalue_tllb
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_tllb _self _k _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

kthvalue_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_tll _self _k _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)));
  }|]

kthvalue_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_tl _self _k =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue(
    *$(at::Tensor* _self)
  , $(int64_t _k)));
  }|]

kthvalue_out_tttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_out_tttllb _values _indices _self _k _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

kthvalue_out_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_out_tttll _values _indices _self _k _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)));
  }|]

kthvalue_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_out_tttl _values _indices _self _k =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)));
  }|]

kthvalue_tlnb
  :: Ptr Tensor
  -> Int64
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_tlnb _self _k _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

kthvalue_tln
  :: Ptr Tensor
  -> Int64
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_tln _self _k _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , *$(at::Dimname* _dim)));
  }|]

kthvalue_out_tttlnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_out_tttlnb _values _indices _self _k _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

kthvalue_out_tttln
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_out_tttln _values _indices _self _k _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , *$(at::Dimname* _dim)));
  }|]

layer_norm_tlttdb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
layer_norm_tlttdb _input _normalized_shape _weight _bias _eps _cudnn_enable =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::layer_norm(
    *$(at::Tensor* _input)
  , *$(std::vector<int64_t>* _normalized_shape)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(double _eps)
  , $(bool _cudnn_enable)));
  }|]

layer_norm_tlttd
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
layer_norm_tlttd _input _normalized_shape _weight _bias _eps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::layer_norm(
    *$(at::Tensor* _input)
  , *$(std::vector<int64_t>* _normalized_shape)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(double _eps)));
  }|]

layer_norm_tltt
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
layer_norm_tltt _input _normalized_shape _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::layer_norm(
    *$(at::Tensor* _input)
  , *$(std::vector<int64_t>* _normalized_shape)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

layer_norm_tlt
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
layer_norm_tlt _input _normalized_shape _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::layer_norm(
    *$(at::Tensor* _input)
  , *$(std::vector<int64_t>* _normalized_shape)
  , *$(at::Tensor* _weight)));
  }|]

layer_norm_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
layer_norm_tl _input _normalized_shape =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::layer_norm(
    *$(at::Tensor* _input)
  , *$(std::vector<int64_t>* _normalized_shape)));
  }|]

native_layer_norm_tttlld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CDouble
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
native_layer_norm_tttlld _input _weight _bias _M _N _eps =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native_layer_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(int64_t _M)
  , $(int64_t _N)
  , $(double _eps)));
  }|]

native_layer_norm_backward_tttttlla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
native_layer_norm_backward_tttttlla _grad_out _input _mean _rstd _weight _M _N _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native_layer_norm_backward(
    *$(at::Tensor* _grad_out)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _rstd)
  , *$(at::Tensor* _weight)
  , $(int64_t _M)
  , $(int64_t _N)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

linear_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
linear_ttt _input _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linear(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

linear_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
linear_tt _input _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linear(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)));
  }|]

mkldnn_linear_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mkldnn_linear_ttt _input _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_linear(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

mkldnn_linear_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mkldnn_linear_tt _input _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_linear(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)));
  }|]

fbgemm_linear_int8_weight_fp32_activation_ttttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_linear_int8_weight_fp32_activation_ttttsst _input _weight _packed _col_offsets _weight_scale _weight_zero_point _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_linear_int8_weight_fp32_activation(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _packed)
  , *$(at::Tensor* _col_offsets)
  , *$(at::Scalar* _weight_scale)
  , *$(at::Scalar* _weight_zero_point)
  , *$(at::Tensor* _bias)));
  }|]

fbgemm_linear_int8_weight_ttttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_linear_int8_weight_ttttsst _input _weight _packed _col_offsets _weight_scale _weight_zero_point _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_linear_int8_weight(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _packed)
  , *$(at::Tensor* _col_offsets)
  , *$(at::Scalar* _weight_scale)
  , *$(at::Scalar* _weight_zero_point)
  , *$(at::Tensor* _bias)));
  }|]

fbgemm_linear_quantize_weight_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,CDouble,Int64)))
fbgemm_linear_quantize_weight_t _input =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,double,int64_t>* { return new std::tuple<at::Tensor,at::Tensor,double,int64_t>(at::fbgemm_linear_quantize_weight(
    *$(at::Tensor* _input)));
  }|]

fbgemm_pack_gemm_matrix_fp16_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_pack_gemm_matrix_fp16_t _input =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_pack_gemm_matrix_fp16(
    *$(at::Tensor* _input)));
  }|]

fbgemm_linear_fp16_weight_fp32_activation_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_linear_fp16_weight_fp32_activation_ttt _input _packed_weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_linear_fp16_weight_fp32_activation(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _packed_weight)
  , *$(at::Tensor* _bias)));
  }|]

fbgemm_linear_fp16_weight_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_linear_fp16_weight_ttt _input _packed_weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_linear_fp16_weight(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _packed_weight)
  , *$(at::Tensor* _bias)));
  }|]

fbgemm_pack_quantized_matrix_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_pack_quantized_matrix_t _input =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_pack_quantized_matrix(
    *$(at::Tensor* _input)));
  }|]

fbgemm_pack_quantized_matrix_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
fbgemm_pack_quantized_matrix_tll _input _K _N =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_pack_quantized_matrix(
    *$(at::Tensor* _input)
  , $(int64_t _K)
  , $(int64_t _N)));
  }|]

linspace_sslo
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
linspace_sslo _start _end _steps _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)
  , *$(at::TensorOptions* _options)));
  }|]

linspace_ssl
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> IO (Ptr Tensor)
linspace_ssl _start _end _steps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)));
  }|]

linspace_ss
  :: Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
linspace_ss _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

linspace_out_tssl
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> IO (Ptr Tensor)
linspace_out_tssl _out _start _end _steps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linspace_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)));
  }|]

linspace_out_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
linspace_out_tss _out _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linspace_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

log_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log(
    *$(at::Tensor* _self)));
  }|]

log__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_(
    *$(at::Tensor* _self)));
  }|]

log_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

log10_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log10_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log10(
    *$(at::Tensor* _self)));
  }|]

log10__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log10__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log10_(
    *$(at::Tensor* _self)));
  }|]

log10_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log10_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log10_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

log1p_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log1p_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log1p(
    *$(at::Tensor* _self)));
  }|]

log1p__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log1p__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log1p_(
    *$(at::Tensor* _self)));
  }|]

log1p_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log1p_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log1p_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

log2_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log2_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log2(
    *$(at::Tensor* _self)));
  }|]

log2__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log2__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log2_(
    *$(at::Tensor* _self)));
  }|]

log2_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log2_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log2_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

logdet_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
logdet_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logdet(
    *$(at::Tensor* _self)));
  }|]

logspace_ssldo
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> CDouble
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
logspace_ssldo _start _end _steps _base _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)
  , $(double _base)
  , *$(at::TensorOptions* _options)));
  }|]

logspace_ssld
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> CDouble
  -> IO (Ptr Tensor)
logspace_ssld _start _end _steps _base =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)
  , $(double _base)));
  }|]

logspace_ssl
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> IO (Ptr Tensor)
logspace_ssl _start _end _steps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)));
  }|]

logspace_ss
  :: Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
logspace_ss _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

logspace_out_tssld
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> CDouble
  -> IO (Ptr Tensor)
logspace_out_tssld _out _start _end _steps _base =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)
  , $(double _base)));
  }|]

logspace_out_tssl
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> IO (Ptr Tensor)
logspace_out_tssl _out _start _end _steps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)));
  }|]

logspace_out_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
logspace_out_tss _out _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

log_softmax_tls
  :: Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
log_softmax_tls _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

log_softmax_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
log_softmax_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

log_softmax_tns
  :: Ptr Tensor
  -> Ptr Dimname
  -> ScalarType
  -> IO (Ptr Tensor)
log_softmax_tns _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_softmax(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(at::ScalarType _dtype)));
  }|]

log_softmax_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
log_softmax_tn _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_softmax(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

_log_softmax_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
_log_softmax_tlb _self _dim _half_to_float =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_log_softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _half_to_float)));
  }|]

_log_softmax_backward_data_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_log_softmax_backward_data_ttlt _grad_output _output _dim _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_log_softmax_backward_data(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)
  , $(int64_t _dim)
  , *$(at::Tensor* _self)));
  }|]

logsumexp_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
logsumexp_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

logsumexp_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
logsumexp_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

logsumexp_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
logsumexp_out_ttlb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

logsumexp_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
logsumexp_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

logsumexp_tNb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
logsumexp_tNb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)));
  }|]

logsumexp_tN
  :: Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
logsumexp_tN _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

logsumexp_out_ttNb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
logsumexp_out_ttNb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)));
  }|]

logsumexp_out_ttN
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
logsumexp_out_ttN _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

margin_ranking_loss_tttdl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
margin_ranking_loss_tttdl _input1 _input2 _target _margin _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::margin_ranking_loss(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _target)
  , $(double _margin)
  , $(int64_t _reduction)));
  }|]

margin_ranking_loss_tttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
margin_ranking_loss_tttd _input1 _input2 _target _margin =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::margin_ranking_loss(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _target)
  , $(double _margin)));
  }|]

margin_ranking_loss_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
margin_ranking_loss_ttt _input1 _input2 _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::margin_ranking_loss(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _target)));
  }|]

matmul_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
matmul_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matmul(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

matmul_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
matmul_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matmul_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

matrix_rank_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
matrix_rank_tdb _self _tol _symmetric =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matrix_rank(
    *$(at::Tensor* _self)
  , $(double _tol)
  , $(bool _symmetric)));
  }|]

matrix_rank_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
matrix_rank_td _self _tol =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matrix_rank(
    *$(at::Tensor* _self)
  , $(double _tol)));
  }|]

matrix_rank_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
matrix_rank_tb _self _symmetric =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matrix_rank(
    *$(at::Tensor* _self)
  , $(bool _symmetric)));
  }|]

matrix_rank_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
matrix_rank_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matrix_rank(
    *$(at::Tensor* _self)));
  }|]

matrix_power_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
matrix_power_tl _self _n =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matrix_power(
    *$(at::Tensor* _self)
  , $(int64_t _n)));
  }|]

max_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_tlb _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

max_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

max_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_out_tttlb _max _max_values _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_out(
    *$(at::Tensor* _max)
  , *$(at::Tensor* _max_values)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

max_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_out_tttl _max _max_values _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_out(
    *$(at::Tensor* _max)
  , *$(at::Tensor* _max_values)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

max_values_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
max_values_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_values(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

max_values_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_values_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_values(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

max_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_tnb _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

max_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_tn _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

max_out_tttnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_out_tttnb _max _max_values _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_out(
    *$(at::Tensor* _max)
  , *$(at::Tensor* _max_values)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

max_out_tttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_out_tttn _max _max_values _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_out(
    *$(at::Tensor* _max)
  , *$(at::Tensor* _max_values)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

max_values_tNb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
max_values_tNb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_values(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)));
  }|]

max_values_tN
  :: Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
max_values_tN _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_values(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

max_pool1d_with_indices_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool1d_with_indices_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool1d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool1d_with_indices_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool1d_with_indices_tllll _self _kernel_size _stride _padding _dilation =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool1d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

max_pool1d_with_indices_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool1d_with_indices_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool1d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_pool1d_with_indices_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool1d_with_indices_tll _self _kernel_size _stride =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool1d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

max_pool1d_with_indices_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool1d_with_indices_tl _self _kernel_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool1d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

max_pool1d_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
max_pool1d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool1d_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool1d_tllll _self _kernel_size _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

max_pool1d_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool1d_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_pool1d_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool1d_tll _self _kernel_size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

max_pool1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool1d_tl _self _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

max_pool2d_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
max_pool2d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool2d_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool2d_tllll _self _kernel_size _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

max_pool2d_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool2d_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_pool2d_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool2d_tll _self _kernel_size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

max_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool2d_tl _self _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

mkldnn_max_pool2d_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
mkldnn_max_pool2d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

mkldnn_max_pool2d_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mkldnn_max_pool2d_tllll _self _kernel_size _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

mkldnn_max_pool2d_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mkldnn_max_pool2d_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

mkldnn_max_pool2d_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mkldnn_max_pool2d_tll _self _kernel_size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

mkldnn_max_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mkldnn_max_pool2d_tl _self _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

quantized_max_pool2d_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
quantized_max_pool2d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantized_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

quantized_max_pool2d_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
quantized_max_pool2d_tllll _self _kernel_size _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantized_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

quantized_max_pool2d_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
quantized_max_pool2d_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantized_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

quantized_max_pool2d_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
quantized_max_pool2d_tll _self _kernel_size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantized_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

quantized_max_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
quantized_max_pool2d_tl _self _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantized_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

max_pool3d_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
max_pool3d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool3d_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool3d_tllll _self _kernel_size _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

max_pool3d_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool3d_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_pool3d_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool3d_tll _self _kernel_size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

max_pool3d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool3d_tl _self _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

mean_ts
  :: Ptr Tensor
  -> ScalarType
  -> IO (Ptr Tensor)
mean_ts _self _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean(
    *$(at::Tensor* _self)
  , $(at::ScalarType _dtype)));
  }|]

mean_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
mean_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean(
    *$(at::Tensor* _self)));
  }|]

mean_tlbs
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
mean_tlbs _self _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

mean_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
mean_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

mean_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mean_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

mean_out_ttlbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
mean_out_ttlbs _out _self _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

mean_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
mean_out_ttlb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

mean_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mean_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

mean_tNbs
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
mean_tNbs _self _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

mean_tNb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
mean_tNb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)));
  }|]

mean_tN
  :: Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
mean_tN _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

mean_out_ttNbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
mean_out_ttNbs _out _self _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

mean_out_ttNb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
mean_out_ttNb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)));
  }|]

mean_out_ttN
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
mean_out_ttN _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mean_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

median_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
median_tlb _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::median(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

median_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
median_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::median(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

median_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
median_out_tttlb _values _indices _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::median_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

median_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
median_out_tttl _values _indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::median_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

median_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
median_tnb _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::median(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

median_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
median_tn _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::median(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

median_out_tttnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
median_out_tttnb _values _indices _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::median_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

median_out_tttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
median_out_tttn _values _indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::median_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

min_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
min_tlb _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::min(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

min_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
min_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::min(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

min_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
min_out_tttlb _min _min_indices _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::min_out(
    *$(at::Tensor* _min)
  , *$(at::Tensor* _min_indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

min_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
min_out_tttl _min _min_indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::min_out(
    *$(at::Tensor* _min)
  , *$(at::Tensor* _min_indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

min_values_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
min_values_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::min_values(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

min_values_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
min_values_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::min_values(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

min_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
min_tnb _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::min(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

min_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
min_tn _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::min(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

min_out_tttnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
min_out_tttnb _min _min_indices _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::min_out(
    *$(at::Tensor* _min)
  , *$(at::Tensor* _min_indices)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

min_out_tttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
min_out_tttn _min _min_indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::min_out(
    *$(at::Tensor* _min)
  , *$(at::Tensor* _min_indices)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

min_values_tNb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
min_values_tNb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::min_values(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)));
  }|]

min_values_tN
  :: Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
min_values_tN _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::min_values(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

mkldnn_convolution_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
mkldnn_convolution_tttllll _self _weight _bias _padding _stride _dilation _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_convolution(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)));
  }|]

mkldnn_convolution_backward_input_lttllllb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
mkldnn_convolution_backward_input_lttllllb _self_size _grad_output _weight _padding _stride _dilation _groups _bias_defined =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_convolution_backward_input(
    *$(std::vector<int64_t>* _self_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _bias_defined)));
  }|]

mkldnn_convolution_backward_weights_lttllllb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
mkldnn_convolution_backward_weights_lttllllb _weight_size _grad_output _self _padding _stride _dilation _groups _bias_defined =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mkldnn_convolution_backward_weights(
    *$(std::vector<int64_t>* _weight_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _bias_defined)));
  }|]

mkldnn_convolution_backward_tttlllla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
mkldnn_convolution_backward_tttlllla _self _grad_output _weight _padding _stride _dilation _groups _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::mkldnn_convolution_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

miopen_batch_norm_tttttbdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
miopen_batch_norm_tttttbdd _input _weight _bias _running_mean _running_var _training _exponential_average_factor _epsilon =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::miopen_batch_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(double _exponential_average_factor)
  , $(double _epsilon)));
  }|]

miopen_batch_norm_backward_tttttttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
miopen_batch_norm_backward_tttttttd _input _grad_output _weight _running_mean _running_var _save_mean _save_var _epsilon =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::miopen_batch_norm_backward(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , *$(at::Tensor* _save_mean)
  , *$(at::Tensor* _save_var)
  , $(double _epsilon)));
  }|]

miopen_convolution_tttllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_convolution_tttllllbb _self _weight _bias _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::miopen_convolution(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_convolution_backward_input_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_convolution_backward_input_lttllllbb _self_size _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::miopen_convolution_backward_input(
    *$(std::vector<int64_t>* _self_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_convolution_backward_tttllllbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
miopen_convolution_backward_tttllllbba _self _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::miopen_convolution_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

miopen_convolution_backward_bias_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
miopen_convolution_backward_bias_t _grad_output =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::miopen_convolution_backward_bias(
    *$(at::Tensor* _grad_output)));
  }|]

miopen_convolution_backward_weight_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_convolution_backward_weight_lttllllbb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::miopen_convolution_backward_weight(
    *$(std::vector<int64_t>* _weight_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_convolution_transpose_tttlllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_convolution_transpose_tttlllllbb _self _weight _bias _padding _output_padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::miopen_convolution_transpose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_convolution_transpose_backward_tttlllllbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
miopen_convolution_transpose_backward_tttlllllbba _self _grad_output _weight _padding _output_padding _stride _dilation _groups _benchmark _deterministic _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::miopen_convolution_transpose_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

miopen_convolution_transpose_backward_input_ttllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_convolution_transpose_backward_input_ttllllbb _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::miopen_convolution_transpose_backward_input(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_convolution_transpose_backward_weight_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_convolution_transpose_backward_weight_lttllllbb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::miopen_convolution_transpose_backward_weight(
    *$(std::vector<int64_t>* _weight_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_depthwise_convolution_tttllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_depthwise_convolution_tttllllbb _self _weight _bias _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::miopen_depthwise_convolution(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_depthwise_convolution_backward_input_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_depthwise_convolution_backward_input_lttllllbb _self_size _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::miopen_depthwise_convolution_backward_input(
    *$(std::vector<int64_t>* _self_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_depthwise_convolution_backward_tttllllbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
miopen_depthwise_convolution_backward_tttllllbba _self _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::miopen_depthwise_convolution_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

miopen_depthwise_convolution_backward_weight_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_depthwise_convolution_backward_weight_lttllllbb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::miopen_depthwise_convolution_backward_weight(
    *$(std::vector<int64_t>* _weight_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_rnn_tllttlllbdbblt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> CBool
  -> CDouble
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor,Tensor)))
miopen_rnn_tllttlllbdbblt _input _weight _weight_stride0 _hx _cx _mode _hidden_size _num_layers _batch_first _dropout _train _bidirectional _batch_sizes _dropout_state =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::miopen_rnn(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _weight)
  , $(int64_t _weight_stride0)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _cx)
  , $(int64_t _mode)
  , $(int64_t _hidden_size)
  , $(int64_t _num_layers)
  , $(bool _batch_first)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , *$(std::vector<int64_t>* _batch_sizes)
  , *$(at::Tensor* _dropout_state)));
  }|]

miopen_rnn_backward_tlltttttttlllbdbbltta
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> CBool
  -> CDouble
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray '(CBool,4))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,TensorList)))
miopen_rnn_backward_tlltttttttlllbdbbltta _input _weight _weight_stride0 _weight_buf _hx _cx _output _grad_output _grad_hy _grad_cy _mode _hidden_size _num_layers _batch_first _dropout _train _bidirectional _batch_sizes _dropout_state _reserve _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,std::vector<at::Tensor>>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,std::vector<at::Tensor>>(at::miopen_rnn_backward(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _weight)
  , $(int64_t _weight_stride0)
  , *$(at::Tensor* _weight_buf)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _output)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _grad_cy)
  , $(int64_t _mode)
  , $(int64_t _hidden_size)
  , $(int64_t _num_layers)
  , $(bool _batch_first)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , *$(std::vector<int64_t>* _batch_sizes)
  , *$(at::Tensor* _dropout_state)
  , *$(at::Tensor* _reserve)
  , *$(std::array<bool,4>* _output_mask)));
  }|]

mm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mm_tt _self _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

mm_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mm_out_ttt _out _self _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

_sparse_mm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_sparse_mm_tt _sparse _dense =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_mm(
    *$(at::Tensor* _sparse)
  , *$(at::Tensor* _dense)));
  }|]

mode_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
mode_tlb _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mode(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

mode_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
mode_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mode(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

mode_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
mode_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mode(
    *$(at::Tensor* _self)));
  }|]

mode_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
mode_out_tttlb _values _indices _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mode_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

mode_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
mode_out_tttl _values _indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mode_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

mode_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
mode_out_ttt _values _indices _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mode_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)));
  }|]

mode_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
mode_tnb _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mode(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

mode_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
mode_tn _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mode(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

mode_out_tttnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
mode_out_tttnb _values _indices _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mode_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

mode_out_tttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
mode_out_tttn _values _indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mode_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

mul_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mul_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mul(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

mul_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mul_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mul_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

mul_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
mul_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mul(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

mv_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mv_tt _self _vec =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec)));
  }|]

mv_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mv_out_ttt _out _self _vec =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec)));
  }|]

mvlgamma_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mvlgamma_tl _self _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mvlgamma(
    *$(at::Tensor* _self)
  , $(int64_t _p)));
  }|]

narrow_tlll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
narrow_tlll _self _dim _start _length =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::narrow(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(int64_t _start)
  , $(int64_t _length)));
  }|]

narrow_tltl
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
narrow_tltl _self _dim _start _length =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::narrow(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _start)
  , $(int64_t _length)));
  }|]

native_batch_norm_tttttbdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
native_batch_norm_tttttbdd _input _weight _bias _running_mean _running_var _training _momentum _eps =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native_batch_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(double _momentum)
  , $(double _eps)));
  }|]

native_batch_norm_out_ttttttttbdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
native_batch_norm_out_ttttttttbdd _out _save_mean _save_invstd _input _weight _bias _running_mean _running_var _training _momentum _eps =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native_batch_norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _save_mean)
  , *$(at::Tensor* _save_invstd)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(double _momentum)
  , $(double _eps)));
  }|]

batch_norm_stats_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
batch_norm_stats_td _input _eps =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::batch_norm_stats(
    *$(at::Tensor* _input)
  , $(double _eps)));
  }|]

batch_norm_elemt_tttttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
batch_norm_elemt_tttttd _input _weight _bias _mean _invstd _eps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::batch_norm_elemt(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _invstd)
  , $(double _eps)));
  }|]

batch_norm_elemt_out_ttttttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
batch_norm_elemt_out_ttttttd _out _input _weight _bias _mean _invstd _eps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::batch_norm_elemt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _invstd)
  , $(double _eps)));
  }|]

batch_norm_gather_stats_tttttddl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
batch_norm_gather_stats_tttttddl _input _mean _invstd _running_mean _running_var _momentum _eps _count =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::batch_norm_gather_stats(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _invstd)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(double _momentum)
  , $(double _eps)
  , $(int64_t _count)));
  }|]

batch_norm_gather_stats_with_counts_tttttddl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
batch_norm_gather_stats_with_counts_tttttddl _input _mean _invstd _running_mean _running_var _momentum _eps _counts =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::batch_norm_gather_stats_with_counts(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _invstd)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(double _momentum)
  , $(double _eps)
  , *$(std::vector<int64_t>* _counts)));
  }|]

native_batch_norm_backward_tttttttbda
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
native_batch_norm_backward_tttttttbda _grad_out _input _weight _running_mean _running_var _save_mean _save_invstd _train _eps _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native_batch_norm_backward(
    *$(at::Tensor* _grad_out)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , *$(at::Tensor* _save_mean)
  , *$(at::Tensor* _save_invstd)
  , $(bool _train)
  , $(double _eps)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

batch_norm_backward_reduce_tttttbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor)))
batch_norm_backward_reduce_tttttbbb _grad_out _input _mean _invstd _weight _input_g _weight_g _bias_g =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::batch_norm_backward_reduce(
    *$(at::Tensor* _grad_out)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _invstd)
  , *$(at::Tensor* _weight)
  , $(bool _input_g)
  , $(bool _weight_g)
  , $(bool _bias_g)));
  }|]

batch_norm_backward_elemt_ttttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
batch_norm_backward_elemt_ttttttt _grad_out _input _mean _invstd _weight _mean_dy _mean_dy_xmu =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::batch_norm_backward_elemt(
    *$(at::Tensor* _grad_out)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _invstd)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _mean_dy)
  , *$(at::Tensor* _mean_dy_xmu)));
  }|]

batch_norm_update_stats_tttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
batch_norm_update_stats_tttd _input _running_mean _running_var _momentum =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::batch_norm_update_stats(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(double _momentum)));
  }|]

_nnpack_spatial_convolution_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_nnpack_spatial_convolution_tttll _input _weight _bias _padding _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_nnpack_spatial_convolution(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

_nnpack_spatial_convolution_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_nnpack_spatial_convolution_tttl _input _weight _bias _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_nnpack_spatial_convolution(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)));
  }|]

_nnpack_spatial_convolution_backward_tttla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_nnpack_spatial_convolution_backward_tttla _input _grad_output _weight _padding _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_nnpack_spatial_convolution_backward(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

_nnpack_spatial_convolution_backward_input_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_nnpack_spatial_convolution_backward_input_tttl _input _grad_output _weight _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_nnpack_spatial_convolution_backward_input(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)));
  }|]

_nnpack_spatial_convolution_backward_weight_tltl
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_nnpack_spatial_convolution_backward_weight_tltl _input _weightsize _grad_output _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_nnpack_spatial_convolution_backward_weight(
    *$(at::Tensor* _input)
  , *$(std::vector<int64_t>* _weightsize)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _padding)));
  }|]

ones_lNo
  :: Ptr IntArray
  -> Ptr DimnameList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
ones_lNo _size _names _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ones(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)
  , *$(at::TensorOptions* _options)));
  }|]

ones_lN
  :: Ptr IntArray
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
ones_lN _size _names =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ones(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)));
  }|]

ones_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
ones_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ones(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

ones_l
  :: Ptr IntArray
  -> IO (Ptr Tensor)
ones_l _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ones(
    *$(std::vector<int64_t>* _size)));
  }|]

ones_out_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
ones_out_tl _out _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ones_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)));
  }|]

ones_like_toM
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
ones_like_toM _self _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ones_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

ones_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
ones_like_to _self _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ones_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

ones_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
ones_like_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ones_like(
    *$(at::Tensor* _self)));
  }|]

pairwise_distance_ttddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
pairwise_distance_ttddb _x1 _x2 _p _eps _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pairwise_distance(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(double _p)
  , $(double _eps)
  , $(bool _keepdim)));
  }|]

pairwise_distance_ttdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
pairwise_distance_ttdd _x1 _x2 _p _eps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pairwise_distance(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(double _p)
  , $(double _eps)));
  }|]

pairwise_distance_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
pairwise_distance_ttd _x1 _x2 _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pairwise_distance(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(double _p)));
  }|]

pairwise_distance_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pairwise_distance_tt _x1 _x2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pairwise_distance(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)));
  }|]

cdist_ttdl
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
cdist_ttdl _x1 _x2 _p _compute_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cdist(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(double _p)
  , $(int64_t _compute_mode)));
  }|]

cdist_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
cdist_ttd _x1 _x2 _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cdist(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(double _p)));
  }|]

cdist_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cdist_tt _x1 _x2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cdist(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)));
  }|]

_cdist_forward_ttdl
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
_cdist_forward_ttdl _x1 _x2 _p _compute_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cdist_forward(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(double _p)
  , $(int64_t _compute_mode)));
  }|]

_cdist_backward_tttdt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_cdist_backward_tttdt _grad _x1 _x2 _p _cdist =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cdist_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(double _p)
  , *$(at::Tensor* _cdist)));
  }|]

pdist_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
pdist_td _self _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pdist(
    *$(at::Tensor* _self)
  , $(double _p)));
  }|]

pdist_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
pdist_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pdist(
    *$(at::Tensor* _self)));
  }|]

_pdist_forward_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
_pdist_forward_td _self _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_pdist_forward(
    *$(at::Tensor* _self)
  , $(double _p)));
  }|]

_pdist_forward_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_pdist_forward_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_pdist_forward(
    *$(at::Tensor* _self)));
  }|]

_pdist_backward_ttdt
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_pdist_backward_ttdt _grad _self _p _pdist =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_pdist_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _self)
  , $(double _p)
  , *$(at::Tensor* _pdist)));
  }|]

cosine_similarity_ttld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CDouble
  -> IO (Ptr Tensor)
cosine_similarity_ttld _x1 _x2 _dim _eps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cosine_similarity(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(int64_t _dim)
  , $(double _eps)));
  }|]

cosine_similarity_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cosine_similarity_ttl _x1 _x2 _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cosine_similarity(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(int64_t _dim)));
  }|]

cosine_similarity_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cosine_similarity_tt _x1 _x2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cosine_similarity(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)));
  }|]

pixel_shuffle_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
pixel_shuffle_tl _self _upscale_factor =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pixel_shuffle(
    *$(at::Tensor* _self)
  , $(int64_t _upscale_factor)));
  }|]

pinverse_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
pinverse_td _self _rcond =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pinverse(
    *$(at::Tensor* _self)
  , $(double _rcond)));
  }|]

pinverse_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
pinverse_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pinverse(
    *$(at::Tensor* _self)));
  }|]

poisson_nll_loss_ttbbdl
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
poisson_nll_loss_ttbbdl _input _target _log_input _full _eps _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::poisson_nll_loss(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _target)
  , $(bool _log_input)
  , $(bool _full)
  , $(double _eps)
  , $(int64_t _reduction)));
  }|]

scalar_tensor_so
  :: Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
scalar_tensor_so _s _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::scalar_tensor(
    *$(at::Scalar* _s)
  , *$(at::TensorOptions* _options)));
  }|]

scalar_tensor_s
  :: Ptr Scalar
  -> IO (Ptr Tensor)
scalar_tensor_s _s =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::scalar_tensor(
    *$(at::Scalar* _s)));
  }|]

rand_lNo
  :: Ptr IntArray
  -> Ptr DimnameList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lNo _size _names _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)
  , *$(at::TensorOptions* _options)));
  }|]

rand_lN
  :: Ptr IntArray
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
rand_lN _size _names =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)));
  }|]

rand_lpNo
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr DimnameList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lpNo _size _generator _names _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(std::vector<at::Dimname>* _names)
  , *$(at::TensorOptions* _options)));
  }|]

rand_lpN
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
rand_lpN _size _generator _names =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(std::vector<at::Dimname>* _names)));
  }|]

rand_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

rand_l
  :: Ptr IntArray
  -> IO (Ptr Tensor)
rand_l _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)));
  }|]

rand_lpo
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lpo _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

rand_lp
  :: Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
rand_lp _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

rand_out_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
rand_out_tl _out _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)));
  }|]

rand_out_tlp
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
rand_out_tlp _out _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

rand_like_toM
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
rand_like_toM _self _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

rand_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_like_to _self _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

rand_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rand_like_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand_like(
    *$(at::Tensor* _self)));
  }|]

randint_llo
  :: Int64
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_llo _high _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randint_ll
  :: Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
randint_ll _high _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _high)
  , *$(std::vector<int64_t>* _size)));
  }|]

randint_llpo
  :: Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_llpo _high _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randint_llp
  :: Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randint_llp _high _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randint_lllo
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_lllo _low _high _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randint_lll
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
randint_lll _low _high _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)));
  }|]

randint_lllpo
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_lllpo _low _high _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randint_lllp
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randint_lllp _low _high _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randint_out_tll
  :: Ptr Tensor
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
randint_out_tll _out _high _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_out(
    *$(at::Tensor* _out)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)));
  }|]

randint_out_tllp
  :: Ptr Tensor
  -> Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randint_out_tllp _out _high _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_out(
    *$(at::Tensor* _out)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randint_out_tlll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
randint_out_tlll _out _low _high _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_out(
    *$(at::Tensor* _out)
  , $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)));
  }|]

randint_out_tlllp
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randint_out_tlllp _out _low _high _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_out(
    *$(at::Tensor* _out)
  , $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randint_like_tloM
  :: Ptr Tensor
  -> Int64
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
randint_like_tloM _self _high _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _high)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

randint_like_tlo
  :: Ptr Tensor
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_like_tlo _self _high _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _high)
  , *$(at::TensorOptions* _options)));
  }|]

randint_like_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
randint_like_tl _self _high =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _high)));
  }|]

randint_like_tlloM
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
randint_like_tlloM _self _low _high _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _low)
  , $(int64_t _high)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

randint_like_tllo
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_like_tllo _self _low _high _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _low)
  , $(int64_t _high)
  , *$(at::TensorOptions* _options)));
  }|]

randint_like_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
randint_like_tll _self _low _high =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _low)
  , $(int64_t _high)));
  }|]

randn_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randn_l
  :: Ptr IntArray
  -> IO (Ptr Tensor)
randn_l _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)));
  }|]

randn_lpo
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lpo _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randn_lp
  :: Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randn_lp _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randn_lNo
  :: Ptr IntArray
  -> Ptr DimnameList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lNo _size _names _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)
  , *$(at::TensorOptions* _options)));
  }|]

randn_lN
  :: Ptr IntArray
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
randn_lN _size _names =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)));
  }|]

randn_lpNo
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr DimnameList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lpNo _size _generator _names _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(std::vector<at::Dimname>* _names)
  , *$(at::TensorOptions* _options)));
  }|]

randn_lpN
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
randn_lpN _size _generator _names =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(std::vector<at::Dimname>* _names)));
  }|]

randn_out_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
randn_out_tl _out _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)));
  }|]

randn_out_tlp
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randn_out_tlp _out _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randn_like_toM
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
randn_like_toM _self _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

randn_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_like_to _self _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

randn_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
randn_like_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn_like(
    *$(at::Tensor* _self)));
  }|]

randperm_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randperm_lo _n _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randperm(
    $(int64_t _n)
  , *$(at::TensorOptions* _options)));
  }|]

randperm_l
  :: Int64
  -> IO (Ptr Tensor)
randperm_l _n =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randperm(
    $(int64_t _n)));
  }|]

randperm_lpo
  :: Int64
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randperm_lpo _n _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randperm(
    $(int64_t _n)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randperm_lp
  :: Int64
  -> Ptr Generator
  -> IO (Ptr Tensor)
randperm_lp _n _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randperm(
    $(int64_t _n)
  , $(at::Generator * _generator)));
  }|]

randperm_out_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
randperm_out_tl _out _n =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randperm_out(
    *$(at::Tensor* _out)
  , $(int64_t _n)));
  }|]

randperm_out_tlp
  :: Ptr Tensor
  -> Int64
  -> Ptr Generator
  -> IO (Ptr Tensor)
randperm_out_tlp _out _n _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randperm_out(
    *$(at::Tensor* _out)
  , $(int64_t _n)
  , $(at::Generator * _generator)));
  }|]

range_ssso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
range_ssso _start _end _step _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::range(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)
  , *$(at::TensorOptions* _options)));
  }|]

range_sss
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
range_sss _start _end _step =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::range(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)));
  }|]

-- range_ss
--   :: Ptr Scalar
--   -> Ptr Scalar
--   -> IO (Ptr Tensor)
-- range_ss _start _end =
--   [C.throwBlock| at::Tensor* { return new at::Tensor(at::range(
--     *$(at::Scalar* _start)
--   , *$(at::Scalar* _end)));
--   }|]

-- range_sso
--   :: Ptr Scalar
--   -> Ptr Scalar
--   -> Ptr TensorOptions
--   -> IO (Ptr Tensor)
-- range_sso _start _end _options =
--   [C.throwBlock| at::Tensor* { return new at::Tensor(at::range(
--     *$(at::Scalar* _start)
--   , *$(at::Scalar* _end)
--   , *$(at::TensorOptions* _options)));
--   }|]

range_out_tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
range_out_tsss _out _start _end _step =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::range_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)));
  }|]

range_out_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
range_out_tss _out _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::range_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

reciprocal_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
reciprocal_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reciprocal(
    *$(at::Tensor* _self)));
  }|]

reciprocal__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
reciprocal__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reciprocal_(
    *$(at::Tensor* _self)));
  }|]

reciprocal_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
reciprocal_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reciprocal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

neg_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
neg_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::neg(
    *$(at::Tensor* _self)));
  }|]

neg__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
neg__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::neg_(
    *$(at::Tensor* _self)));
  }|]

neg_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
neg_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::neg_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

repeat_interleave_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
repeat_interleave_t _repeats =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::repeat_interleave(
    *$(at::Tensor* _repeats)));
  }|]

repeat_interleave_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
repeat_interleave_ttl _self _repeats _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::repeat_interleave(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _repeats)
  , $(int64_t _dim)));
  }|]

repeat_interleave_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
repeat_interleave_tt _self _repeats =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::repeat_interleave(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _repeats)));
  }|]

repeat_interleave_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
repeat_interleave_tll _self _repeats _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::repeat_interleave(
    *$(at::Tensor* _self)
  , $(int64_t _repeats)
  , $(int64_t _dim)));
  }|]

repeat_interleave_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
repeat_interleave_tl _self _repeats =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::repeat_interleave(
    *$(at::Tensor* _self)
  , $(int64_t _repeats)));
  }|]

reshape_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reshape_tl _self _shape =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reshape(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _shape)));
  }|]

_mkldnn_reshape_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_mkldnn_reshape_tl _self _shape =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_mkldnn_reshape(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _shape)));
  }|]

round_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
round_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::round(
    *$(at::Tensor* _self)));
  }|]

round__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
round__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::round_(
    *$(at::Tensor* _self)));
  }|]

round_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
round_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::round_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

rrelu_tssbp
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_tssbp _self _lower _upper _training _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

rrelu_tssb
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu_tssb _self _lower _upper _training =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_tss _self _lower _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)));
  }|]

rrelu_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_ts _self _lower =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)));
  }|]

rrelu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rrelu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu(
    *$(at::Tensor* _self)));
  }|]

rrelu__tssbp
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu__tssbp _self _lower _upper _training _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

rrelu__tssb
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu__tssb _self _lower _upper _training =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu__tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu__tss _self _lower _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)));
  }|]

rrelu__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu__ts _self _lower =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)));
  }|]

rrelu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rrelu__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_(
    *$(at::Tensor* _self)));
  }|]

relu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
relu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::relu(
    *$(at::Tensor* _self)));
  }|]

relu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
relu__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::relu_(
    *$(at::Tensor* _self)));
  }|]

prelu_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
prelu_tt _self _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prelu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)));
  }|]

prelu_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
prelu_backward_ttt _grad_output _self _weight =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::prelu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)));
  }|]

gelu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
gelu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gelu(
    *$(at::Tensor* _self)));
  }|]

gelu_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gelu_backward_tt _grad _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gelu_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _self)));
  }|]

hardshrink_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardshrink_ts _self _lambd =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardshrink(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

hardshrink_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
hardshrink_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardshrink(
    *$(at::Tensor* _self)));
  }|]

hardshrink_backward_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardshrink_backward_tts _grad_out _self _lambd =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardshrink_backward(
    *$(at::Tensor* _grad_out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

rsqrt_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rsqrt_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsqrt(
    *$(at::Tensor* _self)));
  }|]

rsqrt__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rsqrt__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsqrt_(
    *$(at::Tensor* _self)));
  }|]

rsqrt_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rsqrt_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsqrt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

select_tnl
  :: Ptr Tensor
  -> Ptr Dimname
  -> Int64
  -> IO (Ptr Tensor)
select_tnl _self _dim _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::select(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(int64_t _index)));
  }|]

select_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
select_tll _self _dim _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::select(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(int64_t _index)));
  }|]

selu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
selu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::selu(
    *$(at::Tensor* _self)));
  }|]

selu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
selu__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::selu_(
    *$(at::Tensor* _self)));
  }|]

celu_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
celu_ts _self _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::celu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

celu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
celu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::celu(
    *$(at::Tensor* _self)));
  }|]

celu__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
celu__ts _self _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::celu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

celu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
celu__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::celu_(
    *$(at::Tensor* _self)));
  }|]

sigmoid_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sigmoid(
    *$(at::Tensor* _self)));
  }|]

sigmoid__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sigmoid_(
    *$(at::Tensor* _self)));
  }|]

sigmoid_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sigmoid_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

sin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sin_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sin(
    *$(at::Tensor* _self)));
  }|]

sin__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sin__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sin_(
    *$(at::Tensor* _self)));
  }|]

sin_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sin_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sin_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

sinh_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sinh_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sinh(
    *$(at::Tensor* _self)));
  }|]

sinh__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sinh__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sinh_(
    *$(at::Tensor* _self)));
  }|]

sinh_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sinh_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sinh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

detach_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
detach_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::detach(
    *$(at::Tensor* _self)));
  }|]

detach__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
detach__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::detach_(
    *$(at::Tensor* _self)));
  }|]

size_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Int64)
size_tl _self _dim =
  [C.throwBlock| int64_t { return (at::size(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

size_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Int64)
size_tn _self _dim =
  [C.throwBlock| int64_t { return (at::size(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

slice_tllll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
slice_tllll _self _dim _start _end _step =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slice(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(int64_t _start)
  , $(int64_t _end)
  , $(int64_t _step)));
  }|]

slice_tlll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
slice_tlll _self _dim _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slice(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(int64_t _start)
  , $(int64_t _end)));
  }|]

slice_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
slice_tll _self _dim _start =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slice(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(int64_t _start)));
  }|]

slice_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
slice_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slice(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

slice_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
slice_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slice(
    *$(at::Tensor* _self)));
  }|]

slogdet_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
slogdet_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::slogdet(
    *$(at::Tensor* _self)));
  }|]

smm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
smm_tt _self _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

softmax_tls
  :: Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
softmax_tls _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

softmax_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
softmax_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

softmax_tns
  :: Ptr Tensor
  -> Ptr Dimname
  -> ScalarType
  -> IO (Ptr Tensor)
softmax_tns _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softmax(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(at::ScalarType _dtype)));
  }|]

softmax_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
softmax_tn _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softmax(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

_softmax_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
_softmax_tlb _self _dim _half_to_float =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _half_to_float)));
  }|]

_softmax_backward_data_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_softmax_backward_data_ttlt _grad_output _output _dim _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_softmax_backward_data(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)
  , $(int64_t _dim)
  , *$(at::Tensor* _self)));
  }|]

split_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr TensorList)
split_tll _self _split_size _dim =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::split(
    *$(at::Tensor* _self)
  , $(int64_t _split_size)
  , $(int64_t _dim)));
  }|]

split_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr TensorList)
split_tl _self _split_size =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::split(
    *$(at::Tensor* _self)
  , $(int64_t _split_size)));
  }|]

split_with_sizes_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr TensorList)
split_with_sizes_tll _self _split_sizes _dim =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::split_with_sizes(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _split_sizes)
  , $(int64_t _dim)));
  }|]

split_with_sizes_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr TensorList)
split_with_sizes_tl _self _split_sizes =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::split_with_sizes(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _split_sizes)));
  }|]

squeeze_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
squeeze_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::squeeze(
    *$(at::Tensor* _self)));
  }|]

squeeze_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
squeeze_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::squeeze(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

squeeze_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
squeeze_tn _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::squeeze(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

sspaddmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sspaddmm_tttss _self _mat1 _mat2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sspaddmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

sspaddmm_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sspaddmm_ttts _self _mat1 _mat2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sspaddmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)));
  }|]

sspaddmm_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sspaddmm_ttt _self _mat1 _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sspaddmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

sspaddmm_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sspaddmm_out_ttttss _out _self _mat1 _mat2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sspaddmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

sspaddmm_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sspaddmm_out_tttts _out _self _mat1 _mat2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sspaddmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)));
  }|]

sspaddmm_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sspaddmm_out_tttt _out _self _mat1 _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sspaddmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

stack_ll
  :: Ptr TensorList
  -> Int64
  -> IO (Ptr Tensor)
stack_ll _tensors _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::stack(
    *$(std::vector<at::Tensor>* _tensors)
  , $(int64_t _dim)));
  }|]

stack_l
  :: Ptr TensorList
  -> IO (Ptr Tensor)
stack_l _tensors =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::stack(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

stack_out_tll
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> IO (Ptr Tensor)
stack_out_tll _out _tensors _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::stack_out(
    *$(at::Tensor* _out)
  , *$(std::vector<at::Tensor>* _tensors)
  , $(int64_t _dim)));
  }|]

stack_out_tl
  :: Ptr Tensor
  -> Ptr TensorList
  -> IO (Ptr Tensor)
stack_out_tl _out _tensors =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::stack_out(
    *$(at::Tensor* _out)
  , *$(std::vector<at::Tensor>* _tensors)));
  }|]

stft_tllltbb
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
stft_tllltbb _self _n_fft _hop_length _win_length _window _normalized _onesided =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::stft(
    *$(at::Tensor* _self)
  , $(int64_t _n_fft)
  , $(int64_t _hop_length)
  , $(int64_t _win_length)
  , *$(at::Tensor* _window)
  , $(bool _normalized)
  , $(bool _onesided)));
  }|]

stft_tllltb
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
stft_tllltb _self _n_fft _hop_length _win_length _window _normalized =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::stft(
    *$(at::Tensor* _self)
  , $(int64_t _n_fft)
  , $(int64_t _hop_length)
  , $(int64_t _win_length)
  , *$(at::Tensor* _window)
  , $(bool _normalized)));
  }|]

stft_tlllt
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
stft_tlllt _self _n_fft _hop_length _win_length _window =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::stft(
    *$(at::Tensor* _self)
  , $(int64_t _n_fft)
  , $(int64_t _hop_length)
  , $(int64_t _win_length)
  , *$(at::Tensor* _window)));
  }|]

stft_tlll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
stft_tlll _self _n_fft _hop_length _win_length =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::stft(
    *$(at::Tensor* _self)
  , $(int64_t _n_fft)
  , $(int64_t _hop_length)
  , $(int64_t _win_length)));
  }|]

stft_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
stft_tll _self _n_fft _hop_length =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::stft(
    *$(at::Tensor* _self)
  , $(int64_t _n_fft)
  , $(int64_t _hop_length)));
  }|]

stft_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
stft_tl _self _n_fft =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::stft(
    *$(at::Tensor* _self)
  , $(int64_t _n_fft)));
  }|]

stride_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Int64)
stride_tl _self _dim =
  [C.throwBlock| int64_t { return (at::stride(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

stride_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Int64)
stride_tn _self _dim =
  [C.throwBlock| int64_t { return (at::stride(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

sum_ts
  :: Ptr Tensor
  -> ScalarType
  -> IO (Ptr Tensor)
sum_ts _self _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum(
    *$(at::Tensor* _self)
  , $(at::ScalarType _dtype)));
  }|]

sum_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sum_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum(
    *$(at::Tensor* _self)));
  }|]

sum_tlbs
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
sum_tlbs _self _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

sum_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
sum_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

sum_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
sum_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

sum_tNbs
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
sum_tNbs _self _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

sum_tNb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
sum_tNb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)));
  }|]

sum_tN
  :: Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
sum_tN _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

sum_out_ttlbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
sum_out_ttlbs _out _self _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

sum_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
sum_out_ttlb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

sum_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
sum_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

sum_out_ttNbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
sum_out_ttNbs _out _self _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

sum_out_ttNb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
sum_out_ttNb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)));
  }|]

sum_out_ttN
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
sum_out_ttN _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

sqrt_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sqrt_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sqrt(
    *$(at::Tensor* _self)));
  }|]

sqrt__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sqrt__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sqrt_(
    *$(at::Tensor* _self)));
  }|]

sqrt_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sqrt_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sqrt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

square_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
square_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::square(
    *$(at::Tensor* _self)));
  }|]

square__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
square__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::square_(
    *$(at::Tensor* _self)));
  }|]

std_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
std_tb _self _unbiased =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std(
    *$(at::Tensor* _self)
  , $(bool _unbiased)));
  }|]

std_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
std_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std(
    *$(at::Tensor* _self)));
  }|]

std_tlbb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
std_tlbb _self _dim _unbiased _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

std_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
std_tlb _self _dim _unbiased =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)));
  }|]

std_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
std_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

std_mean_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
std_mean_tb _self _unbiased =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::std_mean(
    *$(at::Tensor* _self)
  , $(bool _unbiased)));
  }|]

std_mean_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
std_mean_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::std_mean(
    *$(at::Tensor* _self)));
  }|]

std_mean_tlbb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
std_mean_tlbb _self _dim _unbiased _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::std_mean(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

std_mean_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
std_mean_tlb _self _dim _unbiased =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::std_mean(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)));
  }|]

std_mean_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
std_mean_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::std_mean(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

std_mean_tNbb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
std_mean_tNbb _self _dim _unbiased _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::std_mean(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

std_mean_tNb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
std_mean_tNb _self _dim _unbiased =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::std_mean(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _unbiased)));
  }|]

std_mean_tN
  :: Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
std_mean_tN _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::std_mean(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

std_out_ttlbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
std_out_ttlbb _out _self _dim _unbiased _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

std_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
std_out_ttlb _out _self _dim _unbiased =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)));
  }|]

std_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
std_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

std_tNbb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
std_tNbb _self _dim _unbiased _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

std_tNb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
std_tNb _self _dim _unbiased =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _unbiased)));
  }|]

std_tN
  :: Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
std_tN _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

std_out_ttNbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
std_out_ttNbb _out _self _dim _unbiased _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

std_out_ttNb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
std_out_ttNb _out _self _dim _unbiased =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _unbiased)));
  }|]

std_out_ttN
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
std_out_ttN _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::std_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

prod_ts
  :: Ptr Tensor
  -> ScalarType
  -> IO (Ptr Tensor)
prod_ts _self _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod(
    *$(at::Tensor* _self)
  , $(at::ScalarType _dtype)));
  }|]

prod_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
prod_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod(
    *$(at::Tensor* _self)));
  }|]

prod_tlbs
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
prod_tlbs _self _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

prod_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
prod_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

prod_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
prod_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

prod_out_ttlbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
prod_out_ttlbs _out _self _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

prod_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
prod_out_ttlb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

prod_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
prod_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

prod_tnbs
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
prod_tnbs _self _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

prod_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr Tensor)
prod_tnb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

prod_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
prod_tn _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

prod_out_ttnbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
prod_out_ttnbs _out _self _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

prod_out_ttnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr Tensor)
prod_out_ttnb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

prod_out_ttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
prod_out_ttn _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

t_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
t_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::t(
    *$(at::Tensor* _self)));
  }|]

tan_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
tan_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tan(
    *$(at::Tensor* _self)));
  }|]

tan__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
tan__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tan_(
    *$(at::Tensor* _self)));
  }|]

tan_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
tan_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tan_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

tanh_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
tanh_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tanh(
    *$(at::Tensor* _self)));
  }|]

tanh__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
tanh__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tanh_(
    *$(at::Tensor* _self)));
  }|]

tanh_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
tanh_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tanh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

tensordot_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
tensordot_ttll _self _other _dims_self _dims_other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tensordot(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(std::vector<int64_t>* _dims_self)
  , *$(std::vector<int64_t>* _dims_other)));
  }|]

threshold_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
threshold_tss _self _threshold _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::threshold(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _threshold)
  , *$(at::Scalar* _value)));
  }|]

threshold__tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
threshold__tss _self _threshold _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::threshold_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _threshold)
  , *$(at::Scalar* _value)));
  }|]

threshold_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
threshold_out_ttss _out _self _threshold _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::threshold_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _threshold)
  , *$(at::Scalar* _value)));
  }|]

threshold_backward_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
threshold_backward_tts _grad_output _self _threshold =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::threshold_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _threshold)));
  }|]

transpose_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
transpose_tll _self _dim0 _dim1 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::transpose(
    *$(at::Tensor* _self)
  , $(int64_t _dim0)
  , $(int64_t _dim1)));
  }|]

transpose_tnn
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Dimname
  -> IO (Ptr Tensor)
transpose_tnn _self _dim0 _dim1 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::transpose(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim0)
  , *$(at::Dimname* _dim1)));
  }|]

_mkldnn_transpose_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
_mkldnn_transpose_tll _self _dim0 _dim1 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_mkldnn_transpose(
    *$(at::Tensor* _self)
  , $(int64_t _dim0)
  , $(int64_t _dim1)));
  }|]

_mkldnn_transpose__tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
_mkldnn_transpose__tll _self _dim0 _dim1 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_mkldnn_transpose_(
    *$(at::Tensor* _self)
  , $(int64_t _dim0)
  , $(int64_t _dim1)));
  }|]

one_hot_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
one_hot_tl _self _num_classes =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::one_hot(
    *$(at::Tensor* _self)
  , $(int64_t _num_classes)));
  }|]

one_hot_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
one_hot_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::one_hot(
    *$(at::Tensor* _self)));
  }|]

flip_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
flip_tl _self _dims =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::flip(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dims)));
  }|]

roll_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
roll_tll _self _shifts _dims =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::roll(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _shifts)
  , *$(std::vector<int64_t>* _dims)));
  }|]

roll_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
roll_tl _self _shifts =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::roll(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _shifts)));
  }|]

rot90_tll
  :: Ptr Tensor
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
rot90_tll _self _k _dims =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rot90(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , *$(std::vector<int64_t>* _dims)));
  }|]

rot90_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
rot90_tl _self _k =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rot90(
    *$(at::Tensor* _self)
  , $(int64_t _k)));
  }|]

rot90_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rot90_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rot90(
    *$(at::Tensor* _self)));
  }|]

trapz_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
trapz_ttl _y _x _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::trapz(
    *$(at::Tensor* _y)
  , *$(at::Tensor* _x)
  , $(int64_t _dim)));
  }|]

trapz_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
trapz_tt _y _x =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::trapz(
    *$(at::Tensor* _y)
  , *$(at::Tensor* _x)));
  }|]

trapz_tdl
  :: Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
trapz_tdl _y _dx _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::trapz(
    *$(at::Tensor* _y)
  , $(double _dx)
  , $(int64_t _dim)));
  }|]

trapz_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
trapz_td _y _dx =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::trapz(
    *$(at::Tensor* _y)
  , $(double _dx)));
  }|]

trapz_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
trapz_t _y =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::trapz(
    *$(at::Tensor* _y)));
  }|]

_trilinear_tttlllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
_trilinear_tttlllll _i1 _i2 _i3 _expand1 _expand2 _expand3 _sumdim _unroll_dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_trilinear(
    *$(at::Tensor* _i1)
  , *$(at::Tensor* _i2)
  , *$(at::Tensor* _i3)
  , *$(std::vector<int64_t>* _expand1)
  , *$(std::vector<int64_t>* _expand2)
  , *$(std::vector<int64_t>* _expand3)
  , *$(std::vector<int64_t>* _sumdim)
  , $(int64_t _unroll_dim)));
  }|]

_trilinear_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_trilinear_tttllll _i1 _i2 _i3 _expand1 _expand2 _expand3 _sumdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_trilinear(
    *$(at::Tensor* _i1)
  , *$(at::Tensor* _i2)
  , *$(at::Tensor* _i3)
  , *$(std::vector<int64_t>* _expand1)
  , *$(std::vector<int64_t>* _expand2)
  , *$(std::vector<int64_t>* _expand3)
  , *$(std::vector<int64_t>* _sumdim)));
  }|]

triplet_margin_loss_tttdddbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> CDouble
  -> CBool
  -> Int64
  -> IO (Ptr Tensor)
triplet_margin_loss_tttdddbl _anchor _positive _negative _margin _p _eps _swap _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::triplet_margin_loss(
    *$(at::Tensor* _anchor)
  , *$(at::Tensor* _positive)
  , *$(at::Tensor* _negative)
  , $(double _margin)
  , $(double _p)
  , $(double _eps)
  , $(bool _swap)
  , $(int64_t _reduction)));
  }|]

triplet_margin_loss_tttdddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
triplet_margin_loss_tttdddb _anchor _positive _negative _margin _p _eps _swap =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::triplet_margin_loss(
    *$(at::Tensor* _anchor)
  , *$(at::Tensor* _positive)
  , *$(at::Tensor* _negative)
  , $(double _margin)
  , $(double _p)
  , $(double _eps)
  , $(bool _swap)));
  }|]

triplet_margin_loss_tttddd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
triplet_margin_loss_tttddd _anchor _positive _negative _margin _p _eps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::triplet_margin_loss(
    *$(at::Tensor* _anchor)
  , *$(at::Tensor* _positive)
  , *$(at::Tensor* _negative)
  , $(double _margin)
  , $(double _p)
  , $(double _eps)));
  }|]

triplet_margin_loss_tttdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
triplet_margin_loss_tttdd _anchor _positive _negative _margin _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::triplet_margin_loss(
    *$(at::Tensor* _anchor)
  , *$(at::Tensor* _positive)
  , *$(at::Tensor* _negative)
  , $(double _margin)
  , $(double _p)));
  }|]

triplet_margin_loss_tttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
triplet_margin_loss_tttd _anchor _positive _negative _margin =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::triplet_margin_loss(
    *$(at::Tensor* _anchor)
  , *$(at::Tensor* _positive)
  , *$(at::Tensor* _negative)
  , $(double _margin)));
  }|]

triplet_margin_loss_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
triplet_margin_loss_ttt _anchor _positive _negative =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::triplet_margin_loss(
    *$(at::Tensor* _anchor)
  , *$(at::Tensor* _positive)
  , *$(at::Tensor* _negative)));
  }|]

true_divide_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
true_divide_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::true_divide(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

true_divide_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
true_divide_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::true_divide_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

true_divide_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
true_divide_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::true_divide(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

trunc_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
trunc_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::trunc(
    *$(at::Tensor* _self)));
  }|]

trunc__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
trunc__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::trunc_(
    *$(at::Tensor* _self)));
  }|]

trunc_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
trunc_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::trunc_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_has_compatible_shallow_copy_type_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (CBool)
_has_compatible_shallow_copy_type_tt _self _from =
  [C.throwBlock| bool { return (at::_has_compatible_shallow_copy_type(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _from)));
  }|]

_unique_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_unique_tbb _self _sorted _return_inverse =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_unique(
    *$(at::Tensor* _self)
  , $(bool _sorted)
  , $(bool _return_inverse)));
  }|]

_unique_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_unique_tb _self _sorted =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_unique(
    *$(at::Tensor* _self)
  , $(bool _sorted)));
  }|]

_unique_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_unique_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_unique(
    *$(at::Tensor* _self)));
  }|]

unique_dim_tlbbb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
unique_dim_tlbbb _self _dim _sorted _return_inverse _return_counts =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::unique_dim(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _sorted)
  , $(bool _return_inverse)
  , $(bool _return_counts)));
  }|]

unique_dim_tlbb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
unique_dim_tlbb _self _dim _sorted _return_inverse =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::unique_dim(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _sorted)
  , $(bool _return_inverse)));
  }|]

unique_dim_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
unique_dim_tlb _self _dim _sorted =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::unique_dim(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _sorted)));
  }|]

unique_dim_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
unique_dim_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::unique_dim(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

unique_consecutive_tbbl
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
unique_consecutive_tbbl _self _return_inverse _return_counts _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::unique_consecutive(
    *$(at::Tensor* _self)
  , $(bool _return_inverse)
  , $(bool _return_counts)
  , $(int64_t _dim)));
  }|]

unique_consecutive_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
unique_consecutive_tbb _self _return_inverse _return_counts =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::unique_consecutive(
    *$(at::Tensor* _self)
  , $(bool _return_inverse)
  , $(bool _return_counts)));
  }|]

unique_consecutive_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
unique_consecutive_tb _self _return_inverse =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::unique_consecutive(
    *$(at::Tensor* _self)
  , $(bool _return_inverse)));
  }|]

unique_consecutive_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
unique_consecutive_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::unique_consecutive(
    *$(at::Tensor* _self)));
  }|]

unique_dim_consecutive_tlbb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
unique_dim_consecutive_tlbb _self _dim _return_inverse _return_counts =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::unique_dim_consecutive(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _return_inverse)
  , $(bool _return_counts)));
  }|]

unique_dim_consecutive_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
unique_dim_consecutive_tlb _self _dim _return_inverse =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::unique_dim_consecutive(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _return_inverse)));
  }|]

unique_dim_consecutive_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
unique_dim_consecutive_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::unique_dim_consecutive(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

_unique2_tbbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_unique2_tbbb _self _sorted _return_inverse _return_counts =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_unique2(
    *$(at::Tensor* _self)
  , $(bool _sorted)
  , $(bool _return_inverse)
  , $(bool _return_counts)));
  }|]

_unique2_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_unique2_tbb _self _sorted _return_inverse =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_unique2(
    *$(at::Tensor* _self)
  , $(bool _sorted)
  , $(bool _return_inverse)));
  }|]

_unique2_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_unique2_tb _self _sorted =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_unique2(
    *$(at::Tensor* _self)
  , $(bool _sorted)));
  }|]

_unique2_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_unique2_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_unique2(
    *$(at::Tensor* _self)));
  }|]

_unsafe_view_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_unsafe_view_tl _self _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_unsafe_view(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)));
  }|]

unsqueeze_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
unsqueeze_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::unsqueeze(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

var_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
var_tb _self _unbiased =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var(
    *$(at::Tensor* _self)
  , $(bool _unbiased)));
  }|]

var_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
var_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var(
    *$(at::Tensor* _self)));
  }|]

var_tlbb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
var_tlbb _self _dim _unbiased _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

var_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
var_tlb _self _dim _unbiased =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)));
  }|]

var_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
var_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

var_out_ttlbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
var_out_ttlbb _out _self _dim _unbiased _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

var_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
var_out_ttlb _out _self _dim _unbiased =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)));
  }|]

var_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
var_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

var_tNbb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
var_tNbb _self _dim _unbiased _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

var_tNb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
var_tNb _self _dim _unbiased =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _unbiased)));
  }|]

var_tN
  :: Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
var_tN _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

var_out_ttNbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
var_out_ttNbb _out _self _dim _unbiased _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

var_out_ttNb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
var_out_ttNb _out _self _dim _unbiased =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _unbiased)));
  }|]

var_out_ttN
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
var_out_ttN _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::var_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

var_mean_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
var_mean_tb _self _unbiased =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::var_mean(
    *$(at::Tensor* _self)
  , $(bool _unbiased)));
  }|]

var_mean_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
var_mean_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::var_mean(
    *$(at::Tensor* _self)));
  }|]

var_mean_tlbb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
var_mean_tlbb _self _dim _unbiased _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::var_mean(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

var_mean_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
var_mean_tlb _self _dim _unbiased =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::var_mean(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)));
  }|]

var_mean_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
var_mean_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::var_mean(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

var_mean_tNbb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
var_mean_tNbb _self _dim _unbiased _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::var_mean(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

var_mean_tNb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
var_mean_tNb _self _dim _unbiased =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::var_mean(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _unbiased)));
  }|]

var_mean_tN
  :: Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
var_mean_tN _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::var_mean(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

where_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
where_ttt _condition _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::where(
    *$(at::Tensor* _condition)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

where_t
  :: Ptr Tensor
  -> IO (Ptr TensorList)
where_t _condition =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::where(
    *$(at::Tensor* _condition)));
  }|]

_s_where_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_s_where_ttt _condition _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_s_where(
    *$(at::Tensor* _condition)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

norm_except_dim_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
norm_except_dim_tll _v _pow _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm_except_dim(
    *$(at::Tensor* _v)
  , $(int64_t _pow)
  , $(int64_t _dim)));
  }|]

norm_except_dim_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
norm_except_dim_tl _v _pow =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm_except_dim(
    *$(at::Tensor* _v)
  , $(int64_t _pow)));
  }|]

norm_except_dim_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
norm_except_dim_t _v =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm_except_dim(
    *$(at::Tensor* _v)));
  }|]

_weight_norm_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_weight_norm_ttl _v _g _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_weight_norm(
    *$(at::Tensor* _v)
  , *$(at::Tensor* _g)
  , $(int64_t _dim)));
  }|]

_weight_norm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_weight_norm_tt _v _g =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_weight_norm(
    *$(at::Tensor* _v)
  , *$(at::Tensor* _g)));
  }|]

_weight_norm_cuda_interface_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_weight_norm_cuda_interface_ttl _v _g _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_weight_norm_cuda_interface(
    *$(at::Tensor* _v)
  , *$(at::Tensor* _g)
  , $(int64_t _dim)));
  }|]

_weight_norm_cuda_interface_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_weight_norm_cuda_interface_tt _v _g =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_weight_norm_cuda_interface(
    *$(at::Tensor* _v)
  , *$(at::Tensor* _g)));
  }|]

_weight_norm_cuda_interface_backward_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_weight_norm_cuda_interface_backward_ttttl _grad_w _saved_v _saved_g _saved_norms _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_weight_norm_cuda_interface_backward(
    *$(at::Tensor* _grad_w)
  , *$(at::Tensor* _saved_v)
  , *$(at::Tensor* _saved_g)
  , *$(at::Tensor* _saved_norms)
  , $(int64_t _dim)));
  }|]

_weight_norm_differentiable_backward_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_weight_norm_differentiable_backward_ttttl _grad_w _saved_v _saved_g _saved_norms _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_weight_norm_differentiable_backward(
    *$(at::Tensor* _grad_w)
  , *$(at::Tensor* _saved_v)
  , *$(at::Tensor* _saved_g)
  , *$(at::Tensor* _saved_norms)
  , $(int64_t _dim)));
  }|]

zeros_lNo
  :: Ptr IntArray
  -> Ptr DimnameList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
zeros_lNo _size _names _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::zeros(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)
  , *$(at::TensorOptions* _options)));
  }|]

zeros_lN
  :: Ptr IntArray
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
zeros_lN _size _names =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::zeros(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)));
  }|]

zeros_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
zeros_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::zeros(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

zeros_l
  :: Ptr IntArray
  -> IO (Ptr Tensor)
zeros_l _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::zeros(
    *$(std::vector<int64_t>* _size)));
  }|]

zeros_out_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
zeros_out_tl _out _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::zeros_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)));
  }|]

zeros_like_toM
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
zeros_like_toM _self _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::zeros_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

zeros_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
zeros_like_to _self _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::zeros_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

zeros_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
zeros_like_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::zeros_like(
    *$(at::Tensor* _self)));
  }|]

_standard_gamma_grad_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_standard_gamma_grad_tt _self _output =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_standard_gamma_grad(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _output)));
  }|]

_standard_gamma_tp
  :: Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
_standard_gamma_tp _self _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_standard_gamma(
    *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

_standard_gamma_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_standard_gamma_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_standard_gamma(
    *$(at::Tensor* _self)));
  }|]

_dirichlet_grad_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_dirichlet_grad_ttt _x _alpha _total =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_dirichlet_grad(
    *$(at::Tensor* _x)
  , *$(at::Tensor* _alpha)
  , *$(at::Tensor* _total)));
  }|]

_sample_dirichlet_tp
  :: Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
_sample_dirichlet_tp _self _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sample_dirichlet(
    *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

_sample_dirichlet_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_sample_dirichlet_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sample_dirichlet(
    *$(at::Tensor* _self)));
  }|]

poisson_tp
  :: Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
poisson_tp _self _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::poisson(
    *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

poisson_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
poisson_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::poisson(
    *$(at::Tensor* _self)));
  }|]

native_norm_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
native_norm_ts _self _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::native_norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)));
  }|]

native_norm_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
native_norm_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::native_norm(
    *$(at::Tensor* _self)));
  }|]

_sparse_sum_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_sparse_sum_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_sum(
    *$(at::Tensor* _self)));
  }|]

_sparse_sum_ts
  :: Ptr Tensor
  -> ScalarType
  -> IO (Ptr Tensor)
_sparse_sum_ts _self _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_sum(
    *$(at::Tensor* _self)
  , $(at::ScalarType _dtype)));
  }|]

_sparse_sum_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_sparse_sum_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_sum(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

_sparse_sum_tls
  :: Ptr Tensor
  -> Ptr IntArray
  -> ScalarType
  -> IO (Ptr Tensor)
_sparse_sum_tls _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_sum(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(at::ScalarType _dtype)));
  }|]

_sparse_sum_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_sparse_sum_backward_ttl _grad _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_sum_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

norm_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> ScalarType
  -> IO (Ptr Tensor)
norm_tss _self _p _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , $(at::ScalarType _dtype)));
  }|]

norm_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
norm_ts _self _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)));
  }|]

norm_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
norm_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm(
    *$(at::Tensor* _self)));
  }|]

norm_tslbs
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntArray
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
norm_tslbs _self _p _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

norm_tslb
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
norm_tslb _self _p _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

norm_tsl
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntArray
  -> IO (Ptr Tensor)
norm_tsl _self _p _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<int64_t>* _dim)));
  }|]

norm_out_ttslbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntArray
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
norm_out_ttslbs _out _self _p _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

norm_out_ttslb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
norm_out_ttslb _out _self _p _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

norm_out_ttsl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntArray
  -> IO (Ptr Tensor)
norm_out_ttsl _out _self _p _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<int64_t>* _dim)));
  }|]

norm_tsNbs
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr DimnameList
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
norm_tsNbs _self _p _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

norm_tsNb
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
norm_tsNb _self _p _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)));
  }|]

norm_tsN
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
norm_tsN _self _p _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

norm_out_ttsNbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr DimnameList
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
norm_out_ttsNbs _out _self _p _dim _keepdim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

norm_out_ttsNb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
norm_out_ttsNb _out _self _p _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)));
  }|]

norm_out_ttsN
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
norm_out_ttsN _out _self _p _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

frobenius_norm_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
frobenius_norm_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::frobenius_norm(
    *$(at::Tensor* _self)));
  }|]

frobenius_norm_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
frobenius_norm_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::frobenius_norm(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

frobenius_norm_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
frobenius_norm_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::frobenius_norm(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

frobenius_norm_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
frobenius_norm_out_ttlb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::frobenius_norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

frobenius_norm_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
frobenius_norm_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::frobenius_norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

nuclear_norm_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
nuclear_norm_tb _self _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nuclear_norm(
    *$(at::Tensor* _self)
  , $(bool _keepdim)));
  }|]

nuclear_norm_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
nuclear_norm_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nuclear_norm(
    *$(at::Tensor* _self)));
  }|]

nuclear_norm_out_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
nuclear_norm_out_ttb _out _self _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nuclear_norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(bool _keepdim)));
  }|]

nuclear_norm_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nuclear_norm_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nuclear_norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

nuclear_norm_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
nuclear_norm_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nuclear_norm(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

nuclear_norm_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
nuclear_norm_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nuclear_norm(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

nuclear_norm_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
nuclear_norm_out_ttlb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nuclear_norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

nuclear_norm_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
nuclear_norm_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nuclear_norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

clone_tM
  :: Ptr Tensor
  -> MemoryFormat
  -> IO (Ptr Tensor)
clone_tM _self _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clone(
    *$(at::Tensor* _self)
  , $(at::MemoryFormat _memory_format)));
  }|]

clone_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
clone_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clone(
    *$(at::Tensor* _self)));
  }|]

resize_as__ttM
  :: Ptr Tensor
  -> Ptr Tensor
  -> MemoryFormat
  -> IO (Ptr Tensor)
resize_as__ttM _self _the_template _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::resize_as_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _the_template)
  , $(at::MemoryFormat _memory_format)));
  }|]

resize_as__tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
resize_as__tt _self _the_template =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::resize_as_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _the_template)));
  }|]

pow_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
pow_out_tts _out _self _exponent =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pow_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _exponent)));
  }|]

pow_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
pow_ts _self _exponent =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pow(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _exponent)));
  }|]

zero__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
zero__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::zero_(
    *$(at::Tensor* _self)));
  }|]

sub_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_out_ttts _out _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sub_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

sub_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sub_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sub_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

sub_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_tts _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sub(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

sub_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sub_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sub(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

sub_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_tss _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sub(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

sub_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sub(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

rsub_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rsub_tts _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsub(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

rsub_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rsub_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsub(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

rsub_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rsub_tss _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsub(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

rsub_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rsub_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsub(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

_sparse_addmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_sparse_addmm_tttss _self _sparse _dense _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _sparse)
  , *$(at::Tensor* _dense)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

_sparse_addmm_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_sparse_addmm_ttts _self _sparse _dense _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _sparse)
  , *$(at::Tensor* _dense)
  , *$(at::Scalar* _beta)));
  }|]

_sparse_addmm_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_sparse_addmm_ttt _self _sparse _dense =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _sparse)
  , *$(at::Tensor* _dense)));
  }|]

addmm_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmm_out_ttttss _out _self _mat1 _mat2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmm_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmm_out_tttts _out _self _mat1 _mat2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)));
  }|]

addmm_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addmm_out_tttt _out _self _mat1 _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

addmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmm_tttss _self _mat1 _mat2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmm_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmm_ttts _self _mat1 _mat2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)));
  }|]

addmm_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addmm_ttt _self _mat1 _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

sparse_coo_tensor_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sparse_coo_tensor(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_coo_tensor_tto
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_tto _indices _values _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_coo_tensor_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sparse_coo_tensor_tt _indices _values =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)));
  }|]

sparse_coo_tensor_ttlo
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_ttlo _indices _values _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_coo_tensor_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
sparse_coo_tensor_ttl _indices _values _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(std::vector<int64_t>* _size)));
  }|]

_sparse_coo_tensor_unsafe_ttlo
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_sparse_coo_tensor_unsafe_ttlo _indices _values _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_coo_tensor_unsafe(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

_sparse_coo_tensor_unsafe_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_sparse_coo_tensor_unsafe_ttl _indices _values _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_coo_tensor_unsafe(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(std::vector<int64_t>* _size)));
  }|]

_sparse_coo_tensor_with_dims_lllo
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_sparse_coo_tensor_with_dims_lllo _sparse_dim _dense_dim _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_coo_tensor_with_dims(
    $(int64_t _sparse_dim)
  , $(int64_t _dense_dim)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

_sparse_coo_tensor_with_dims_and_tensors_llltto
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_sparse_coo_tensor_with_dims_and_tensors_llltto _sparse_dim _dense_dim _size _indices _values _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_coo_tensor_with_dims_and_tensors(
    $(int64_t _sparse_dim)
  , $(int64_t _dense_dim)
  , *$(std::vector<int64_t>* _size)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(at::TensorOptions* _options)));
  }|]

to_dense_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
to_dense_backward_tt _grad _input =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::to_dense_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _input)));
  }|]

hspmm_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hspmm_out_ttt _out _mat1 _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hspmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

hspmm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hspmm_tt _mat1 _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hspmm(
    *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

copy_sparse_to_sparse__ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
copy_sparse_to_sparse__ttb _self _src _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::copy_sparse_to_sparse_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _src)
  , $(bool _non_blocking)));
  }|]

copy_sparse_to_sparse__tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
copy_sparse_to_sparse__tt _self _src =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::copy_sparse_to_sparse_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _src)));
  }|]

unbind_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr TensorList)
unbind_tl _self _dim =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::unbind(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

unbind_t
  :: Ptr Tensor
  -> IO (Ptr TensorList)
unbind_t _self =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::unbind(
    *$(at::Tensor* _self)));
  }|]

unbind_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr TensorList)
unbind_tn _self _dim =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::unbind(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

mkldnn_reorder_conv2d_weight_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
mkldnn_reorder_conv2d_weight_tllll _self _padding _stride _dilation _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_reorder_conv2d_weight(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)));
  }|]

mkldnn_reorder_conv2d_weight_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mkldnn_reorder_conv2d_weight_tlll _self _padding _stride _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_reorder_conv2d_weight(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

mkldnn_reorder_conv2d_weight_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mkldnn_reorder_conv2d_weight_tll _self _padding _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_reorder_conv2d_weight(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

mkldnn_reorder_conv2d_weight_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mkldnn_reorder_conv2d_weight_tl _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_reorder_conv2d_weight(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

mkldnn_reorder_conv2d_weight_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
mkldnn_reorder_conv2d_weight_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_reorder_conv2d_weight(
    *$(at::Tensor* _self)));
  }|]

to_mkldnn_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
to_mkldnn_backward_tt _grad _input =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::to_mkldnn_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _input)));
  }|]

quantize_per_tensor_tdls
  :: Ptr Tensor
  -> CDouble
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
quantize_per_tensor_tdls _self _scale _zero_point _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantize_per_tensor(
    *$(at::Tensor* _self)
  , $(double _scale)
  , $(int64_t _zero_point)
  , $(at::ScalarType _dtype)));
  }|]

quantize_per_channel_tttls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
quantize_per_channel_tttls _self _scales _zero_points _axis _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantize_per_channel(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _scales)
  , *$(at::Tensor* _zero_points)
  , $(int64_t _axis)
  , $(at::ScalarType _dtype)));
  }|]

dequantize_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
dequantize_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::dequantize(
    *$(at::Tensor* _self)));
  }|]

q_scale_t
  :: Ptr Tensor
  -> IO (CDouble)
q_scale_t _self =
  [C.throwBlock| double { return (at::q_scale(
    *$(at::Tensor* _self)));
  }|]

q_zero_point_t
  :: Ptr Tensor
  -> IO (Int64)
q_zero_point_t _self =
  [C.throwBlock| int64_t { return (at::q_zero_point(
    *$(at::Tensor* _self)));
  }|]

q_per_channel_scales_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
q_per_channel_scales_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::q_per_channel_scales(
    *$(at::Tensor* _self)));
  }|]

q_per_channel_zero_points_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
q_per_channel_zero_points_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::q_per_channel_zero_points(
    *$(at::Tensor* _self)));
  }|]

q_per_channel_axis_t
  :: Ptr Tensor
  -> IO (Int64)
q_per_channel_axis_t _self =
  [C.throwBlock| int64_t { return (at::q_per_channel_axis(
    *$(at::Tensor* _self)));
  }|]

int_repr_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
int_repr_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::int_repr(
    *$(at::Tensor* _self)));
  }|]

_make_per_tensor_quantized_tensor_tdl
  :: Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
_make_per_tensor_quantized_tensor_tdl _self _scale _zero_point =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_make_per_tensor_quantized_tensor(
    *$(at::Tensor* _self)
  , $(double _scale)
  , $(int64_t _zero_point)));
  }|]

_make_per_channel_quantized_tensor_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_make_per_channel_quantized_tensor_tttl _self _scale _zero_point _axis =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_make_per_channel_quantized_tensor(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _scale)
  , *$(at::Tensor* _zero_point)
  , $(int64_t _axis)));
  }|]

fake_quantize_per_tensor_affine_tdlll
  :: Ptr Tensor
  -> CDouble
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
fake_quantize_per_tensor_affine_tdlll _self _scale _zero_point _quant_min _quant_max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fake_quantize_per_tensor_affine(
    *$(at::Tensor* _self)
  , $(double _scale)
  , $(int64_t _zero_point)
  , $(int64_t _quant_min)
  , $(int64_t _quant_max)));
  }|]

fake_quantize_per_tensor_affine_backward_ttdlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
fake_quantize_per_tensor_affine_backward_ttdlll _grad _self _scale _zero_point _quant_min _quant_max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fake_quantize_per_tensor_affine_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _self)
  , $(double _scale)
  , $(int64_t _zero_point)
  , $(int64_t _quant_min)
  , $(int64_t _quant_max)));
  }|]

fake_quantize_per_channel_affine_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
fake_quantize_per_channel_affine_tttlll _self _scale _zero_point _axis _quant_min _quant_max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fake_quantize_per_channel_affine(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _scale)
  , *$(at::Tensor* _zero_point)
  , $(int64_t _axis)
  , $(int64_t _quant_min)
  , $(int64_t _quant_max)));
  }|]

fake_quantize_per_channel_affine_backward_ttttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
fake_quantize_per_channel_affine_backward_ttttlll _grad _self _scale _zero_point _axis _quant_min _quant_max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fake_quantize_per_channel_affine_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _scale)
  , *$(at::Tensor* _zero_point)
  , $(int64_t _axis)
  , $(int64_t _quant_min)
  , $(int64_t _quant_max)));
  }|]

meshgrid_l
  :: Ptr TensorList
  -> IO (Ptr TensorList)
meshgrid_l _tensors =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::meshgrid(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

cartesian_prod_l
  :: Ptr TensorList
  -> IO (Ptr Tensor)
cartesian_prod_l _tensors =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cartesian_prod(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

combinations_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
combinations_tlb _self _r _with_replacement =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::combinations(
    *$(at::Tensor* _self)
  , $(int64_t _r)
  , $(bool _with_replacement)));
  }|]

combinations_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
combinations_tl _self _r =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::combinations(
    *$(at::Tensor* _self)
  , $(int64_t _r)));
  }|]

combinations_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
combinations_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::combinations(
    *$(at::Tensor* _self)));
  }|]

result_type_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (ScalarType)
result_type_tt _tensor _other =
  [C.throwBlock| at::ScalarType { return (at::result_type(
    *$(at::Tensor* _tensor)
  , *$(at::Tensor* _other)));
  }|]

result_type_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (ScalarType)
result_type_ts _tensor _other =
  [C.throwBlock| at::ScalarType { return (at::result_type(
    *$(at::Tensor* _tensor)
  , *$(at::Scalar* _other)));
  }|]

result_type_st
  :: Ptr Scalar
  -> Ptr Tensor
  -> IO (ScalarType)
result_type_st _scalar _tensor =
  [C.throwBlock| at::ScalarType { return (at::result_type(
    *$(at::Scalar* _scalar)
  , *$(at::Tensor* _tensor)));
  }|]

result_type_ss
  :: Ptr Scalar
  -> Ptr Scalar
  -> IO (ScalarType)
result_type_ss _scalar1 _scalar2 =
  [C.throwBlock| at::ScalarType { return (at::result_type(
    *$(at::Scalar* _scalar1)
  , *$(at::Scalar* _scalar2)));
  }|]

can_cast_ss
  :: ScalarType
  -> ScalarType
  -> IO (CBool)
can_cast_ss _from _to =
  [C.throwBlock| bool { return (at::can_cast(
    $(at::ScalarType _from)
  , $(at::ScalarType _to)));
  }|]

promote_types_ss
  :: ScalarType
  -> ScalarType
  -> IO (ScalarType)
promote_types_ss _type1 _type2 =
  [C.throwBlock| at::ScalarType { return (at::promote_types(
    $(at::ScalarType _type1)
  , $(at::ScalarType _type2)));
  }|]

_local_scalar_dense_t
  :: Ptr Tensor
  -> IO (Ptr Scalar)
_local_scalar_dense_t _self =
  [C.throwBlock| at::Scalar* { return new at::Scalar(at::_local_scalar_dense(
    *$(at::Tensor* _self)));
  }|]

_thnn_fused_lstm_cell_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_thnn_fused_lstm_cell_ttttt _input_gates _hidden_gates _cx _input_bias _hidden_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_thnn_fused_lstm_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _input_bias)
  , *$(at::Tensor* _hidden_bias)));
  }|]

_thnn_fused_lstm_cell_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_thnn_fused_lstm_cell_tttt _input_gates _hidden_gates _cx _input_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_thnn_fused_lstm_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _input_bias)));
  }|]

_thnn_fused_lstm_cell_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_thnn_fused_lstm_cell_ttt _input_gates _hidden_gates _cx =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_thnn_fused_lstm_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _cx)));
  }|]

_thnn_fused_lstm_cell_backward_tttttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor,Tensor)))
_thnn_fused_lstm_cell_backward_tttttb _grad_hy _grad_cy _cx _cy _workspace _has_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_thnn_fused_lstm_cell_backward(
    *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _grad_cy)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _cy)
  , *$(at::Tensor* _workspace)
  , $(bool _has_bias)));
  }|]

_thnn_differentiable_lstm_cell_backward_tttttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor,Tensor)))
_thnn_differentiable_lstm_cell_backward_tttttttt _grad_hy _grad_cy _input_gates _hidden_gates _input_bias _hidden_bias _cx _cy =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_thnn_differentiable_lstm_cell_backward(
    *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _grad_cy)
  , *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _input_bias)
  , *$(at::Tensor* _hidden_bias)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _cy)));
  }|]

_thnn_fused_gru_cell_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_thnn_fused_gru_cell_ttttt _input_gates _hidden_gates _hx _input_bias _hidden_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_thnn_fused_gru_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _input_bias)
  , *$(at::Tensor* _hidden_bias)));
  }|]

_thnn_fused_gru_cell_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_thnn_fused_gru_cell_tttt _input_gates _hidden_gates _hx _input_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_thnn_fused_gru_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _input_bias)));
  }|]

_thnn_fused_gru_cell_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_thnn_fused_gru_cell_ttt _input_gates _hidden_gates _hx =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_thnn_fused_gru_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _hx)));
  }|]

_thnn_fused_gru_cell_backward_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor,Tensor)))
_thnn_fused_gru_cell_backward_ttb _grad_hy _workspace _has_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_thnn_fused_gru_cell_backward(
    *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _workspace)
  , $(bool _has_bias)));
  }|]

_thnn_differentiable_gru_cell_backward_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor,Tensor)))
_thnn_differentiable_gru_cell_backward_tttttt _grad_hy _input_gates _hidden_gates _hx _input_bias _hidden_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_thnn_differentiable_gru_cell_backward(
    *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _input_bias)
  , *$(at::Tensor* _hidden_bias)));
  }|]

lstm_tllbldbbb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
lstm_tllbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::lstm(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

lstm_ttllbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
lstm_ttllbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::lstm(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

gru_ttlbldbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
gru_ttlbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::gru(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

gru_tttlbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
gru_tttlbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::gru(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

rnn_tanh_ttlbldbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
rnn_tanh_ttlbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::rnn_tanh(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

rnn_tanh_tttlbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
rnn_tanh_tttlbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::rnn_tanh(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

rnn_relu_ttlbldbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
rnn_relu_ttlbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::rnn_relu(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

rnn_relu_tttlbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
rnn_relu_tttlbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::rnn_relu(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

lstm_cell_tltttt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
lstm_cell_tltttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::lstm_cell(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

lstm_cell_tlttt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
lstm_cell_tlttt _input _hx _w_ih _w_hh _b_ih =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::lstm_cell(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)));
  }|]

lstm_cell_tltt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
lstm_cell_tltt _input _hx _w_ih _w_hh =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::lstm_cell(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)));
  }|]

gru_cell_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gru_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gru_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

gru_cell_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gru_cell_ttttt _input _hx _w_ih _w_hh _b_ih =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gru_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)));
  }|]

gru_cell_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gru_cell_tttt _input _hx _w_ih _w_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gru_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)));
  }|]

rnn_tanh_cell_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_tanh_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rnn_tanh_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

rnn_tanh_cell_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_tanh_cell_ttttt _input _hx _w_ih _w_hh _b_ih =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rnn_tanh_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)));
  }|]

rnn_tanh_cell_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_tanh_cell_tttt _input _hx _w_ih _w_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rnn_tanh_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)));
  }|]

rnn_relu_cell_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_relu_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rnn_relu_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

rnn_relu_cell_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_relu_cell_ttttt _input _hx _w_ih _w_hh _b_ih =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rnn_relu_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)));
  }|]

rnn_relu_cell_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_relu_cell_tttt _input _hx _w_ih _w_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rnn_relu_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)));
  }|]

quantized_lstm_tllbldbbbsb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> ScalarType
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
quantized_lstm_tllbldbbbsb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first _dtype _use_dynamic =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::quantized_lstm(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)
  , $(at::ScalarType _dtype)
  , $(bool _use_dynamic)));
  }|]

quantized_lstm_tllbldbbbs
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> ScalarType
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
quantized_lstm_tllbldbbbs _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first _dtype =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::quantized_lstm(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)
  , $(at::ScalarType _dtype)));
  }|]

quantized_lstm_tllbldbbb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
quantized_lstm_tllbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::quantized_lstm(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

quantized_lstm_ttllbldbbsb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> ScalarType
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
quantized_lstm_ttllbldbbsb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional _dtype _use_dynamic =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::quantized_lstm(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(at::ScalarType _dtype)
  , $(bool _use_dynamic)));
  }|]

quantized_lstm_ttllbldbbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> ScalarType
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
quantized_lstm_ttllbldbbs _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional _dtype =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::quantized_lstm(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(at::ScalarType _dtype)));
  }|]

quantized_lstm_ttllbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
quantized_lstm_ttllbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::quantized_lstm(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

quantized_gru_ttlbldbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
quantized_gru_ttlbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::quantized_gru(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

quantized_gru_tttlbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
quantized_gru_tttlbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::quantized_gru(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

quantized_lstm_cell_tlttttttttssss
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
quantized_lstm_cell_tlttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::quantized_lstm_cell(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

quantized_gru_cell_ttttttttttssss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
quantized_gru_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantized_gru_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

quantized_rnn_relu_cell_ttttttttttssss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
quantized_rnn_relu_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantized_rnn_relu_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

quantized_rnn_tanh_cell_ttttttttttssss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
quantized_rnn_tanh_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantized_rnn_tanh_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

_pack_padded_sequence_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_pack_padded_sequence_ttb _input _lengths _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_pack_padded_sequence(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _lengths)
  , $(bool _batch_first)));
  }|]

_pack_padded_sequence_backward_tltb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_pack_padded_sequence_backward_tltb _grad _input_size _batch_sizes _batch_first =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_pack_padded_sequence_backward(
    *$(at::Tensor* _grad)
  , *$(std::vector<int64_t>* _input_size)
  , *$(at::Tensor* _batch_sizes)
  , $(bool _batch_first)));
  }|]

_pad_packed_sequence_ttbsl
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Ptr Scalar
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_pad_packed_sequence_ttbsl _data _batch_sizes _batch_first _padding_value _total_length =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_pad_packed_sequence(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , $(bool _batch_first)
  , *$(at::Scalar* _padding_value)
  , $(int64_t _total_length)));
  }|]

masked_fill_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
masked_fill_tts _self _mask _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::masked_fill(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Scalar* _value)));
  }|]

masked_fill_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_fill_ttt _self _mask _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::masked_fill(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Tensor* _value)));
  }|]

masked_scatter_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_scatter_ttt _self _mask _source =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::masked_scatter(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Tensor* _source)));
  }|]

index_add_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_add_tltt _self _dim _index _source =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_add(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

index_add_tntt
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_add_tntt _self _dim _index _source =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_add(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

index_fill_tlts
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
index_fill_tlts _self _dim _index _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_fill(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Scalar* _value)));
  }|]

index_fill_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_fill_tltt _self _dim _index _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_fill(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _value)));
  }|]

index_fill_tnts
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
index_fill_tnts _self _dim _index _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_fill(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)
  , *$(at::Scalar* _value)));
  }|]

index_fill_tntt
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_fill_tntt _self _dim _index _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_fill(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _value)));
  }|]

scatter_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
scatter_tltt _self _dim _index _src =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::scatter(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _src)));
  }|]

scatter_tlts
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
scatter_tlts _self _dim _index _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::scatter(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Scalar* _value)));
  }|]

scatter_tntt
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
scatter_tntt _self _dim _index _src =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::scatter(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _src)));
  }|]

scatter_tnts
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
scatter_tnts _self _dim _index _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::scatter(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)
  , *$(at::Scalar* _value)));
  }|]

scatter_add_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
scatter_add_tltt _self _dim _index _src =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::scatter_add(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _src)));
  }|]

scatter_add_tntt
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
scatter_add_tntt _self _dim _index _src =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::scatter_add(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _src)));
  }|]

bitwise_and_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bitwise_and_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_and_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

bitwise_and_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
bitwise_and_out_tts _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_and_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

bitwise_and_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
bitwise_and_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_and(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

bitwise_and_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bitwise_and_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_and(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__and___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__and___ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::__and__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__and___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__and___tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::__and__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

bitwise_or_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bitwise_or_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_or_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

bitwise_or_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
bitwise_or_out_tts _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_or_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

bitwise_or_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
bitwise_or_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_or(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

bitwise_or_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bitwise_or_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_or(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__or___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__or___ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::__or__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__or___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__or___tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::__or__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

bitwise_xor_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bitwise_xor_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_xor_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

bitwise_xor_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
bitwise_xor_out_tts _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_xor_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

bitwise_xor_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
bitwise_xor_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_xor(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

bitwise_xor_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bitwise_xor_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_xor(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__xor___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__xor___ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::__xor__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__xor___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__xor___tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::__xor__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__lshift___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__lshift___ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::__lshift__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__lshift___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__lshift___tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::__lshift__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__rshift___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__rshift___ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::__rshift__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__rshift___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__rshift___tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::__rshift__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

addbmm_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addbmm_out_ttttss _out _self _batch1 _batch2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addbmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addbmm_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addbmm_out_tttts _out _self _batch1 _batch2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addbmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)));
  }|]

addbmm_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addbmm_out_tttt _out _self _batch1 _batch2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addbmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)));
  }|]

addbmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addbmm_tttss _self _batch1 _batch2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addbmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addbmm_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addbmm_ttts _self _batch1 _batch2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addbmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)));
  }|]

addbmm_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addbmm_ttt _self _batch1 _batch2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addbmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)));
  }|]

diag_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
diag_out_ttl _out _self _diagonal =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diag_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _diagonal)));
  }|]

diag_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
diag_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diag_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

diag_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
diag_tl _self _diagonal =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diag(
    *$(at::Tensor* _self)
  , $(int64_t _diagonal)));
  }|]

diag_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
diag_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::diag(
    *$(at::Tensor* _self)));
  }|]

cross_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cross_out_tttl _out _self _other _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cross_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(int64_t _dim)));
  }|]

cross_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cross_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cross_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

cross_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cross_ttl _self _other _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cross(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(int64_t _dim)));
  }|]

cross_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cross_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cross(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

triu_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
triu_out_ttl _out _self _diagonal =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::triu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _diagonal)));
  }|]

triu_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
triu_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::triu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

triu_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
triu_tl _self _diagonal =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::triu(
    *$(at::Tensor* _self)
  , $(int64_t _diagonal)));
  }|]

triu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
triu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::triu(
    *$(at::Tensor* _self)));
  }|]

tril_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
tril_out_ttl _out _self _diagonal =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tril_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _diagonal)));
  }|]

tril_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
tril_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tril_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

tril_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
tril_tl _self _diagonal =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tril(
    *$(at::Tensor* _self)
  , $(int64_t _diagonal)));
  }|]

tril_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
tril_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tril(
    *$(at::Tensor* _self)));
  }|]

tril_indices_lllo
  :: Int64
  -> Int64
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
tril_indices_lllo _row _col _offset _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tril_indices(
    $(int64_t _row)
  , $(int64_t _col)
  , $(int64_t _offset)
  , *$(at::TensorOptions* _options)));
  }|]

tril_indices_lll
  :: Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
tril_indices_lll _row _col _offset =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tril_indices(
    $(int64_t _row)
  , $(int64_t _col)
  , $(int64_t _offset)));
  }|]

tril_indices_ll
  :: Int64
  -> Int64
  -> IO (Ptr Tensor)
tril_indices_ll _row _col =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tril_indices(
    $(int64_t _row)
  , $(int64_t _col)));
  }|]

triu_indices_lllo
  :: Int64
  -> Int64
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
triu_indices_lllo _row _col _offset _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::triu_indices(
    $(int64_t _row)
  , $(int64_t _col)
  , $(int64_t _offset)
  , *$(at::TensorOptions* _options)));
  }|]

triu_indices_lll
  :: Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
triu_indices_lll _row _col _offset =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::triu_indices(
    $(int64_t _row)
  , $(int64_t _col)
  , $(int64_t _offset)));
  }|]

triu_indices_ll
  :: Int64
  -> Int64
  -> IO (Ptr Tensor)
triu_indices_ll _row _col =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::triu_indices(
    $(int64_t _row)
  , $(int64_t _col)));
  }|]

trace_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
trace_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::trace(
    *$(at::Tensor* _self)));
  }|]

ne_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ne_out_tts _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ne_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ne_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ne_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ne(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ne_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ne_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ne_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

ne_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ne_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ne(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

eq_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
eq_out_tts _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::eq_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

eq_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
eq_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::eq(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

eq_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
eq_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::eq_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

eq_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
eq_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::eq(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

ge_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ge_out_tts _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ge_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ge_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ge_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ge(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ge_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ge_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ge_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

ge_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ge_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ge(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

le_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
le_out_tts _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::le_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

le_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
le_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::le(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

le_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
le_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::le_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

le_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
le_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::le(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

gt_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
gt_out_tts _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

gt_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
gt_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gt(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

gt_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gt_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

gt_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gt_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gt(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

lt_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lt_out_tts _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

lt_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lt_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lt(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

lt_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lt_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

lt_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lt_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lt(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

take_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
take_out_ttt _out _self _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::take_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _index)));
  }|]

take_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
take_tt _self _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::take(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _index)));
  }|]

index_select_out_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_select_out_ttlt _out _self _dim _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_select_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)));
  }|]

index_select_tlt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_select_tlt _self _dim _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_select(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)));
  }|]

index_select_out_ttnt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_select_out_ttnt _out _self _dim _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_select_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)));
  }|]

index_select_tnt
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_select_tnt _self _dim _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_select(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)));
  }|]

masked_select_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_select_out_ttt _out _self _mask =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::masked_select_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)));
  }|]

masked_select_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_select_tt _self _mask =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::masked_select(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)));
  }|]

nonzero_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nonzero_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nonzero_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

nonzero_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
nonzero_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nonzero(
    *$(at::Tensor* _self)));
  }|]

nonzero_numpy_t
  :: Ptr Tensor
  -> IO (Ptr TensorList)
nonzero_numpy_t _self =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::nonzero_numpy(
    *$(at::Tensor* _self)));
  }|]

gather_out_ttltb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
gather_out_ttltb _out _self _dim _index _sparse_grad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gather_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , $(bool _sparse_grad)));
  }|]

gather_out_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gather_out_ttlt _out _self _dim _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gather_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)));
  }|]

gather_tltb
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
gather_tltb _self _dim _index _sparse_grad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gather(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , $(bool _sparse_grad)));
  }|]

gather_tlt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gather_tlt _self _dim _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gather(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)));
  }|]

gather_out_ttntb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
gather_out_ttntb _out _self _dim _index _sparse_grad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gather_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)
  , $(bool _sparse_grad)));
  }|]

gather_out_ttnt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gather_out_ttnt _out _self _dim _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gather_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)));
  }|]

gather_tntb
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
gather_tntb _self _dim _index _sparse_grad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gather(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)
  , $(bool _sparse_grad)));
  }|]

gather_tnt
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gather_tnt _self _dim _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gather(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)));
  }|]

_gather_sparse_backward_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_gather_sparse_backward_tltt _self _dim _index _grad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_gather_sparse_backward(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _grad)));
  }|]

addcmul_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcmul_out_tttts _out _self _tensor1 _tensor2 _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addcmul_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

addcmul_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addcmul_out_tttt _out _self _tensor1 _tensor2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addcmul_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)));
  }|]

addcmul_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcmul_ttts _self _tensor1 _tensor2 _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addcmul(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

addcmul_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addcmul_ttt _self _tensor1 _tensor2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addcmul(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)));
  }|]

addcdiv_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcdiv_out_tttts _out _self _tensor1 _tensor2 _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addcdiv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

addcdiv_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addcdiv_out_tttt _out _self _tensor1 _tensor2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addcdiv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)));
  }|]

addcdiv_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcdiv_ttts _self _tensor1 _tensor2 _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addcdiv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

addcdiv_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addcdiv_ttt _self _tensor1 _tensor2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addcdiv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)));
  }|]

lstsq_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
lstsq_out_tttt _X _qr _self _A =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::lstsq_out(
    *$(at::Tensor* _X)
  , *$(at::Tensor* _qr)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

lstsq_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
lstsq_tt _self _A =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::lstsq(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

triangular_solve_out_ttttbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
triangular_solve_out_ttttbbb _X _M _self _A _upper _transpose _unitriangular =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::triangular_solve_out(
    *$(at::Tensor* _X)
  , *$(at::Tensor* _M)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)
  , $(bool _transpose)
  , $(bool _unitriangular)));
  }|]

triangular_solve_out_ttttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
triangular_solve_out_ttttbb _X _M _self _A _upper _transpose =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::triangular_solve_out(
    *$(at::Tensor* _X)
  , *$(at::Tensor* _M)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)
  , $(bool _transpose)));
  }|]

triangular_solve_out_ttttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
triangular_solve_out_ttttb _X _M _self _A _upper =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::triangular_solve_out(
    *$(at::Tensor* _X)
  , *$(at::Tensor* _M)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)));
  }|]

triangular_solve_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
triangular_solve_out_tttt _X _M _self _A =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::triangular_solve_out(
    *$(at::Tensor* _X)
  , *$(at::Tensor* _M)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

triangular_solve_ttbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
triangular_solve_ttbbb _self _A _upper _transpose _unitriangular =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::triangular_solve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)
  , $(bool _transpose)
  , $(bool _unitriangular)));
  }|]

triangular_solve_ttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
triangular_solve_ttbb _self _A _upper _transpose =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::triangular_solve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)
  , $(bool _transpose)));
  }|]

triangular_solve_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
triangular_solve_ttb _self _A _upper =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::triangular_solve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)));
  }|]

triangular_solve_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
triangular_solve_tt _self _A =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::triangular_solve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

_triangular_solve_helper_ttbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_triangular_solve_helper_ttbbb _self _A _upper _transpose _unitriangular =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_triangular_solve_helper(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)
  , $(bool _transpose)
  , $(bool _unitriangular)));
  }|]

symeig_out_tttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
symeig_out_tttbb _e _V _self _eigenvectors _upper =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::symeig_out(
    *$(at::Tensor* _e)
  , *$(at::Tensor* _V)
  , *$(at::Tensor* _self)
  , $(bool _eigenvectors)
  , $(bool _upper)));
  }|]

symeig_out_tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
symeig_out_tttb _e _V _self _eigenvectors =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::symeig_out(
    *$(at::Tensor* _e)
  , *$(at::Tensor* _V)
  , *$(at::Tensor* _self)
  , $(bool _eigenvectors)));
  }|]

symeig_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
symeig_out_ttt _e _V _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::symeig_out(
    *$(at::Tensor* _e)
  , *$(at::Tensor* _V)
  , *$(at::Tensor* _self)));
  }|]

symeig_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
symeig_tbb _self _eigenvectors _upper =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::symeig(
    *$(at::Tensor* _self)
  , $(bool _eigenvectors)
  , $(bool _upper)));
  }|]

symeig_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
symeig_tb _self _eigenvectors =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::symeig(
    *$(at::Tensor* _self)
  , $(bool _eigenvectors)));
  }|]

symeig_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
symeig_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::symeig(
    *$(at::Tensor* _self)));
  }|]

_symeig_helper_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_symeig_helper_tbb _self _eigenvectors _upper =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_symeig_helper(
    *$(at::Tensor* _self)
  , $(bool _eigenvectors)
  , $(bool _upper)));
  }|]

eig_out_tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
eig_out_tttb _e _v _self _eigenvectors =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::eig_out(
    *$(at::Tensor* _e)
  , *$(at::Tensor* _v)
  , *$(at::Tensor* _self)
  , $(bool _eigenvectors)));
  }|]

eig_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
eig_out_ttt _e _v _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::eig_out(
    *$(at::Tensor* _e)
  , *$(at::Tensor* _v)
  , *$(at::Tensor* _self)));
  }|]

eig_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
eig_tb _self _eigenvectors =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::eig(
    *$(at::Tensor* _self)
  , $(bool _eigenvectors)));
  }|]

eig_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
eig_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::eig(
    *$(at::Tensor* _self)));
  }|]

svd_out_ttttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
svd_out_ttttbb _U _S _V _self _some _compute_uv =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::svd_out(
    *$(at::Tensor* _U)
  , *$(at::Tensor* _S)
  , *$(at::Tensor* _V)
  , *$(at::Tensor* _self)
  , $(bool _some)
  , $(bool _compute_uv)));
  }|]

svd_out_ttttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
svd_out_ttttb _U _S _V _self _some =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::svd_out(
    *$(at::Tensor* _U)
  , *$(at::Tensor* _S)
  , *$(at::Tensor* _V)
  , *$(at::Tensor* _self)
  , $(bool _some)));
  }|]

svd_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
svd_out_tttt _U _S _V _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::svd_out(
    *$(at::Tensor* _U)
  , *$(at::Tensor* _S)
  , *$(at::Tensor* _V)
  , *$(at::Tensor* _self)));
  }|]

svd_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
svd_tbb _self _some _compute_uv =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::svd(
    *$(at::Tensor* _self)
  , $(bool _some)
  , $(bool _compute_uv)));
  }|]

svd_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
svd_tb _self _some =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::svd(
    *$(at::Tensor* _self)
  , $(bool _some)));
  }|]

svd_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
svd_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::svd(
    *$(at::Tensor* _self)));
  }|]

_svd_helper_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_svd_helper_tbb _self _some _compute_uv =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_svd_helper(
    *$(at::Tensor* _self)
  , $(bool _some)
  , $(bool _compute_uv)));
  }|]

cholesky_out_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_out_ttb _out _self _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cholesky_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

cholesky_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cholesky_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cholesky_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

cholesky_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_tb _self _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cholesky(
    *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

cholesky_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cholesky_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cholesky(
    *$(at::Tensor* _self)));
  }|]

_cholesky_helper_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cholesky_helper_tb _self _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cholesky_helper(
    *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

cholesky_solve_out_tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_solve_out_tttb _out _self _input2 _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cholesky_solve_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , $(bool _upper)));
  }|]

cholesky_solve_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cholesky_solve_out_ttt _out _self _input2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cholesky_solve_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)));
  }|]

cholesky_solve_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_solve_ttb _self _input2 _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cholesky_solve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , $(bool _upper)));
  }|]

cholesky_solve_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cholesky_solve_tt _self _input2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cholesky_solve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)));
  }|]

_cholesky_solve_helper_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cholesky_solve_helper_ttb _self _A _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cholesky_solve_helper(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)));
  }|]

solve_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
solve_tt _self _A =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::solve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

solve_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
solve_out_tttt _solution _lu _self _A =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::solve_out(
    *$(at::Tensor* _solution)
  , *$(at::Tensor* _lu)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

_solve_helper_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_solve_helper_tt _self _A =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_solve_helper(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

cholesky_inverse_out_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_inverse_out_ttb _out _self _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cholesky_inverse_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

cholesky_inverse_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cholesky_inverse_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cholesky_inverse_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

cholesky_inverse_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_inverse_tb _self _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cholesky_inverse(
    *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

cholesky_inverse_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cholesky_inverse_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cholesky_inverse(
    *$(at::Tensor* _self)));
  }|]

qr_out_tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
qr_out_tttb _Q _R _self _some =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::qr_out(
    *$(at::Tensor* _Q)
  , *$(at::Tensor* _R)
  , *$(at::Tensor* _self)
  , $(bool _some)));
  }|]

qr_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
qr_out_ttt _Q _R _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::qr_out(
    *$(at::Tensor* _Q)
  , *$(at::Tensor* _R)
  , *$(at::Tensor* _self)));
  }|]

qr_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
qr_tb _self _some =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::qr(
    *$(at::Tensor* _self)
  , $(bool _some)));
  }|]

qr_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
qr_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::qr(
    *$(at::Tensor* _self)));
  }|]

_qr_helper_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_qr_helper_tb _self _some =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_qr_helper(
    *$(at::Tensor* _self)
  , $(bool _some)));
  }|]

geqrf_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
geqrf_out_ttt _a _tau _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::geqrf_out(
    *$(at::Tensor* _a)
  , *$(at::Tensor* _tau)
  , *$(at::Tensor* _self)));
  }|]

geqrf_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
geqrf_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::geqrf(
    *$(at::Tensor* _self)));
  }|]

orgqr_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
orgqr_out_ttt _out _self _input2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::orgqr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)));
  }|]

orgqr_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
orgqr_tt _self _input2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::orgqr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)));
  }|]

ormqr_out_ttttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
ormqr_out_ttttbb _out _self _input2 _input3 _left _transpose =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ormqr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)
  , $(bool _left)
  , $(bool _transpose)));
  }|]

ormqr_out_ttttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
ormqr_out_ttttb _out _self _input2 _input3 _left =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ormqr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)
  , $(bool _left)));
  }|]

ormqr_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ormqr_out_tttt _out _self _input2 _input3 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ormqr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)));
  }|]

ormqr_tttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
ormqr_tttbb _self _input2 _input3 _left _transpose =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ormqr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)
  , $(bool _left)
  , $(bool _transpose)));
  }|]

ormqr_tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
ormqr_tttb _self _input2 _input3 _left =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ormqr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)
  , $(bool _left)));
  }|]

ormqr_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ormqr_ttt _self _input2 _input3 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ormqr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)));
  }|]

_lu_with_info_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_lu_with_info_tbb _self _pivot _check_errors =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_lu_with_info(
    *$(at::Tensor* _self)
  , $(bool _pivot)
  , $(bool _check_errors)));
  }|]

_lu_with_info_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_lu_with_info_tb _self _pivot =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_lu_with_info(
    *$(at::Tensor* _self)
  , $(bool _pivot)));
  }|]

_lu_with_info_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_lu_with_info_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_lu_with_info(
    *$(at::Tensor* _self)));
  }|]

lu_solve_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lu_solve_out_tttt _out _self _LU_data _LU_pivots =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lu_solve_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _LU_data)
  , *$(at::Tensor* _LU_pivots)));
  }|]

lu_solve_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lu_solve_ttt _self _LU_data _LU_pivots =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lu_solve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _LU_data)
  , *$(at::Tensor* _LU_pivots)));
  }|]

_lu_solve_helper_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_lu_solve_helper_ttt _self _LU_data _LU_pivots =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_lu_solve_helper(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _LU_data)
  , *$(at::Tensor* _LU_pivots)));
  }|]

multinomial_out_ttlbp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
multinomial_out_ttlbp _out _self _num_samples _replacement _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multinomial_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _num_samples)
  , $(bool _replacement)
  , $(at::Generator * _generator)));
  }|]

multinomial_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
multinomial_out_ttlb _out _self _num_samples _replacement =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multinomial_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _num_samples)
  , $(bool _replacement)));
  }|]

multinomial_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multinomial_out_ttl _out _self _num_samples =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multinomial_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _num_samples)));
  }|]

multinomial_tlbp
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
multinomial_tlbp _self _num_samples _replacement _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multinomial(
    *$(at::Tensor* _self)
  , $(int64_t _num_samples)
  , $(bool _replacement)
  , $(at::Generator * _generator)));
  }|]

multinomial_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
multinomial_tlb _self _num_samples _replacement =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multinomial(
    *$(at::Tensor* _self)
  , $(int64_t _num_samples)
  , $(bool _replacement)));
  }|]

multinomial_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multinomial_tl _self _num_samples =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multinomial(
    *$(at::Tensor* _self)
  , $(int64_t _num_samples)));
  }|]

_multinomial_alias_setup_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_multinomial_alias_setup_t _probs =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_multinomial_alias_setup(
    *$(at::Tensor* _probs)));
  }|]

_multinomial_alias_draw_ttlp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Generator
  -> IO (Ptr Tensor)
_multinomial_alias_draw_ttlp _J _q _num_samples _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_multinomial_alias_draw(
    *$(at::Tensor* _J)
  , *$(at::Tensor* _q)
  , $(int64_t _num_samples)
  , $(at::Generator * _generator)));
  }|]

_multinomial_alias_draw_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_multinomial_alias_draw_ttl _J _q _num_samples =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_multinomial_alias_draw(
    *$(at::Tensor* _J)
  , *$(at::Tensor* _q)
  , $(int64_t _num_samples)));
  }|]

lgamma_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lgamma_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lgamma_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

lgamma_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
lgamma_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lgamma(
    *$(at::Tensor* _self)));
  }|]

digamma_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
digamma_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::digamma_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

digamma_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
digamma_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::digamma(
    *$(at::Tensor* _self)));
  }|]

polygamma_out_tlt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
polygamma_out_tlt _out _n _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::polygamma_out(
    *$(at::Tensor* _out)
  , $(int64_t _n)
  , *$(at::Tensor* _self)));
  }|]

polygamma_lt
  :: Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
polygamma_lt _n _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::polygamma(
    $(int64_t _n)
  , *$(at::Tensor* _self)));
  }|]

erfinv_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erfinv_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::erfinv(
    *$(at::Tensor* _self)));
  }|]

erfinv_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
erfinv_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::erfinv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

sign_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sign_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sign(
    *$(at::Tensor* _self)));
  }|]

sign_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sign_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sign_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

dist_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
dist_tts _self _other _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::dist(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _p)));
  }|]

dist_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
dist_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::dist(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

atan2_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
atan2_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::atan2_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

atan2_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
atan2_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::atan2(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

lerp_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lerp_out_ttts _out _self _end _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lerp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Scalar* _weight)));
  }|]

lerp_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lerp_out_tttt _out _self _end _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lerp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Tensor* _weight)));
  }|]

lerp_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lerp_tts _self _end _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lerp(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Scalar* _weight)));
  }|]

lerp_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lerp_ttt _self _end _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lerp(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Tensor* _weight)));
  }|]

histc_out_ttlss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
histc_out_ttlss _out _self _bins _min _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _bins)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

histc_out_ttls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Scalar
  -> IO (Ptr Tensor)
histc_out_ttls _out _self _bins _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _bins)
  , *$(at::Scalar* _min)));
  }|]

histc_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
histc_out_ttl _out _self _bins =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _bins)));
  }|]

histc_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
histc_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

histc_tlss
  :: Ptr Tensor
  -> Int64
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
histc_tlss _self _bins _min _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc(
    *$(at::Tensor* _self)
  , $(int64_t _bins)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

histc_tls
  :: Ptr Tensor
  -> Int64
  -> Ptr Scalar
  -> IO (Ptr Tensor)
histc_tls _self _bins _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc(
    *$(at::Tensor* _self)
  , $(int64_t _bins)
  , *$(at::Scalar* _min)));
  }|]

histc_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
histc_tl _self _bins =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc(
    *$(at::Tensor* _self)
  , $(int64_t _bins)));
  }|]

histc_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
histc_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc(
    *$(at::Tensor* _self)));
  }|]

fmod_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
fmod_out_tts _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fmod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

fmod_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
fmod_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fmod(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

fmod_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fmod_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fmod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

fmod_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fmod_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fmod(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

remainder_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
remainder_out_tts _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::remainder_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

remainder_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
remainder_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::remainder(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

remainder_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
remainder_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::remainder_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

remainder_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
remainder_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::remainder(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

min_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
min_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::min_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

min_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
min_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::min(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

min_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
min_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::min(
    *$(at::Tensor* _self)));
  }|]

max_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

max_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

max_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
max_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max(
    *$(at::Tensor* _self)));
  }|]

median_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
median_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::median(
    *$(at::Tensor* _self)));
  }|]

sort_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_out_tttlb _values _indices _self _dim _descending =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _descending)));
  }|]

sort_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_out_tttl _values _indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

sort_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_out_ttt _values _indices _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)));
  }|]

sort_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_tlb _self _dim _descending =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _descending)));
  }|]

sort_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

sort_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort(
    *$(at::Tensor* _self)));
  }|]

sort_out_tttnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_out_tttnb _values _indices _self _dim _descending =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _descending)));
  }|]

sort_out_tttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_out_tttn _values _indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

sort_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_tnb _self _dim _descending =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _descending)));
  }|]

sort_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_tn _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

argsort_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
argsort_tlb _self _dim _descending =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argsort(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _descending)));
  }|]

argsort_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
argsort_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argsort(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

argsort_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
argsort_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argsort(
    *$(at::Tensor* _self)));
  }|]

argsort_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr Tensor)
argsort_tnb _self _dim _descending =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argsort(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _descending)));
  }|]

argsort_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
argsort_tn _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argsort(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

topk_out_tttllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_out_tttllbb _values _indices _self _k _dim _largest _sorted =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _largest)
  , $(bool _sorted)));
  }|]

topk_out_tttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_out_tttllb _values _indices _self _k _dim _largest =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _largest)));
  }|]

topk_out_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_out_tttll _values _indices _self _k _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)));
  }|]

topk_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_out_tttl _values _indices _self _k =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)));
  }|]

topk_tllbb
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_tllbb _self _k _dim _largest _sorted =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _largest)
  , $(bool _sorted)));
  }|]

topk_tllb
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_tllb _self _k _dim _largest =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _largest)));
  }|]

topk_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_tll _self _k _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)));
  }|]

topk_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_tl _self _k =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk(
    *$(at::Tensor* _self)
  , $(int64_t _k)));
  }|]

all_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
all_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all(
    *$(at::Tensor* _self)));
  }|]

any_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
any_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any(
    *$(at::Tensor* _self)));
  }|]

renorm_out_ttsls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Int64
  -> Ptr Scalar
  -> IO (Ptr Tensor)
renorm_out_ttsls _out _self _p _dim _maxnorm =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::renorm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , $(int64_t _dim)
  , *$(at::Scalar* _maxnorm)));
  }|]

renorm_tsls
  :: Ptr Tensor
  -> Ptr Scalar
  -> Int64
  -> Ptr Scalar
  -> IO (Ptr Tensor)
renorm_tsls _self _p _dim _maxnorm =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::renorm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , $(int64_t _dim)
  , *$(at::Scalar* _maxnorm)));
  }|]

equal_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (CBool)
equal_tt _self _other =
  [C.throwBlock| bool { return (at::equal(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

pow_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_out_ttt _out _self _exponent =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pow_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _exponent)));
  }|]

pow_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_tt _self _exponent =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pow(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _exponent)));
  }|]

pow_out_tst
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_out_tst _out _self _exponent =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pow_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _self)
  , *$(at::Tensor* _exponent)));
  }|]

pow_st
  :: Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_st _self _exponent =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pow(
    *$(at::Scalar* _self)
  , *$(at::Tensor* _exponent)));
  }|]

normal_out_ttdp
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_ttdp _out _mean _std _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mean)
  , $(double _std)
  , $(at::Generator * _generator)));
  }|]

normal_out_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
normal_out_ttd _out _mean _std =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mean)
  , $(double _std)));
  }|]

normal_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
normal_out_tt _out _mean =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mean)));
  }|]

normal_tdp
  :: Ptr Tensor
  -> CDouble
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_tdp _mean _std _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    *$(at::Tensor* _mean)
  , $(double _std)
  , $(at::Generator * _generator)));
  }|]

normal_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
normal_td _mean _std =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    *$(at::Tensor* _mean)
  , $(double _std)));
  }|]

normal_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
normal_t _mean =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    *$(at::Tensor* _mean)));
  }|]

normal_out_tdtp
  :: Ptr Tensor
  -> CDouble
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_tdtp _out _mean _std _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , $(double _mean)
  , *$(at::Tensor* _std)
  , $(at::Generator * _generator)));
  }|]

normal_out_tdt
  :: Ptr Tensor
  -> CDouble
  -> Ptr Tensor
  -> IO (Ptr Tensor)
normal_out_tdt _out _mean _std =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , $(double _mean)
  , *$(at::Tensor* _std)));
  }|]

normal_dtp
  :: CDouble
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_dtp _mean _std _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    $(double _mean)
  , *$(at::Tensor* _std)
  , $(at::Generator * _generator)));
  }|]

normal_dt
  :: CDouble
  -> Ptr Tensor
  -> IO (Ptr Tensor)
normal_dt _mean _std =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    $(double _mean)
  , *$(at::Tensor* _std)));
  }|]

normal_out_tttp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_tttp _out _mean _std _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _std)
  , $(at::Generator * _generator)));
  }|]

normal_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
normal_out_ttt _out _mean _std =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _std)));
  }|]

normal_ttp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_ttp _mean _std _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    *$(at::Tensor* _mean)
  , *$(at::Tensor* _std)
  , $(at::Generator * _generator)));
  }|]

normal_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
normal_tt _mean _std =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    *$(at::Tensor* _mean)
  , *$(at::Tensor* _std)));
  }|]

normal_ddlpo
  :: CDouble
  -> CDouble
  -> Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
normal_ddlpo _mean _std _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    $(double _mean)
  , $(double _std)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

normal_ddlp
  :: CDouble
  -> CDouble
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_ddlp _mean _std _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    $(double _mean)
  , $(double _std)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

normal_ddl
  :: CDouble
  -> CDouble
  -> Ptr IntArray
  -> IO (Ptr Tensor)
normal_ddl _mean _std _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    $(double _mean)
  , $(double _std)
  , *$(std::vector<int64_t>* _size)));
  }|]

normal_out_tddlp
  :: Ptr Tensor
  -> CDouble
  -> CDouble
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_tddlp _out _mean _std _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , $(double _mean)
  , $(double _std)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

normal_out_tddl
  :: Ptr Tensor
  -> CDouble
  -> CDouble
  -> Ptr IntArray
  -> IO (Ptr Tensor)
normal_out_tddl _out _mean _std _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , $(double _mean)
  , $(double _std)
  , *$(std::vector<int64_t>* _size)));
  }|]

alias_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
alias_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::alias(
    *$(at::Tensor* _self)));
  }|]

_addr_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_addr_tttss _self _vec1 _vec2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_addr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

_addr_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_addr_ttts _self _vec1 _vec2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_addr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)));
  }|]

_addr_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_addr_ttt _self _vec1 _vec2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_addr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)));
  }|]

_addr__tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_addr__tttss _self _vec1 _vec2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_addr_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

_addr__ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_addr__ttts _self _vec1 _vec2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_addr_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)));
  }|]

_addr__ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_addr__ttt _self _vec1 _vec2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_addr_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)));
  }|]

_addr_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_addr_out_ttttss _out _self _vec1 _vec2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_addr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

_addr_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_addr_out_tttts _out _self _vec1 _vec2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_addr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)));
  }|]

_addr_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_addr_out_tttt _out _self _vec1 _vec2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_addr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)));
  }|]

_index_copy__tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_index_copy__tltt _self _dim _index _source =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_index_copy_(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

_cumsum_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_cumsum_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cumsum(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

_cumsum_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_cumsum_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cumsum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

_cumprod_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_cumprod_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cumprod(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

_cumprod_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_cumprod_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cumprod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

_var_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_var_tb _self _unbiased =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_var(
    *$(at::Tensor* _self)
  , $(bool _unbiased)));
  }|]

_var_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_var_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_var(
    *$(at::Tensor* _self)));
  }|]

_std_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_std_tb _self _unbiased =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_std(
    *$(at::Tensor* _self)
  , $(bool _unbiased)));
  }|]

_std_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_std_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_std(
    *$(at::Tensor* _self)));
  }|]

_amp_non_finite_check_and_unscale__ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (())
_amp_non_finite_check_and_unscale__ttt _self _found_inf _inv_scale =
  [C.throwBlock| void {  (at::_amp_non_finite_check_and_unscale_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _found_inf)
  , *$(at::Tensor* _inv_scale)));
  }|]

_amp_update_scale_tttddl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
_amp_update_scale_tttddl _growth_tracker _current_scale _found_inf _scale_growth_factor _scale_backoff_factor _growth_interval =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_amp_update_scale(
    *$(at::Tensor* _growth_tracker)
  , *$(at::Tensor* _current_scale)
  , *$(at::Tensor* _found_inf)
  , $(double _scale_growth_factor)
  , $(double _scale_backoff_factor)
  , $(int64_t _growth_interval)));
  }|]

_cat_ll
  :: Ptr TensorList
  -> Int64
  -> IO (Ptr Tensor)
_cat_ll _tensors _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cat(
    *$(std::vector<at::Tensor>* _tensors)
  , $(int64_t _dim)));
  }|]

_cat_l
  :: Ptr TensorList
  -> IO (Ptr Tensor)
_cat_l _tensors =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cat(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

_cat_out_tll
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> IO (Ptr Tensor)
_cat_out_tll _out _tensors _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cat_out(
    *$(at::Tensor* _out)
  , *$(std::vector<at::Tensor>* _tensors)
  , $(int64_t _dim)));
  }|]

_cat_out_tl
  :: Ptr Tensor
  -> Ptr TensorList
  -> IO (Ptr Tensor)
_cat_out_tl _out _tensors =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cat_out(
    *$(at::Tensor* _out)
  , *$(std::vector<at::Tensor>* _tensors)));
  }|]

_mode_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_mode_tlb _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_mode(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

_mode_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_mode_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_mode(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

_mode_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_mode_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_mode(
    *$(at::Tensor* _self)));
  }|]

_mode_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_mode_out_tttlb _values _indices _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_mode_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

_mode_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_mode_out_tttl _values _indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_mode_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

_mode_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_mode_out_ttt _values _indices _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_mode_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)));
  }|]

_max_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_max_tlb _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_max(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

_max_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_max_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_max(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

_max_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_max_out_tttlb _max _max_indices _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_max_out(
    *$(at::Tensor* _max)
  , *$(at::Tensor* _max_indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

_max_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_max_out_tttl _max _max_indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_max_out(
    *$(at::Tensor* _max)
  , *$(at::Tensor* _max_indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

_min_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_min_tlb _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_min(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

_min_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_min_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_min(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

_min_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_min_out_tttlb _min _min_indices _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_min_out(
    *$(at::Tensor* _min)
  , *$(at::Tensor* _min_indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

_min_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_min_out_tttl _min _min_indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_min_out(
    *$(at::Tensor* _min)
  , *$(at::Tensor* _min_indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

mse_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mse_loss_out_tttl _out _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mse_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

mse_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mse_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mse_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

mse_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mse_loss_ttl _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mse_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

mse_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mse_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mse_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

mse_loss_backward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mse_loss_backward_out_ttttl _grad_input _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mse_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

mse_loss_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mse_loss_backward_tttl _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mse_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

l1_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
l1_loss_out_tttl _out _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::l1_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

l1_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
l1_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::l1_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

l1_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
l1_loss_ttl _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::l1_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

l1_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
l1_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::l1_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

l1_loss_backward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
l1_loss_backward_out_ttttl _grad_input _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::l1_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

l1_loss_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
l1_loss_backward_tttl _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::l1_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_out_tttsstl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multi_margin_loss_out_tttsstl _out _self _target _p _margin _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_out_tttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multi_margin_loss_out_tttsst _out _self _target _p _margin _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)));
  }|]

multi_margin_loss_out_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
multi_margin_loss_out_tttss _out _self _target _p _margin =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)));
  }|]

multi_margin_loss_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
multi_margin_loss_out_ttts _out _self _target _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)));
  }|]

multi_margin_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multi_margin_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

multi_margin_loss_ttsstl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multi_margin_loss_ttsstl _self _target _p _margin _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_ttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multi_margin_loss_ttsst _self _target _p _margin _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)));
  }|]

multi_margin_loss_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
multi_margin_loss_ttss _self _target _p _margin =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)));
  }|]

multi_margin_loss_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
multi_margin_loss_tts _self _target _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)));
  }|]

multi_margin_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multi_margin_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

multi_margin_loss_backward_out_ttttsstl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multi_margin_loss_backward_out_ttttsstl _grad_input _grad_output _self _target _p _margin _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_backward_out_ttttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multi_margin_loss_backward_out_ttttsst _grad_input _grad_output _self _target _p _margin _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)));
  }|]

multi_margin_loss_backward_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
multi_margin_loss_backward_out_ttttss _grad_input _grad_output _self _target _p _margin =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)));
  }|]

multi_margin_loss_backward_tttsstl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multi_margin_loss_backward_tttsstl _grad_output _self _target _p _margin _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_backward_tttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multi_margin_loss_backward_tttsst _grad_output _self _target _p _margin _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)));
  }|]

multi_margin_loss_backward_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
multi_margin_loss_backward_tttss _grad_output _self _target _p _margin =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)));
  }|]

multilabel_margin_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multilabel_margin_loss_out_tttl _out _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multilabel_margin_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multilabel_margin_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

multilabel_margin_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multilabel_margin_loss_ttl _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multilabel_margin_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multilabel_margin_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

multilabel_margin_loss_forward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
multilabel_margin_loss_forward_out_ttttl _output _is_target _self _target _reduction =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::multilabel_margin_loss_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _is_target)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multilabel_margin_loss_forward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
multilabel_margin_loss_forward_ttl _self _target _reduction =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::multilabel_margin_loss_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multilabel_margin_loss_backward_out_ttttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multilabel_margin_loss_backward_out_ttttlt _grad_input _grad_output _self _target _reduction _is_target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)
  , *$(at::Tensor* _is_target)));
  }|]

multilabel_margin_loss_backward_tttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multilabel_margin_loss_backward_tttlt _grad_output _self _target _reduction _is_target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)
  , *$(at::Tensor* _is_target)));
  }|]

nll_loss_out_ttttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
nll_loss_out_ttttll _out _self _target _weight _reduction _ignore_index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
nll_loss_out_ttttl _out _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

nll_loss_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_out_tttt _out _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

nll_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

nll_loss_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
nll_loss_tttll _self _target _weight _reduction _ignore_index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
nll_loss_tttl _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

nll_loss_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_ttt _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

nll_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

nll_loss_forward_out_tttttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
nll_loss_forward_out_tttttll _output _total_weight _self _target _weight _reduction _ignore_index =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::nll_loss_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _total_weight)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss_forward_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
nll_loss_forward_tttll _self _target _weight _reduction _ignore_index =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::nll_loss_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss_backward_out_tttttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_backward_out_tttttllt _grad_input _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

nll_loss_backward_ttttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_backward_ttttllt _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

nll_loss2d_out_ttttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
nll_loss2d_out_ttttll _out _self _target _weight _reduction _ignore_index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss2d_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
nll_loss2d_out_ttttl _out _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

nll_loss2d_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_out_tttt _out _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

nll_loss2d_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

nll_loss2d_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
nll_loss2d_tttll _self _target _weight _reduction _ignore_index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss2d_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
nll_loss2d_tttl _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

nll_loss2d_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_ttt _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

nll_loss2d_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

nll_loss2d_forward_out_tttttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
nll_loss2d_forward_out_tttttll _output _total_weight _self _target _weight _reduction _ignore_index =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::nll_loss2d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _total_weight)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss2d_forward_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
nll_loss2d_forward_tttll _self _target _weight _reduction _ignore_index =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::nll_loss2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss2d_backward_out_tttttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_backward_out_tttttllt _grad_input _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

nll_loss2d_backward_ttttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_backward_ttttllt _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

smooth_l1_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
smooth_l1_loss_out_tttl _out _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

smooth_l1_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
smooth_l1_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

smooth_l1_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
smooth_l1_loss_ttl _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

smooth_l1_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
smooth_l1_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

smooth_l1_loss_backward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
smooth_l1_loss_backward_out_ttttl _grad_input _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

smooth_l1_loss_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
smooth_l1_loss_backward_tttl _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

soft_margin_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
soft_margin_loss_out_tttl _out _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::soft_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

soft_margin_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
soft_margin_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::soft_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

soft_margin_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
soft_margin_loss_ttl _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::soft_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

soft_margin_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
soft_margin_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::soft_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

soft_margin_loss_backward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
soft_margin_loss_backward_out_ttttl _grad_input _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::soft_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

soft_margin_loss_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
soft_margin_loss_backward_tttl _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::soft_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

elu_out_ttsss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_out_ttsss _out _self _alpha _scale _input_scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)));
  }|]

elu_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_out_ttss _out _self _alpha _scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)));
  }|]

elu_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_out_tts _out _self _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

elu_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
elu_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

elu_tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_tsss _self _alpha _scale _input_scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)));
  }|]

elu_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_tss _self _alpha _scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)));
  }|]

elu_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_ts _self _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

elu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
elu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu(
    *$(at::Tensor* _self)));
  }|]

elu_backward_out_ttssst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
elu_backward_out_ttssst _grad_input _grad_output _alpha _scale _input_scale _output =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)
  , *$(at::Tensor* _output)));
  }|]

elu_backward_tssst
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
elu_backward_tssst _grad_output _alpha _scale _input_scale _output =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)
  , *$(at::Tensor* _output)));
  }|]

elu__tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu__tsss _self _alpha _scale _input_scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)));
  }|]

elu__tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu__tss _self _alpha _scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)));
  }|]

elu__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu__ts _self _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

elu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
elu__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_(
    *$(at::Tensor* _self)));
  }|]

glu_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
glu_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::glu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

glu_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
glu_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::glu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

glu_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
glu_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::glu(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

glu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
glu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::glu(
    *$(at::Tensor* _self)));
  }|]

glu_backward_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
glu_backward_out_tttl _grad_input _grad_output _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::glu_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

glu_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
glu_backward_ttl _grad_output _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::glu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

hardsigmoid_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hardsigmoid_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardsigmoid_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

hardsigmoid_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
hardsigmoid_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardsigmoid(
    *$(at::Tensor* _self)));
  }|]

hardsigmoid__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
hardsigmoid__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardsigmoid_(
    *$(at::Tensor* _self)));
  }|]

hardsigmoid_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hardsigmoid_backward_tt _grad_output _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardsigmoid_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

hardtanh_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_out_ttss _out _self _min_val _max_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_out_tts _out _self _min_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)));
  }|]

hardtanh_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hardtanh_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

hardtanh_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_tss _self _min_val _max_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_ts _self _min_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)));
  }|]

hardtanh_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
hardtanh_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh(
    *$(at::Tensor* _self)));
  }|]

hardtanh_backward_out_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_backward_out_tttss _grad_input _grad_output _self _min_val _max_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh_backward_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_backward_ttss _grad_output _self _min_val _max_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh__tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh__tss _self _min_val _max_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh__ts _self _min_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)));
  }|]

hardtanh__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
hardtanh__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_(
    *$(at::Tensor* _self)));
  }|]

leaky_relu_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu_out_tts _out _self _negative_slope =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
leaky_relu_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

leaky_relu_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu_ts _self _negative_slope =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
leaky_relu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu(
    *$(at::Tensor* _self)));
  }|]

leaky_relu_backward_ttsb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
leaky_relu_backward_ttsb _grad_output _self _negative_slope _self_is_result =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)
  , $(bool _self_is_result)));
  }|]

leaky_relu__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu__ts _self _negative_slope =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
leaky_relu__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu_(
    *$(at::Tensor* _self)));
  }|]

log_sigmoid_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_sigmoid_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

log_sigmoid_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_sigmoid(
    *$(at::Tensor* _self)));
  }|]

log_sigmoid_forward_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
log_sigmoid_forward_out_ttt _output _buffer _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::log_sigmoid_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _buffer)
  , *$(at::Tensor* _self)));
  }|]

log_sigmoid_forward_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
log_sigmoid_forward_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::log_sigmoid_forward(
    *$(at::Tensor* _self)));
  }|]

log_sigmoid_backward_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_backward_out_tttt _grad_input _grad_output _self _buffer =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_sigmoid_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _buffer)));
  }|]

log_sigmoid_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_backward_ttt _grad_output _self _buffer =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_sigmoid_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _buffer)));
  }|]

rrelu_with_noise_out_tttssbp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_with_noise_out_tttssbp _out _self _noise _lower _upper _training _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

rrelu_with_noise_out_tttssb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu_with_noise_out_tttssb _out _self _noise _lower _upper _training =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu_with_noise_out_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_with_noise_out_tttss _out _self _noise _lower _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)));
  }|]

rrelu_with_noise_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_with_noise_out_ttts _out _self _noise _lower =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)));
  }|]

rrelu_with_noise_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rrelu_with_noise_out_ttt _out _self _noise =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)));
  }|]

rrelu_with_noise_ttssbp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_with_noise_ttssbp _self _noise _lower _upper _training _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

rrelu_with_noise_ttssb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu_with_noise_ttssb _self _noise _lower _upper _training =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu_with_noise_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_with_noise_ttss _self _noise _lower _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)));
  }|]

rrelu_with_noise_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_with_noise_tts _self _noise _lower =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)));
  }|]

rrelu_with_noise_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rrelu_with_noise_tt _self _noise =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)));
  }|]

rrelu_with_noise_backward_tttssbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
rrelu_with_noise_backward_tttssbb _grad_output _self _noise _lower _upper _training _self_is_result =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(bool _self_is_result)));
  }|]

rrelu_with_noise__ttssbp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_with_noise__ttssbp _self _noise _lower _upper _training _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

rrelu_with_noise__ttssb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu_with_noise__ttssb _self _noise _lower _upper _training =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu_with_noise__ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_with_noise__ttss _self _noise _lower _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)));
  }|]

rrelu_with_noise__tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_with_noise__tts _self _noise _lower =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)));
  }|]

rrelu_with_noise__tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rrelu_with_noise__tt _self _noise =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)));
  }|]

softplus_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softplus_out_ttss _out _self _beta _threshold =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)));
  }|]

softplus_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softplus_out_tts _out _self _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)));
  }|]

softplus_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
softplus_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

softplus_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softplus_tss _self _beta _threshold =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)));
  }|]

softplus_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softplus_ts _self _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)));
  }|]

softplus_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
softplus_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus(
    *$(at::Tensor* _self)));
  }|]

softplus_backward_out_tttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
softplus_backward_out_tttsst _grad_input _grad_output _self _beta _threshold _output =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)
  , *$(at::Tensor* _output)));
  }|]

softplus_backward_ttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
softplus_backward_ttsst _grad_output _self _beta _threshold _output =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)
  , *$(at::Tensor* _output)));
  }|]

softshrink_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_out_tts _out _self _lambd =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softshrink_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

softshrink_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
softshrink_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softshrink_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

softshrink_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_ts _self _lambd =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softshrink(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

softshrink_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
softshrink_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softshrink(
    *$(at::Tensor* _self)));
  }|]

softshrink_backward_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_backward_out_ttts _grad_input _grad_output _self _lambd =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softshrink_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

softshrink_backward_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_backward_tts _grad_output _self _lambd =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softshrink_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

adaptive_avg_pool2d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool2d_out_ttl _out _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_avg_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool2d_tl _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

mkldnn_adaptive_avg_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mkldnn_adaptive_avg_pool2d_tl _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_adaptive_avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

_adaptive_avg_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_adaptive_avg_pool2d_tl _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_adaptive_avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

_adaptive_avg_pool2d_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_adaptive_avg_pool2d_backward_tt _grad_output _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_adaptive_avg_pool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

adaptive_avg_pool3d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_out_ttl _out _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_avg_pool3d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_tl _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_avg_pool3d_backward_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_backward_out_ttt _grad_input _grad_output _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

adaptive_avg_pool3d_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_backward_tt _grad_output _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

adaptive_max_pool2d_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
adaptive_max_pool2d_out_tttl _out _indices _self _output_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
adaptive_max_pool2d_tl _self _output_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool2d_backward_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool2d_backward_out_tttt _grad_input _grad_output _self _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_max_pool2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

adaptive_max_pool2d_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool2d_backward_ttt _grad_output _self _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_max_pool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

adaptive_max_pool3d_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
adaptive_max_pool3d_out_tttl _out _indices _self _output_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool3d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
adaptive_max_pool3d_tl _self _output_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool3d_backward_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool3d_backward_out_tttt _grad_input _grad_output _self _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_max_pool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

adaptive_max_pool3d_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool3d_backward_ttt _grad_output _self _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_max_pool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

avg_pool2d_out_ttlllbbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> Int64
  -> IO (Ptr Tensor)
avg_pool2d_out_ttlllbbl _out _self _kernel_size _stride _padding _ceil_mode _count_include_pad _divisor_override =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)
  , $(int64_t _divisor_override)));
  }|]

avg_pool2d_out_ttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool2d_out_ttlllbb _out _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool2d_out_ttlllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
avg_pool2d_out_ttlllb _out _self _kernel_size _stride _padding _ceil_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)));
  }|]

avg_pool2d_out_ttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool2d_out_ttlll _out _self _kernel_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

avg_pool2d_out_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool2d_out_ttll _out _self _kernel_size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

avg_pool2d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool2d_out_ttl _out _self _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

avg_pool2d_tlllbbl
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> Int64
  -> IO (Ptr Tensor)
avg_pool2d_tlllbbl _self _kernel_size _stride _padding _ceil_mode _count_include_pad _divisor_override =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)
  , $(int64_t _divisor_override)));
  }|]

avg_pool2d_tlllbb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool2d_tlllbb _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool2d_tlllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
avg_pool2d_tlllb _self _kernel_size _stride _padding _ceil_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)));
  }|]

avg_pool2d_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool2d_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

avg_pool2d_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool2d_tll _self _kernel_size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

avg_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool2d_tl _self _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

avg_pool2d_backward_out_tttlllbbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> Int64
  -> IO (Ptr Tensor)
avg_pool2d_backward_out_tttlllbbl _grad_input _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad _divisor_override =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)
  , $(int64_t _divisor_override)));
  }|]

avg_pool2d_backward_ttlllbbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> Int64
  -> IO (Ptr Tensor)
avg_pool2d_backward_ttlllbbl _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad _divisor_override =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)
  , $(int64_t _divisor_override)));
  }|]

avg_pool3d_out_ttlllbbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> Int64
  -> IO (Ptr Tensor)
avg_pool3d_out_ttlllbbl _out _self _kernel_size _stride _padding _ceil_mode _count_include_pad _divisor_override =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)
  , $(int64_t _divisor_override)));
  }|]

avg_pool3d_out_ttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool3d_out_ttlllbb _out _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool3d_out_ttlllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
avg_pool3d_out_ttlllb _out _self _kernel_size _stride _padding _ceil_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)));
  }|]

avg_pool3d_out_ttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool3d_out_ttlll _out _self _kernel_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

avg_pool3d_out_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool3d_out_ttll _out _self _kernel_size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

avg_pool3d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool3d_out_ttl _out _self _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

avg_pool3d_tlllbbl
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> Int64
  -> IO (Ptr Tensor)
avg_pool3d_tlllbbl _self _kernel_size _stride _padding _ceil_mode _count_include_pad _divisor_override =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)
  , $(int64_t _divisor_override)));
  }|]

avg_pool3d_tlllbb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool3d_tlllbb _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool3d_tlllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
avg_pool3d_tlllb _self _kernel_size _stride _padding _ceil_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)));
  }|]

avg_pool3d_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool3d_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

avg_pool3d_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool3d_tll _self _kernel_size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

avg_pool3d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool3d_tl _self _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

avg_pool3d_backward_out_tttlllbbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> Int64
  -> IO (Ptr Tensor)
avg_pool3d_backward_out_tttlllbbl _grad_input _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad _divisor_override =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)
  , $(int64_t _divisor_override)));
  }|]

avg_pool3d_backward_ttlllbbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> Int64
  -> IO (Ptr Tensor)
avg_pool3d_backward_ttlllbbl _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad _divisor_override =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)
  , $(int64_t _divisor_override)));
  }|]

fractional_max_pool2d_out_tttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
fractional_max_pool2d_out_tttllt _output _indices _self _kernel_size _output_size _random_samples =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::fractional_max_pool2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _random_samples)));
  }|]

fractional_max_pool2d_tllt
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
fractional_max_pool2d_tllt _self _kernel_size _output_size _random_samples =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::fractional_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _random_samples)));
  }|]

fractional_max_pool2d_backward_out_tttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fractional_max_pool2d_backward_out_tttllt _grad_input _grad_output _self _kernel_size _output_size _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fractional_max_pool2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _indices)));
  }|]

fractional_max_pool2d_backward_ttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fractional_max_pool2d_backward_ttllt _grad_output _self _kernel_size _output_size _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fractional_max_pool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _indices)));
  }|]

fractional_max_pool3d_out_tttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
fractional_max_pool3d_out_tttllt _output _indices _self _kernel_size _output_size _random_samples =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::fractional_max_pool3d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _random_samples)));
  }|]

fractional_max_pool3d_tllt
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
fractional_max_pool3d_tllt _self _kernel_size _output_size _random_samples =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::fractional_max_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _random_samples)));
  }|]

fractional_max_pool3d_backward_out_tttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fractional_max_pool3d_backward_out_tttllt _grad_input _grad_output _self _kernel_size _output_size _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fractional_max_pool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _indices)));
  }|]

fractional_max_pool3d_backward_ttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fractional_max_pool3d_backward_ttllt _grad_output _self _kernel_size _output_size _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fractional_max_pool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _indices)));
  }|]

max_pool2d_with_indices_out_tttllllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool2d_with_indices_out_tttllllb _out _indices _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool2d_with_indices_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool2d_with_indices_out_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool2d_with_indices_out_tttllll _out _indices _self _kernel_size _stride _padding _dilation =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool2d_with_indices_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

max_pool2d_with_indices_out_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool2d_with_indices_out_tttlll _out _indices _self _kernel_size _stride _padding =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool2d_with_indices_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_pool2d_with_indices_out_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool2d_with_indices_out_tttll _out _indices _self _kernel_size _stride =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool2d_with_indices_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

max_pool2d_with_indices_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool2d_with_indices_out_tttl _out _indices _self _kernel_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool2d_with_indices_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

max_pool2d_with_indices_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool2d_with_indices_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool2d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool2d_with_indices_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool2d_with_indices_tllll _self _kernel_size _stride _padding _dilation =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool2d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

max_pool2d_with_indices_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool2d_with_indices_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool2d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_pool2d_with_indices_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool2d_with_indices_tll _self _kernel_size _stride =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool2d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

max_pool2d_with_indices_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool2d_with_indices_tl _self _kernel_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool2d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

max_pool2d_with_indices_backward_out_tttllllbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_pool2d_with_indices_backward_out_tttllllbt _grad_input _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool2d_with_indices_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)
  , *$(at::Tensor* _indices)));
  }|]

max_pool2d_with_indices_backward_ttllllbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_pool2d_with_indices_backward_ttllllbt _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool2d_with_indices_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)
  , *$(at::Tensor* _indices)));
  }|]

max_pool3d_with_indices_out_tttllllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool3d_with_indices_out_tttllllb _out _indices _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool3d_with_indices_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool3d_with_indices_out_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool3d_with_indices_out_tttllll _out _indices _self _kernel_size _stride _padding _dilation =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool3d_with_indices_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

max_pool3d_with_indices_out_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool3d_with_indices_out_tttlll _out _indices _self _kernel_size _stride _padding =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool3d_with_indices_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_pool3d_with_indices_out_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool3d_with_indices_out_tttll _out _indices _self _kernel_size _stride =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool3d_with_indices_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

max_pool3d_with_indices_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool3d_with_indices_out_tttl _out _indices _self _kernel_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool3d_with_indices_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

max_pool3d_with_indices_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool3d_with_indices_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool3d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool3d_with_indices_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool3d_with_indices_tllll _self _kernel_size _stride _padding _dilation =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool3d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

max_pool3d_with_indices_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool3d_with_indices_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool3d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_pool3d_with_indices_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool3d_with_indices_tll _self _kernel_size _stride =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool3d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

max_pool3d_with_indices_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool3d_with_indices_tl _self _kernel_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool3d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

max_pool3d_with_indices_backward_out_tttllllbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_pool3d_with_indices_backward_out_tttllllbt _grad_input _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool3d_with_indices_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)
  , *$(at::Tensor* _indices)));
  }|]

max_pool3d_with_indices_backward_ttllllbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_pool3d_with_indices_backward_ttllllbt _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool3d_with_indices_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)
  , *$(at::Tensor* _indices)));
  }|]

max_unpool2d_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool2d_out_tttl _out _self _indices _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_unpool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

max_unpool2d_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool2d_ttl _self _indices _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_unpool2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

max_unpool2d_backward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool2d_backward_out_ttttl _grad_input _grad_output _self _indices _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_unpool2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

max_unpool2d_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool2d_backward_tttl _grad_output _self _indices _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_unpool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

max_unpool3d_out_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool3d_out_tttlll _out _self _indices _output_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_unpool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_unpool3d_ttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool3d_ttlll _self _indices _output_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_unpool3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_unpool3d_backward_out_ttttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool3d_backward_out_ttttlll _grad_input _grad_output _self _indices _output_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_unpool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_unpool3d_backward_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool3d_backward_tttlll _grad_output _self _indices _output_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_unpool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad1d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad1d_out_ttl _out _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reflection_pad1d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad1d_tl _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reflection_pad1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad1d_backward_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad1d_backward_out_tttl _grad_input _grad_output _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reflection_pad1d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad1d_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad1d_backward_ttl _grad_output _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reflection_pad1d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad2d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad2d_out_ttl _out _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reflection_pad2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad2d_tl _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reflection_pad2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad2d_backward_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad2d_backward_out_tttl _grad_input _grad_output _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reflection_pad2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad2d_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad2d_backward_ttl _grad_output _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reflection_pad2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad1d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad1d_out_ttl _out _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::replication_pad1d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad1d_tl _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::replication_pad1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad1d_backward_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad1d_backward_out_tttl _grad_input _grad_output _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::replication_pad1d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad1d_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad1d_backward_ttl _grad_output _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::replication_pad1d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad2d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad2d_out_ttl _out _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::replication_pad2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad2d_tl _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::replication_pad2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad2d_backward_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad2d_backward_out_tttl _grad_input _grad_output _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::replication_pad2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad2d_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad2d_backward_ttl _grad_output _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::replication_pad2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad3d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad3d_out_ttl _out _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::replication_pad3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad3d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad3d_tl _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::replication_pad3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad3d_backward_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad3d_backward_out_tttl _grad_input _grad_output _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::replication_pad3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad3d_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad3d_backward_ttl _grad_output _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::replication_pad3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

upsample_linear1d_out_ttlbd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_linear1d_out_ttlbd _out _self _output_size _align_corners _scales =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_linear1d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales)));
  }|]

upsample_linear1d_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_linear1d_out_ttlb _out _self _output_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_linear1d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_linear1d_tlbd
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_linear1d_tlbd _self _output_size _align_corners _scales =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_linear1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales)));
  }|]

upsample_linear1d_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_linear1d_tlb _self _output_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_linear1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_linear1d_backward_out_ttllbd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_linear1d_backward_out_ttllbd _grad_input _grad_output _output_size _input_size _align_corners _scales =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_linear1d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales)));
  }|]

upsample_linear1d_backward_out_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_linear1d_backward_out_ttllb _grad_input _grad_output _output_size _input_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_linear1d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_linear1d_backward_tllbd
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_linear1d_backward_tllbd _grad_output _output_size _input_size _align_corners _scales =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_linear1d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales)));
  }|]

upsample_linear1d_backward_tllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_linear1d_backward_tllb _grad_output _output_size _input_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_linear1d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_bilinear2d_out_ttlbdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bilinear2d_out_ttlbdd _out _self _output_size _align_corners _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_bilinear2d_out_ttlbd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bilinear2d_out_ttlbd _out _self _output_size _align_corners _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_h)));
  }|]

upsample_bilinear2d_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bilinear2d_out_ttlb _out _self _output_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_bilinear2d_tlbdd
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bilinear2d_tlbdd _self _output_size _align_corners _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_bilinear2d_tlbd
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bilinear2d_tlbd _self _output_size _align_corners _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_h)));
  }|]

upsample_bilinear2d_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bilinear2d_tlb _self _output_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_bilinear2d_backward_out_ttllbdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bilinear2d_backward_out_ttllbdd _grad_input _grad_output _output_size _input_size _align_corners _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_bilinear2d_backward_out_ttllbd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bilinear2d_backward_out_ttllbd _grad_input _grad_output _output_size _input_size _align_corners _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_h)));
  }|]

upsample_bilinear2d_backward_out_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bilinear2d_backward_out_ttllb _grad_input _grad_output _output_size _input_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_bilinear2d_backward_tllbdd
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bilinear2d_backward_tllbdd _grad_output _output_size _input_size _align_corners _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_bilinear2d_backward_tllbd
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bilinear2d_backward_tllbd _grad_output _output_size _input_size _align_corners _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_h)));
  }|]

upsample_bilinear2d_backward_tllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bilinear2d_backward_tllb _grad_output _output_size _input_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_bicubic2d_out_ttlbdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bicubic2d_out_ttlbdd _out _self _output_size _align_corners _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_bicubic2d_out_ttlbd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bicubic2d_out_ttlbd _out _self _output_size _align_corners _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_h)));
  }|]

upsample_bicubic2d_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bicubic2d_out_ttlb _out _self _output_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_bicubic2d_tlbdd
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bicubic2d_tlbdd _self _output_size _align_corners _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_bicubic2d_tlbd
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bicubic2d_tlbd _self _output_size _align_corners _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_h)));
  }|]

upsample_bicubic2d_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bicubic2d_tlb _self _output_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_bicubic2d_backward_out_ttllbdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bicubic2d_backward_out_ttllbdd _grad_input _grad_output _output_size _input_size _align_corners _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_bicubic2d_backward_out_ttllbd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bicubic2d_backward_out_ttllbd _grad_input _grad_output _output_size _input_size _align_corners _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_h)));
  }|]

upsample_bicubic2d_backward_out_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bicubic2d_backward_out_ttllb _grad_input _grad_output _output_size _input_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_bicubic2d_backward_tllbdd
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bicubic2d_backward_tllbdd _grad_output _output_size _input_size _align_corners _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_bicubic2d_backward_tllbd
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_bicubic2d_backward_tllbd _grad_output _output_size _input_size _align_corners _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_h)));
  }|]

upsample_bicubic2d_backward_tllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bicubic2d_backward_tllb _grad_output _output_size _input_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_trilinear3d_out_ttlbddd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_trilinear3d_out_ttlbddd _out _self _output_size _align_corners _scales_d _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_d)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_trilinear3d_out_ttlbdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_trilinear3d_out_ttlbdd _out _self _output_size _align_corners _scales_d _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_d)
  , $(double _scales_h)));
  }|]

upsample_trilinear3d_out_ttlbd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_trilinear3d_out_ttlbd _out _self _output_size _align_corners _scales_d =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_d)));
  }|]

upsample_trilinear3d_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_trilinear3d_out_ttlb _out _self _output_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_trilinear3d_tlbddd
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_trilinear3d_tlbddd _self _output_size _align_corners _scales_d _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_d)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_trilinear3d_tlbdd
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_trilinear3d_tlbdd _self _output_size _align_corners _scales_d _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_d)
  , $(double _scales_h)));
  }|]

upsample_trilinear3d_tlbd
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_trilinear3d_tlbd _self _output_size _align_corners _scales_d =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)
  , $(double _scales_d)));
  }|]

upsample_trilinear3d_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_trilinear3d_tlb _self _output_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_trilinear3d_backward_out_ttllbddd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_trilinear3d_backward_out_ttllbddd _grad_input _grad_output _output_size _input_size _align_corners _scales_d _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_d)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_trilinear3d_backward_out_ttllbdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_trilinear3d_backward_out_ttllbdd _grad_input _grad_output _output_size _input_size _align_corners _scales_d _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_d)
  , $(double _scales_h)));
  }|]

upsample_trilinear3d_backward_out_ttllbd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_trilinear3d_backward_out_ttllbd _grad_input _grad_output _output_size _input_size _align_corners _scales_d =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_d)));
  }|]

upsample_trilinear3d_backward_out_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_trilinear3d_backward_out_ttllb _grad_input _grad_output _output_size _input_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_trilinear3d_backward_tllbddd
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_trilinear3d_backward_tllbddd _grad_output _output_size _input_size _align_corners _scales_d _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_d)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_trilinear3d_backward_tllbdd
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_trilinear3d_backward_tllbdd _grad_output _output_size _input_size _align_corners _scales_d _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_d)
  , $(double _scales_h)));
  }|]

upsample_trilinear3d_backward_tllbd
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CDouble
  -> IO (Ptr Tensor)
upsample_trilinear3d_backward_tllbd _grad_output _output_size _input_size _align_corners _scales_d =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)
  , $(double _scales_d)));
  }|]

upsample_trilinear3d_backward_tllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_trilinear3d_backward_tllb _grad_output _output_size _input_size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_nearest1d_out_ttld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest1d_out_ttld _out _self _output_size _scales =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest1d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(double _scales)));
  }|]

upsample_nearest1d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest1d_out_ttl _out _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest1d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

upsample_nearest1d_tld
  :: Ptr Tensor
  -> Ptr IntArray
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest1d_tld _self _output_size _scales =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(double _scales)));
  }|]

upsample_nearest1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest1d_tl _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

upsample_nearest1d_backward_out_ttlld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest1d_backward_out_ttlld _grad_input _grad_output _output_size _input_size _scales =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest1d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(double _scales)));
  }|]

upsample_nearest1d_backward_out_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest1d_backward_out_ttll _grad_input _grad_output _output_size _input_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest1d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)));
  }|]

upsample_nearest1d_backward_tlld
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest1d_backward_tlld _grad_output _output_size _input_size _scales =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest1d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(double _scales)));
  }|]

upsample_nearest1d_backward_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest1d_backward_tll _grad_output _output_size _input_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest1d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)));
  }|]

upsample_nearest2d_out_ttldd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest2d_out_ttldd _out _self _output_size _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_nearest2d_out_ttld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest2d_out_ttld _out _self _output_size _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(double _scales_h)));
  }|]

upsample_nearest2d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest2d_out_ttl _out _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

upsample_nearest2d_tldd
  :: Ptr Tensor
  -> Ptr IntArray
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest2d_tldd _self _output_size _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_nearest2d_tld
  :: Ptr Tensor
  -> Ptr IntArray
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest2d_tld _self _output_size _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(double _scales_h)));
  }|]

upsample_nearest2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest2d_tl _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

upsample_nearest2d_backward_out_ttlldd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest2d_backward_out_ttlldd _grad_input _grad_output _output_size _input_size _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_nearest2d_backward_out_ttlld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest2d_backward_out_ttlld _grad_input _grad_output _output_size _input_size _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(double _scales_h)));
  }|]

upsample_nearest2d_backward_out_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest2d_backward_out_ttll _grad_input _grad_output _output_size _input_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)));
  }|]

upsample_nearest2d_backward_tlldd
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest2d_backward_tlldd _grad_output _output_size _input_size _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_nearest2d_backward_tlld
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest2d_backward_tlld _grad_output _output_size _input_size _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(double _scales_h)));
  }|]

upsample_nearest2d_backward_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest2d_backward_tll _grad_output _output_size _input_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)));
  }|]

upsample_nearest3d_out_ttlddd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CDouble
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest3d_out_ttlddd _out _self _output_size _scales_d _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(double _scales_d)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_nearest3d_out_ttldd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest3d_out_ttldd _out _self _output_size _scales_d _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(double _scales_d)
  , $(double _scales_h)));
  }|]

upsample_nearest3d_out_ttld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest3d_out_ttld _out _self _output_size _scales_d =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(double _scales_d)));
  }|]

upsample_nearest3d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest3d_out_ttl _out _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

upsample_nearest3d_tlddd
  :: Ptr Tensor
  -> Ptr IntArray
  -> CDouble
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest3d_tlddd _self _output_size _scales_d _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(double _scales_d)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_nearest3d_tldd
  :: Ptr Tensor
  -> Ptr IntArray
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest3d_tldd _self _output_size _scales_d _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(double _scales_d)
  , $(double _scales_h)));
  }|]

upsample_nearest3d_tld
  :: Ptr Tensor
  -> Ptr IntArray
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest3d_tld _self _output_size _scales_d =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(double _scales_d)));
  }|]

upsample_nearest3d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest3d_tl _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

upsample_nearest3d_backward_out_ttllddd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CDouble
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest3d_backward_out_ttllddd _grad_input _grad_output _output_size _input_size _scales_d _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(double _scales_d)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_nearest3d_backward_out_ttlldd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest3d_backward_out_ttlldd _grad_input _grad_output _output_size _input_size _scales_d _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(double _scales_d)
  , $(double _scales_h)));
  }|]

upsample_nearest3d_backward_out_ttlld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest3d_backward_out_ttlld _grad_input _grad_output _output_size _input_size _scales_d =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(double _scales_d)));
  }|]

upsample_nearest3d_backward_out_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest3d_backward_out_ttll _grad_input _grad_output _output_size _input_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)));
  }|]

upsample_nearest3d_backward_tllddd
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CDouble
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest3d_backward_tllddd _grad_output _output_size _input_size _scales_d _scales_h _scales_w =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(double _scales_d)
  , $(double _scales_h)
  , $(double _scales_w)));
  }|]

upsample_nearest3d_backward_tlldd
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest3d_backward_tlldd _grad_output _output_size _input_size _scales_d _scales_h =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(double _scales_d)
  , $(double _scales_h)));
  }|]

upsample_nearest3d_backward_tlld
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CDouble
  -> IO (Ptr Tensor)
upsample_nearest3d_backward_tlld _grad_output _output_size _input_size _scales_d =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(double _scales_d)));
  }|]

upsample_nearest3d_backward_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest3d_backward_tll _grad_output _output_size _input_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)));
  }|]

sigmoid_backward_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid_backward_out_ttt _grad_input _grad_output _output =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sigmoid_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)));
  }|]

sigmoid_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid_backward_tt _grad_output _output =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sigmoid_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)));
  }|]

tanh_backward_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
tanh_backward_out_ttt _grad_input _grad_output _output =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tanh_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)));
  }|]

tanh_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
tanh_backward_tt _grad_output _output =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::tanh_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)));
  }|]

slow_conv_transpose2d_out_tttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose2d_out_tttltllll _out _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

slow_conv_transpose2d_out_tttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose2d_out_tttltlll _out _self _weight _kernel_size _bias _stride _padding _output_padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)));
  }|]

slow_conv_transpose2d_out_tttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose2d_out_tttltll _out _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

slow_conv_transpose2d_out_tttltl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose2d_out_tttltl _out _self _weight _kernel_size _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

slow_conv_transpose2d_out_tttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
slow_conv_transpose2d_out_tttlt _out _self _weight _kernel_size _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)));
  }|]

slow_conv_transpose2d_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose2d_out_tttl _out _self _weight _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

slow_conv_transpose2d_ttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose2d_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

slow_conv_transpose2d_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose2d_ttltlll _self _weight _kernel_size _bias _stride _padding _output_padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)));
  }|]

slow_conv_transpose2d_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose2d_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

slow_conv_transpose2d_ttltl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose2d_ttltl _self _weight _kernel_size _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

slow_conv_transpose2d_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
slow_conv_transpose2d_ttlt _self _weight _kernel_size _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)));
  }|]

slow_conv_transpose2d_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose2d_ttl _self _weight _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

slow_conv_transpose2d_backward_out_ttttttllllltt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
slow_conv_transpose2d_backward_out_ttttttllllltt _grad_input _grad_weight _grad_bias _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _columns _ones =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::slow_conv_transpose2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)));
  }|]

slow_conv_transpose2d_backward_tttllllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
slow_conv_transpose2d_backward_tttllllltta _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _columns _ones _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::slow_conv_transpose2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

slow_conv_transpose3d_out_tttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose3d_out_tttltllll _out _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

slow_conv_transpose3d_out_tttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose3d_out_tttltlll _out _self _weight _kernel_size _bias _stride _padding _output_padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)));
  }|]

slow_conv_transpose3d_out_tttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose3d_out_tttltll _out _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

slow_conv_transpose3d_out_tttltl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose3d_out_tttltl _out _self _weight _kernel_size _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

slow_conv_transpose3d_out_tttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
slow_conv_transpose3d_out_tttlt _out _self _weight _kernel_size _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)));
  }|]

slow_conv_transpose3d_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose3d_out_tttl _out _self _weight _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

slow_conv_transpose3d_ttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose3d_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

slow_conv_transpose3d_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose3d_ttltlll _self _weight _kernel_size _bias _stride _padding _output_padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)));
  }|]

slow_conv_transpose3d_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose3d_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

slow_conv_transpose3d_ttltl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose3d_ttltl _self _weight _kernel_size _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

slow_conv_transpose3d_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
slow_conv_transpose3d_ttlt _self _weight _kernel_size _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)));
  }|]

slow_conv_transpose3d_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_transpose3d_ttl _self _weight _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_transpose3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

slow_conv_transpose3d_backward_out_ttttttllllltt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
slow_conv_transpose3d_backward_out_ttttttllllltt _grad_input _grad_weight _grad_bias _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _finput _fgrad_input =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::slow_conv_transpose3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)));
  }|]

slow_conv_transpose3d_backward_tttllllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
slow_conv_transpose3d_backward_tttllllltta _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _finput _fgrad_input _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::slow_conv_transpose3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_conv2d_out_tttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv2d_out_tttltll _out _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv2d_out_tttltl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv2d_out_tttltl _out _self _weight _kernel_size _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

thnn_conv2d_out_tttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
thnn_conv2d_out_tttlt _out _self _weight _kernel_size _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)));
  }|]

thnn_conv2d_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv2d_out_tttl _out _self _weight _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

thnn_conv2d_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv2d_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv2d_ttltl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv2d_ttltl _self _weight _kernel_size _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

thnn_conv2d_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
thnn_conv2d_ttlt _self _weight _kernel_size _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)));
  }|]

thnn_conv2d_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv2d_ttl _self _weight _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

thnn_conv2d_forward_out_tttttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
thnn_conv2d_forward_out_tttttltll _output _finput _fgrad_input _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv2d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv2d_forward_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
thnn_conv2d_forward_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv2d_backward_out_ttttttllltt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
thnn_conv2d_backward_out_ttttttllltt _grad_input _grad_weight _grad_bias _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)));
  }|]

thnn_conv2d_backward_tttllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
thnn_conv2d_backward_tttllltta _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_conv_depthwise2d_out_tttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_out_tttltlll _out _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_depthwise2d_out_tttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_out_tttltll _out _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv_depthwise2d_out_tttltl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_out_tttltl _out _self _weight _kernel_size _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

thnn_conv_depthwise2d_out_tttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_out_tttlt _out _self _weight _kernel_size _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)));
  }|]

thnn_conv_depthwise2d_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_out_tttl _out _self _weight _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

thnn_conv_depthwise2d_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_depthwise2d_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv_depthwise2d_ttltl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_ttltl _self _weight _kernel_size _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

thnn_conv_depthwise2d_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_ttlt _self _weight _kernel_size _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)));
  }|]

thnn_conv_depthwise2d_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_ttl _self _weight _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

thnn_conv_depthwise2d_forward_out_tttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_forward_out_tttltlll _out _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d_forward_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_depthwise2d_forward_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_forward_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_depthwise2d_backward_out_tttttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
thnn_conv_depthwise2d_backward_out_tttttllll _grad_input _grad_weight _grad_output _self _weight _kernel_size _stride _padding _dilation =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::thnn_conv_depthwise2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_depthwise2d_backward_tttlllla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr (StdArray '(CBool,2))
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
thnn_conv_depthwise2d_backward_tttlllla _grad_output _self _weight _kernel_size _stride _padding _dilation _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::thnn_conv_depthwise2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::array<bool,2>* _output_mask)));
  }|]

slow_conv3d_out_tttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv3d_out_tttltll _out _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

slow_conv3d_out_tttltl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv3d_out_tttltl _out _self _weight _kernel_size _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

slow_conv3d_out_tttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
slow_conv3d_out_tttlt _out _self _weight _kernel_size _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)));
  }|]

slow_conv3d_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv3d_out_tttl _out _self _weight _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

slow_conv3d_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv3d_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

slow_conv3d_ttltl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv3d_ttltl _self _weight _kernel_size _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

slow_conv3d_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
slow_conv3d_ttlt _self _weight _kernel_size _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)));
  }|]

slow_conv3d_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv3d_ttl _self _weight _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

slow_conv3d_forward_out_tttttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
slow_conv3d_forward_out_tttttltll _output _finput _fgrad_input _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::slow_conv3d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

slow_conv3d_forward_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
slow_conv3d_forward_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::slow_conv3d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

slow_conv3d_backward_out_ttttttllltt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
slow_conv3d_backward_out_ttttttllltt _grad_input _grad_weight _grad_bias _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::slow_conv3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)));
  }|]

slow_conv3d_backward_tttllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
slow_conv3d_backward_tttllltta _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::slow_conv3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

slow_conv_dilated2d_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_dilated2d_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_dilated2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

slow_conv_dilated2d_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_dilated2d_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_dilated2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

slow_conv_dilated2d_ttltl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_dilated2d_ttltl _self _weight _kernel_size _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_dilated2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

slow_conv_dilated2d_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
slow_conv_dilated2d_ttlt _self _weight _kernel_size _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_dilated2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)));
  }|]

slow_conv_dilated2d_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_dilated2d_ttl _self _weight _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_dilated2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

slow_conv_dilated2d_backward_tttlllla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
slow_conv_dilated2d_backward_tttlllla _grad_output _self _weight _kernel_size _stride _padding _dilation _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::slow_conv_dilated2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

slow_conv_dilated3d_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_dilated3d_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_dilated3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

slow_conv_dilated3d_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_dilated3d_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_dilated3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

slow_conv_dilated3d_ttltl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_dilated3d_ttltl _self _weight _kernel_size _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_dilated3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

slow_conv_dilated3d_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
slow_conv_dilated3d_ttlt _self _weight _kernel_size _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_dilated3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)));
  }|]

slow_conv_dilated3d_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
slow_conv_dilated3d_ttl _self _weight _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::slow_conv_dilated3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

slow_conv_dilated3d_backward_tttlllla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
slow_conv_dilated3d_backward_tttlllla _grad_output _self _weight _kernel_size _stride _padding _dilation _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::slow_conv_dilated3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

col2im_out_ttlllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
col2im_out_ttlllll _out _self _output_size _kernel_size _dilation _padding _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::col2im_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

col2im_tlllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
col2im_tlllll _self _output_size _kernel_size _dilation _padding _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::col2im(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

col2im_backward_out_ttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
col2im_backward_out_ttllll _grad_input _grad_output _kernel_size _dilation _padding _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::col2im_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

col2im_backward_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
col2im_backward_tllll _grad_output _kernel_size _dilation _padding _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::col2im_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

im2col_out_ttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
im2col_out_ttllll _out _self _kernel_size _dilation _padding _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::im2col_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

im2col_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
im2col_tllll _self _kernel_size _dilation _padding _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::im2col(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

im2col_backward_out_ttlllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
im2col_backward_out_ttlllll _grad_input _grad_output _input_size _kernel_size _dilation _padding _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::im2col_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _input_size)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

im2col_backward_tlllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
im2col_backward_tlllll _grad_output _input_size _kernel_size _dilation _padding _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::im2col_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _input_size)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

isfinite_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
isfinite_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::isfinite(
    *$(at::Tensor* _self)));
  }|]

isinf_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
isinf_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::isinf(
    *$(at::Tensor* _self)));
  }|]

