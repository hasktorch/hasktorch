
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Torch.Internal.Unmanaged.Native.Native6 where


import Foreign.C.String
import Foreign.C.Types
import Foreign
import Torch.Internal.Type


import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<vector>"
C.include "<ATen/Tensor.h>"
C.include "<ATen/Functions.h>"

pdist_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
pdist_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pdist(
    *$(at::Tensor* _self)));
  }|]

_pdist_forward_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
_pdist_forward_td _self _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_pdist_forward(
    *$(at::Tensor* _self)
  , $(double _p)));
  }|]

_pdist_forward_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_pdist_forward_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_pdist_forward(
    *$(at::Tensor* _self)));
  }|]

_pdist_backward_ttdt
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_pdist_backward_ttdt _grad _self _p _pdist =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_pdist_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _self)
  , $(double _p)
  , *$(at::Tensor* _pdist)));
  }|]

cosine_similarity_ttld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CDouble
  -> IO (Ptr Tensor)
cosine_similarity_ttld _x1 _x2 _dim _eps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cosine_similarity(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(int64_t _dim)
  , $(double _eps)));
  }|]

cosine_similarity_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cosine_similarity_ttl _x1 _x2 _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cosine_similarity(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(int64_t _dim)));
  }|]

cosine_similarity_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cosine_similarity_tt _x1 _x2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cosine_similarity(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)));
  }|]

pixel_shuffle_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
pixel_shuffle_tl _self _upscale_factor =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pixel_shuffle(
    *$(at::Tensor* _self)
  , $(int64_t _upscale_factor)));
  }|]

pinverse_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
pinverse_td _self _rcond =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pinverse(
    *$(at::Tensor* _self)
  , $(double _rcond)));
  }|]

pinverse_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
pinverse_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pinverse(
    *$(at::Tensor* _self)));
  }|]

poisson_nll_loss_ttbbdl
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
poisson_nll_loss_ttbbdl _input _target _log_input _full _eps _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::poisson_nll_loss(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _target)
  , $(bool _log_input)
  , $(bool _full)
  , $(double _eps)
  , $(int64_t _reduction)));
  }|]

scalar_tensor_so
  :: Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
scalar_tensor_so _s _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::scalar_tensor(
    *$(at::Scalar* _s)
  , *$(at::TensorOptions* _options)));
  }|]

scalar_tensor_s
  :: Ptr Scalar
  -> IO (Ptr Tensor)
scalar_tensor_s _s =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::scalar_tensor(
    *$(at::Scalar* _s)));
  }|]

rand_lNo
  :: Ptr IntArray
  -> Ptr DimnameList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lNo _size _names _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)
  , *$(at::TensorOptions* _options)));
  }|]

rand_lN
  :: Ptr IntArray
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
rand_lN _size _names =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)));
  }|]

rand_lpNo
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr DimnameList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lpNo _size _generator _names _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(std::vector<at::Dimname>* _names)
  , *$(at::TensorOptions* _options)));
  }|]

rand_lpN
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
rand_lpN _size _generator _names =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(std::vector<at::Dimname>* _names)));
  }|]

rand_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

rand_l
  :: Ptr IntArray
  -> IO (Ptr Tensor)
rand_l _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)));
  }|]

rand_lpo
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lpo _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

rand_lp
  :: Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
rand_lp _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

rand_out_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
rand_out_tl _out _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)));
  }|]

rand_out_tlp
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
rand_out_tlp _out _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

rand_like_toM
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
rand_like_toM _self _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

rand_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_like_to _self _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

rand_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rand_like_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rand_like(
    *$(at::Tensor* _self)));
  }|]

randint_llo
  :: Int64
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_llo _high _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randint_ll
  :: Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
randint_ll _high _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _high)
  , *$(std::vector<int64_t>* _size)));
  }|]

randint_llpo
  :: Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_llpo _high _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randint_llp
  :: Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randint_llp _high _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randint_lllo
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_lllo _low _high _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randint_lll
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
randint_lll _low _high _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)));
  }|]

randint_lllpo
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_lllpo _low _high _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randint_lllp
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randint_lllp _low _high _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randint_out_tll
  :: Ptr Tensor
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
randint_out_tll _out _high _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_out(
    *$(at::Tensor* _out)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)));
  }|]

randint_out_tllp
  :: Ptr Tensor
  -> Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randint_out_tllp _out _high _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_out(
    *$(at::Tensor* _out)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randint_out_tlll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
randint_out_tlll _out _low _high _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_out(
    *$(at::Tensor* _out)
  , $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)));
  }|]

randint_out_tlllp
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randint_out_tlllp _out _low _high _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_out(
    *$(at::Tensor* _out)
  , $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randint_like_tloM
  :: Ptr Tensor
  -> Int64
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
randint_like_tloM _self _high _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _high)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

randint_like_tlo
  :: Ptr Tensor
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_like_tlo _self _high _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _high)
  , *$(at::TensorOptions* _options)));
  }|]

randint_like_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
randint_like_tl _self _high =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _high)));
  }|]

randint_like_tlloM
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
randint_like_tlloM _self _low _high _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _low)
  , $(int64_t _high)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

randint_like_tllo
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_like_tllo _self _low _high _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _low)
  , $(int64_t _high)
  , *$(at::TensorOptions* _options)));
  }|]

randint_like_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
randint_like_tll _self _low _high =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _low)
  , $(int64_t _high)));
  }|]

randn_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randn_l
  :: Ptr IntArray
  -> IO (Ptr Tensor)
randn_l _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)));
  }|]

randn_lpo
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lpo _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randn_lp
  :: Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randn_lp _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randn_lNo
  :: Ptr IntArray
  -> Ptr DimnameList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lNo _size _names _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)
  , *$(at::TensorOptions* _options)));
  }|]

randn_lN
  :: Ptr IntArray
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
randn_lN _size _names =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<at::Dimname>* _names)));
  }|]

randn_lpNo
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr DimnameList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lpNo _size _generator _names _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(std::vector<at::Dimname>* _names)
  , *$(at::TensorOptions* _options)));
  }|]

randn_lpN
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
randn_lpN _size _generator _names =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(std::vector<at::Dimname>* _names)));
  }|]

randn_out_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
randn_out_tl _out _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)));
  }|]

randn_out_tlp
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randn_out_tlp _out _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randn_like_toM
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> MemoryFormat
  -> IO (Ptr Tensor)
randn_like_toM _self _options _memory_format =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)
  , $(at::MemoryFormat _memory_format)));
  }|]

randn_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_like_to _self _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

randn_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
randn_like_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randn_like(
    *$(at::Tensor* _self)));
  }|]

randperm_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randperm_lo _n _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randperm(
    $(int64_t _n)
  , *$(at::TensorOptions* _options)));
  }|]

randperm_l
  :: Int64
  -> IO (Ptr Tensor)
randperm_l _n =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randperm(
    $(int64_t _n)));
  }|]

randperm_lpo
  :: Int64
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randperm_lpo _n _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randperm(
    $(int64_t _n)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randperm_lp
  :: Int64
  -> Ptr Generator
  -> IO (Ptr Tensor)
randperm_lp _n _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randperm(
    $(int64_t _n)
  , $(at::Generator * _generator)));
  }|]

randperm_out_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
randperm_out_tl _out _n =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randperm_out(
    *$(at::Tensor* _out)
  , $(int64_t _n)));
  }|]

randperm_out_tlp
  :: Ptr Tensor
  -> Int64
  -> Ptr Generator
  -> IO (Ptr Tensor)
randperm_out_tlp _out _n _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::randperm_out(
    *$(at::Tensor* _out)
  , $(int64_t _n)
  , $(at::Generator * _generator)));
  }|]

range_ssso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
range_ssso _start _end _step _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::range(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)
  , *$(at::TensorOptions* _options)));
  }|]

range_sss
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
range_sss _start _end _step =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::range(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)));
  }|]

-- range_ss
--   :: Ptr Scalar
--   -> Ptr Scalar
--   -> IO (Ptr Tensor)
-- range_ss _start _end =
--   [C.throwBlock| at::Tensor* { return new at::Tensor(at::range(
--     *$(at::Scalar* _start)
--   , *$(at::Scalar* _end)));
--   }|]

-- range_sso
--   :: Ptr Scalar
--   -> Ptr Scalar
--   -> Ptr TensorOptions
--   -> IO (Ptr Tensor)
-- range_sso _start _end _options =
--   [C.throwBlock| at::Tensor* { return new at::Tensor(at::range(
--     *$(at::Scalar* _start)
--   , *$(at::Scalar* _end)
--   , *$(at::TensorOptions* _options)));
--   }|]

range_out_tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
range_out_tsss _out _start _end _step =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::range_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)));
  }|]

range_out_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
range_out_tss _out _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::range_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

reciprocal_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
reciprocal_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reciprocal(
    *$(at::Tensor* _self)));
  }|]

reciprocal__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
reciprocal__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reciprocal_(
    *$(at::Tensor* _self)));
  }|]

reciprocal_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
reciprocal_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reciprocal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

neg_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
neg_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::neg(
    *$(at::Tensor* _self)));
  }|]

neg__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
neg__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::neg_(
    *$(at::Tensor* _self)));
  }|]

neg_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
neg_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::neg_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

repeat_interleave_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
repeat_interleave_t _repeats =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::repeat_interleave(
    *$(at::Tensor* _repeats)));
  }|]

repeat_interleave_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
repeat_interleave_ttl _self _repeats _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::repeat_interleave(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _repeats)
  , $(int64_t _dim)));
  }|]

repeat_interleave_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
repeat_interleave_tt _self _repeats =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::repeat_interleave(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _repeats)));
  }|]

repeat_interleave_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
repeat_interleave_tll _self _repeats _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::repeat_interleave(
    *$(at::Tensor* _self)
  , $(int64_t _repeats)
  , $(int64_t _dim)));
  }|]

repeat_interleave_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
repeat_interleave_tl _self _repeats =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::repeat_interleave(
    *$(at::Tensor* _self)
  , $(int64_t _repeats)));
  }|]

reshape_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reshape_tl _self _shape =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::reshape(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _shape)));
  }|]

_mkldnn_reshape_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_mkldnn_reshape_tl _self _shape =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_mkldnn_reshape(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _shape)));
  }|]

round_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
round_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::round(
    *$(at::Tensor* _self)));
  }|]

round__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
round__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::round_(
    *$(at::Tensor* _self)));
  }|]

round_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
round_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::round_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

rrelu_tssbp
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_tssbp _self _lower _upper _training _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

rrelu_tssb
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu_tssb _self _lower _upper _training =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_tss _self _lower _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)));
  }|]

rrelu_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_ts _self _lower =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)));
  }|]

rrelu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rrelu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu(
    *$(at::Tensor* _self)));
  }|]

rrelu__tssbp
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu__tssbp _self _lower _upper _training _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

rrelu__tssb
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu__tssb _self _lower _upper _training =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu__tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu__tss _self _lower _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)));
  }|]

rrelu__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu__ts _self _lower =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)));
  }|]

rrelu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rrelu__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_(
    *$(at::Tensor* _self)));
  }|]

relu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
relu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::relu(
    *$(at::Tensor* _self)));
  }|]

relu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
relu__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::relu_(
    *$(at::Tensor* _self)));
  }|]

prelu_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
prelu_tt _self _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::prelu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)));
  }|]

prelu_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
prelu_backward_ttt _grad_output _self _weight =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::prelu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)));
  }|]

gelu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
gelu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gelu(
    *$(at::Tensor* _self)));
  }|]

gelu_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gelu_backward_tt _grad _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gelu_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _self)));
  }|]

hardshrink_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardshrink_ts _self _lambd =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardshrink(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

hardshrink_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
hardshrink_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardshrink(
    *$(at::Tensor* _self)));
  }|]

hardshrink_backward_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardshrink_backward_tts _grad_out _self _lambd =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardshrink_backward(
    *$(at::Tensor* _grad_out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

rsqrt_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rsqrt_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsqrt(
    *$(at::Tensor* _self)));
  }|]

rsqrt__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rsqrt__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsqrt_(
    *$(at::Tensor* _self)));
  }|]

rsqrt_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rsqrt_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsqrt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

select_tnl
  :: Ptr Tensor
  -> Ptr Dimname
  -> Int64
  -> IO (Ptr Tensor)
select_tnl _self _dim _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::select(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(int64_t _index)));
  }|]

select_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
select_tll _self _dim _index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::select(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(int64_t _index)));
  }|]

selu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
selu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::selu(
    *$(at::Tensor* _self)));
  }|]

selu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
selu__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::selu_(
    *$(at::Tensor* _self)));
  }|]

celu_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
celu_ts _self _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::celu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

celu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
celu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::celu(
    *$(at::Tensor* _self)));
  }|]

celu__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
celu__ts _self _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::celu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

celu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
celu__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::celu_(
    *$(at::Tensor* _self)));
  }|]

sigmoid_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sigmoid(
    *$(at::Tensor* _self)));
  }|]

sigmoid__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sigmoid_(
    *$(at::Tensor* _self)));
  }|]

sigmoid_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sigmoid_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

sin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sin_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sin(
    *$(at::Tensor* _self)));
  }|]

sin__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sin__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sin_(
    *$(at::Tensor* _self)));
  }|]

sin_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sin_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sin_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

sinh_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sinh_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sinh(
    *$(at::Tensor* _self)));
  }|]

sinh__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sinh__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sinh_(
    *$(at::Tensor* _self)));
  }|]

sinh_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sinh_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sinh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

detach_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
detach_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::detach(
    *$(at::Tensor* _self)));
  }|]

detach__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
detach__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::detach_(
    *$(at::Tensor* _self)));
  }|]

size_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Int64)
size_tl _self _dim =
  [C.throwBlock| int64_t { return (at::size(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]
