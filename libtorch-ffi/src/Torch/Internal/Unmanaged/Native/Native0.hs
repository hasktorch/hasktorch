
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Torch.Internal.Unmanaged.Native.Native0 where


import Foreign.C.String
import Foreign.C.Types
import Foreign
import Torch.Internal.Type

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<vector>"
C.include "<ATen/Tensor.h>"
C.include "<ATen/Functions.h>"


_cast_Byte_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Byte_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Byte(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Byte_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Byte_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Byte(
    *$(at::Tensor* _self)));
  }|]

_cast_Char_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Char_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Char(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Char_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Char_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Char(
    *$(at::Tensor* _self)));
  }|]

_cast_Double_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Double_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Double(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Double_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Double_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Double(
    *$(at::Tensor* _self)));
  }|]

_cast_Float_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Float_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Float(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Float_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Float_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Float(
    *$(at::Tensor* _self)));
  }|]

_cast_Int_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Int_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Int(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Int_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Int_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Int(
    *$(at::Tensor* _self)));
  }|]

_cast_Long_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Long_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Long(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Long_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Long_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Long(
    *$(at::Tensor* _self)));
  }|]

_cast_Short_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Short_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Short(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Short_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Short_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Short(
    *$(at::Tensor* _self)));
  }|]

_cast_Half_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Half_tb _self _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Half(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Half_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cast_Half_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cast_Half(
    *$(at::Tensor* _self)));
  }|]

align_tensors_l
  :: Ptr TensorList
  -> IO (Ptr TensorList)
align_tensors_l _tensors =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::align_tensors(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

_use_cudnn_ctc_loss_ttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (CBool)
_use_cudnn_ctc_loss_ttlll _log_probs _targets _input_lengths _target_lengths _blank =
  [C.throwBlock| bool { return (at::_use_cudnn_ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , $(int64_t _blank)));
  }|]

_cudnn_ctc_loss_ttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_cudnn_ctc_loss_ttlllbb _log_probs _targets _input_lengths _target_lengths _blank _deterministic _zero_infinity =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_cudnn_ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , $(int64_t _blank)
  , $(bool _deterministic)
  , $(bool _zero_infinity)));
  }|]

_cudnn_rnn_flatten_weight_llllllbb
  :: Ptr TensorList
  -> Int64
  -> Int64
  -> Int64
  -> Int64
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
_cudnn_rnn_flatten_weight_llllllbb _weight_arr _weight_stride0 _input_size _mode _hidden_size _num_layers _batch_first _bidirectional =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cudnn_rnn_flatten_weight(
    *$(std::vector<at::Tensor>* _weight_arr)
  , $(int64_t _weight_stride0)
  , $(int64_t _input_size)
  , $(int64_t _mode)
  , $(int64_t _hidden_size)
  , $(int64_t _num_layers)
  , $(bool _batch_first)
  , $(bool _bidirectional)));
  }|]

_cudnn_rnn_tlltttlllbdbblt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> CBool
  -> CDouble
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor,Tensor)))
_cudnn_rnn_tlltttlllbdbblt _input _weight _weight_stride0 _weight_buf _hx _cx _mode _hidden_size _num_layers _batch_first _dropout _train _bidirectional _batch_sizes _dropout_state =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_cudnn_rnn(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _weight)
  , $(int64_t _weight_stride0)
  , *$(at::Tensor* _weight_buf)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _cx)
  , $(int64_t _mode)
  , $(int64_t _hidden_size)
  , $(int64_t _num_layers)
  , $(bool _batch_first)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , *$(std::vector<int64_t>* _batch_sizes)
  , *$(at::Tensor* _dropout_state)));
  }|]

_cudnn_rnn_backward_tlltttttttlllbdbbltta
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> CBool
  -> CDouble
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray '(CBool,4))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,TensorList)))
_cudnn_rnn_backward_tlltttttttlllbdbbltta _input _weight _weight_stride0 _weight_buf _hx _cx _output _grad_output _grad_hy _grad_cy _mode _hidden_size _num_layers _batch_first _dropout _train _bidirectional _batch_sizes _dropout_state _reserve _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,std::vector<at::Tensor>>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,std::vector<at::Tensor>>(at::_cudnn_rnn_backward(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _weight)
  , $(int64_t _weight_stride0)
  , *$(at::Tensor* _weight_buf)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _output)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _grad_cy)
  , $(int64_t _mode)
  , $(int64_t _hidden_size)
  , $(int64_t _num_layers)
  , $(bool _batch_first)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , *$(std::vector<int64_t>* _batch_sizes)
  , *$(at::Tensor* _dropout_state)
  , *$(at::Tensor* _reserve)
  , *$(std::array<bool,4>* _output_mask)));
  }|]

_cudnn_init_dropout_state_dblo
  :: CDouble
  -> CBool
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_cudnn_init_dropout_state_dblo _dropout _train _dropout_seed _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_cudnn_init_dropout_state(
    $(double _dropout)
  , $(bool _train)
  , $(int64_t _dropout_seed)
  , *$(at::TensorOptions* _options)));
  }|]

_debug_has_internal_overlap_t
  :: Ptr Tensor
  -> IO (Int64)
_debug_has_internal_overlap_t _self =
  [C.throwBlock| int64_t { return (at::_debug_has_internal_overlap(
    *$(at::Tensor* _self)));
  }|]

_fused_dropout_tdp
  :: Ptr Tensor
  -> CDouble
  -> Ptr Generator
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_fused_dropout_tdp _self _p _generator =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_fused_dropout(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(at::Generator * _generator)));
  }|]

_fused_dropout_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_fused_dropout_td _self _p =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_fused_dropout(
    *$(at::Tensor* _self)
  , $(double _p)));
  }|]

_masked_scale_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
_masked_scale_ttd _self _mask _scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_masked_scale(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , $(double _scale)));
  }|]

_sobol_engine_draw_tltlls
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> ScalarType
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_sobol_engine_draw_tltlls _quasi _n _sobolstate _dimension _num_generated _dtype =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_sobol_engine_draw(
    *$(at::Tensor* _quasi)
  , $(int64_t _n)
  , *$(at::Tensor* _sobolstate)
  , $(int64_t _dimension)
  , $(int64_t _num_generated)
  , $(at::ScalarType _dtype)));
  }|]

_sobol_engine_ff__tltll
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
_sobol_engine_ff__tltll _self _n _sobolstate _dimension _num_generated =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sobol_engine_ff_(
    *$(at::Tensor* _self)
  , $(int64_t _n)
  , *$(at::Tensor* _sobolstate)
  , $(int64_t _dimension)
  , $(int64_t _num_generated)));
  }|]

_sobol_engine_scramble__ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_sobol_engine_scramble__ttl _self _ltm _dimension =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sobol_engine_scramble_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _ltm)
  , $(int64_t _dimension)));
  }|]

_sobol_engine_initialize_state__tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_sobol_engine_initialize_state__tl _self _dimension =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sobol_engine_initialize_state_(
    *$(at::Tensor* _self)
  , $(int64_t _dimension)));
  }|]

_reshape_from_tensor_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_reshape_from_tensor_tt _self _shape =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_reshape_from_tensor(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _shape)));
  }|]

_shape_as_tensor_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_shape_as_tensor_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_shape_as_tensor(
    *$(at::Tensor* _self)));
  }|]

dropout_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
dropout_tdb _input _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::dropout(
    *$(at::Tensor* _input)
  , $(double _p)
  , $(bool _train)));
  }|]

dropout__tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
dropout__tdb _self _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::dropout_(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(bool _train)));
  }|]

feature_dropout_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
feature_dropout_tdb _input _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::feature_dropout(
    *$(at::Tensor* _input)
  , $(double _p)
  , $(bool _train)));
  }|]

feature_dropout__tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
feature_dropout__tdb _self _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::feature_dropout_(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(bool _train)));
  }|]

alpha_dropout_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
alpha_dropout_tdb _input _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::alpha_dropout(
    *$(at::Tensor* _input)
  , $(double _p)
  , $(bool _train)));
  }|]

alpha_dropout__tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
alpha_dropout__tdb _self _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::alpha_dropout_(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(bool _train)));
  }|]

feature_alpha_dropout_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
feature_alpha_dropout_tdb _input _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::feature_alpha_dropout(
    *$(at::Tensor* _input)
  , $(double _p)
  , $(bool _train)));
  }|]

feature_alpha_dropout__tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
feature_alpha_dropout__tdb _self _p _train =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::feature_alpha_dropout_(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(bool _train)));
  }|]

abs_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
abs_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::abs(
    *$(at::Tensor* _self)));
  }|]

abs__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
abs__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::abs_(
    *$(at::Tensor* _self)));
  }|]

abs_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
abs_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::abs_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

angle_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
angle_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::angle(
    *$(at::Tensor* _self)));
  }|]

angle_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
angle_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::angle_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

real_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
real_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::real(
    *$(at::Tensor* _self)));
  }|]

imag_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
imag_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::imag(
    *$(at::Tensor* _self)));
  }|]

conj_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
conj_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conj(
    *$(at::Tensor* _self)));
  }|]

conj_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conj_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conj_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

acos_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
acos_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::acos(
    *$(at::Tensor* _self)));
  }|]

acos__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
acos__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::acos_(
    *$(at::Tensor* _self)));
  }|]

acos_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
acos_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::acos_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

avg_pool1d_tlllbb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool1d_tlllbb _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool1d_tlllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
avg_pool1d_tlllb _self _kernel_size _stride _padding _ceil_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)));
  }|]

avg_pool1d_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool1d_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

avg_pool1d_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool1d_tll _self _kernel_size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

avg_pool1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
avg_pool1d_tl _self _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

adaptive_avg_pool1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool1d_tl _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
adaptive_max_pool1d_tl _self _output_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

add_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_tts _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::add(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

add_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
add_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::add(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

add_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_out_ttts _out _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::add_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

add_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
add_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::add_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

add_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_tss _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::add(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

add_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::add(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

addmv_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv_tttss _self _mat _vec _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmv_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv_ttts _self _mat _vec _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)));
  }|]

addmv_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addmv_ttt _self _mat _vec =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)));
  }|]

addmv__tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv__tttss _self _mat _vec _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmv__ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv__ttts _self _mat _vec _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)));
  }|]

addmv__ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addmv__ttt _self _mat _vec =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)));
  }|]

addmv_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv_out_ttttss _out _self _mat _vec _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmv_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv_out_tttts _out _self _mat _vec _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)));
  }|]

addmv_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addmv_out_tttt _out _self _mat _vec =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)));
  }|]

addr_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addr_tttss _self _vec1 _vec2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addr_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addr_ttts _self _vec1 _vec2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)));
  }|]

addr_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addr_ttt _self _vec1 _vec2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)));
  }|]

addr_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addr_out_ttttss _out _self _vec1 _vec2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addr_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addr_out_tttts _out _self _vec1 _vec2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)));
  }|]

addr_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addr_out_tttt _out _self _vec1 _vec2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)));
  }|]

affine_grid_generator_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
affine_grid_generator_tlb _theta _size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::affine_grid_generator(
    *$(at::Tensor* _theta)
  , *$(std::vector<int64_t>* _size)
  , $(bool _align_corners)));
  }|]

affine_grid_generator_backward_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
affine_grid_generator_backward_tlb _grad _size _align_corners =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::affine_grid_generator_backward(
    *$(at::Tensor* _grad)
  , *$(std::vector<int64_t>* _size)
  , $(bool _align_corners)));
  }|]

all_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
all_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

all_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
all_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

all_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
all_out_ttlb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

all_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
all_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

all_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr Tensor)
all_tnb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

all_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
all_tn _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

all_out_ttnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr Tensor)
all_out_ttnb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

all_out_ttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
all_out_ttn _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

allclose_ttddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (CBool)
allclose_ttddb _self _other _rtol _atol _equal_nan =
  [C.throwBlock| bool { return (at::allclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)
  , $(double _atol)
  , $(bool _equal_nan)));
  }|]

allclose_ttdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> IO (CBool)
allclose_ttdd _self _other _rtol _atol =
  [C.throwBlock| bool { return (at::allclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)
  , $(double _atol)));
  }|]

allclose_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (CBool)
allclose_ttd _self _other _rtol =
  [C.throwBlock| bool { return (at::allclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)));
  }|]

allclose_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (CBool)
allclose_tt _self _other =
  [C.throwBlock| bool { return (at::allclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

any_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
any_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

any_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
any_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

any_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
any_out_ttlb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

any_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
any_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

any_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr Tensor)
any_tnb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

any_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
any_tn _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

any_out_ttnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr Tensor)
any_out_ttnb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

any_out_ttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
any_out_ttn _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

arange_so
  :: Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_so _end _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _end)
  , *$(at::TensorOptions* _options)));
  }|]

arange_s
  :: Ptr Scalar
  -> IO (Ptr Tensor)
arange_s _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _end)));
  }|]

arange_sso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_sso _start _end _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::TensorOptions* _options)));
  }|]

arange_ss
  :: Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_ss _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

arange_ssso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_ssso _start _end _step _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)
  , *$(at::TensorOptions* _options)));
  }|]

arange_sss
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_sss _start _end _step =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)));
  }|]

arange_out_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_out_ts _out _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _end)));
  }|]

arange_out_tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_out_tsss _out _start _end _step =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)));
  }|]

arange_out_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_out_tss _out _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arange_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

_dim_arange_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_dim_arange_tl _like _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_dim_arange(
    *$(at::Tensor* _like)
  , $(int64_t _dim)));
  }|]

argmax_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
argmax_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

argmax_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
argmax_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

argmax_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
argmax_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argmax(
    *$(at::Tensor* _self)));
  }|]

argmin_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
argmin_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argmin(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

argmin_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
argmin_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argmin(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

argmin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
argmin_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argmin(
    *$(at::Tensor* _self)));
  }|]

as_strided_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
as_strided_tlll _self _size _stride _storage_offset =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::as_strided(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)
  , $(int64_t _storage_offset)));
  }|]

as_strided_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
as_strided_tll _self _size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::as_strided(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

as_strided__tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
as_strided__tlll _self _size _stride _storage_offset =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::as_strided_(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)
  , $(int64_t _storage_offset)));
  }|]

as_strided__tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
as_strided__tll _self _size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::as_strided_(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

asin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
asin_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::asin(
    *$(at::Tensor* _self)));
  }|]

asin__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
asin__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::asin_(
    *$(at::Tensor* _self)));
  }|]
