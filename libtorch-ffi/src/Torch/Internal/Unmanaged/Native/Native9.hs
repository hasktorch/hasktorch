
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Torch.Internal.Unmanaged.Native.Native9 where


import Foreign.C.String
import Foreign.C.Types
import Foreign
import Torch.Internal.Type


import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<vector>"
C.include "<ATen/Tensor.h>"
C.include "<ATen/Functions.h>"

sub_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_out_ttts _out _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sub_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

sub_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sub_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sub_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

sub_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_tts _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sub(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

sub_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sub_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sub(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

sub_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_tss _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sub(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

sub_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sub(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

rsub_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rsub_tts _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsub(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

rsub_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rsub_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsub(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

rsub_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rsub_tss _self _other _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsub(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

rsub_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rsub_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rsub(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

_sparse_addmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_sparse_addmm_tttss _self _sparse _dense _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _sparse)
  , *$(at::Tensor* _dense)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

_sparse_addmm_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_sparse_addmm_ttts _self _sparse _dense _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _sparse)
  , *$(at::Tensor* _dense)
  , *$(at::Scalar* _beta)));
  }|]

_sparse_addmm_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_sparse_addmm_ttt _self _sparse _dense =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _sparse)
  , *$(at::Tensor* _dense)));
  }|]

addmm_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmm_out_ttttss _out _self _mat1 _mat2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmm_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmm_out_tttts _out _self _mat1 _mat2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)));
  }|]

addmm_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addmm_out_tttt _out _self _mat1 _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

addmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmm_tttss _self _mat1 _mat2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmm_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmm_ttts _self _mat1 _mat2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)));
  }|]

addmm_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
addmm_ttt _self _mat1 _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

sparse_coo_tensor_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sparse_coo_tensor(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_coo_tensor_tto
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_tto _indices _values _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_coo_tensor_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sparse_coo_tensor_tt _indices _values =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)));
  }|]

sparse_coo_tensor_ttlo
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_ttlo _indices _values _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_coo_tensor_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
sparse_coo_tensor_ttl _indices _values _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(std::vector<int64_t>* _size)));
  }|]

_sparse_coo_tensor_unsafe_ttlo
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_sparse_coo_tensor_unsafe_ttlo _indices _values _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_coo_tensor_unsafe(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

_sparse_coo_tensor_unsafe_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_sparse_coo_tensor_unsafe_ttl _indices _values _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_coo_tensor_unsafe(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(std::vector<int64_t>* _size)));
  }|]

_sparse_coo_tensor_with_dims_lllo
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_sparse_coo_tensor_with_dims_lllo _sparse_dim _dense_dim _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_coo_tensor_with_dims(
    $(int64_t _sparse_dim)
  , $(int64_t _dense_dim)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

_sparse_coo_tensor_with_dims_and_tensors_llltto
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_sparse_coo_tensor_with_dims_and_tensors_llltto _sparse_dim _dense_dim _size _indices _values _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_sparse_coo_tensor_with_dims_and_tensors(
    $(int64_t _sparse_dim)
  , $(int64_t _dense_dim)
  , *$(std::vector<int64_t>* _size)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(at::TensorOptions* _options)));
  }|]

to_dense_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
to_dense_backward_tt _grad _input =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::to_dense_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _input)));
  }|]

hspmm_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hspmm_out_ttt _out _mat1 _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hspmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

hspmm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hspmm_tt _mat1 _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hspmm(
    *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

copy_sparse_to_sparse__ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
copy_sparse_to_sparse__ttb _self _src _non_blocking =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::copy_sparse_to_sparse_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _src)
  , $(bool _non_blocking)));
  }|]

copy_sparse_to_sparse__tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
copy_sparse_to_sparse__tt _self _src =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::copy_sparse_to_sparse_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _src)));
  }|]

unbind_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr TensorList)
unbind_tl _self _dim =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::unbind(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

unbind_t
  :: Ptr Tensor
  -> IO (Ptr TensorList)
unbind_t _self =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::unbind(
    *$(at::Tensor* _self)));
  }|]

unbind_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr TensorList)
unbind_tn _self _dim =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::unbind(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

mkldnn_reorder_conv2d_weight_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
mkldnn_reorder_conv2d_weight_tllll _self _padding _stride _dilation _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_reorder_conv2d_weight(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)));
  }|]

mkldnn_reorder_conv2d_weight_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mkldnn_reorder_conv2d_weight_tlll _self _padding _stride _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_reorder_conv2d_weight(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

mkldnn_reorder_conv2d_weight_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mkldnn_reorder_conv2d_weight_tll _self _padding _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_reorder_conv2d_weight(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

mkldnn_reorder_conv2d_weight_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mkldnn_reorder_conv2d_weight_tl _self _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_reorder_conv2d_weight(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

mkldnn_reorder_conv2d_weight_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
mkldnn_reorder_conv2d_weight_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_reorder_conv2d_weight(
    *$(at::Tensor* _self)));
  }|]

to_mkldnn_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
to_mkldnn_backward_tt _grad _input =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::to_mkldnn_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _input)));
  }|]

quantize_per_tensor_tdls
  :: Ptr Tensor
  -> CDouble
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
quantize_per_tensor_tdls _self _scale _zero_point _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantize_per_tensor(
    *$(at::Tensor* _self)
  , $(double _scale)
  , $(int64_t _zero_point)
  , $(at::ScalarType _dtype)));
  }|]

quantize_per_channel_tttls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
quantize_per_channel_tttls _self _scales _zero_points _axis _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantize_per_channel(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _scales)
  , *$(at::Tensor* _zero_points)
  , $(int64_t _axis)
  , $(at::ScalarType _dtype)));
  }|]

dequantize_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
dequantize_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::dequantize(
    *$(at::Tensor* _self)));
  }|]

q_scale_t
  :: Ptr Tensor
  -> IO (CDouble)
q_scale_t _self =
  [C.throwBlock| double { return (at::q_scale(
    *$(at::Tensor* _self)));
  }|]

q_zero_point_t
  :: Ptr Tensor
  -> IO (Int64)
q_zero_point_t _self =
  [C.throwBlock| int64_t { return (at::q_zero_point(
    *$(at::Tensor* _self)));
  }|]

q_per_channel_scales_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
q_per_channel_scales_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::q_per_channel_scales(
    *$(at::Tensor* _self)));
  }|]

q_per_channel_zero_points_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
q_per_channel_zero_points_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::q_per_channel_zero_points(
    *$(at::Tensor* _self)));
  }|]

q_per_channel_axis_t
  :: Ptr Tensor
  -> IO (Int64)
q_per_channel_axis_t _self =
  [C.throwBlock| int64_t { return (at::q_per_channel_axis(
    *$(at::Tensor* _self)));
  }|]

int_repr_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
int_repr_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::int_repr(
    *$(at::Tensor* _self)));
  }|]

_make_per_tensor_quantized_tensor_tdl
  :: Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
_make_per_tensor_quantized_tensor_tdl _self _scale _zero_point =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_make_per_tensor_quantized_tensor(
    *$(at::Tensor* _self)
  , $(double _scale)
  , $(int64_t _zero_point)));
  }|]

_make_per_channel_quantized_tensor_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_make_per_channel_quantized_tensor_tttl _self _scale _zero_point _axis =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_make_per_channel_quantized_tensor(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _scale)
  , *$(at::Tensor* _zero_point)
  , $(int64_t _axis)));
  }|]

fake_quantize_per_tensor_affine_tdlll
  :: Ptr Tensor
  -> CDouble
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
fake_quantize_per_tensor_affine_tdlll _self _scale _zero_point _quant_min _quant_max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fake_quantize_per_tensor_affine(
    *$(at::Tensor* _self)
  , $(double _scale)
  , $(int64_t _zero_point)
  , $(int64_t _quant_min)
  , $(int64_t _quant_max)));
  }|]

fake_quantize_per_tensor_affine_backward_ttdlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
fake_quantize_per_tensor_affine_backward_ttdlll _grad _self _scale _zero_point _quant_min _quant_max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fake_quantize_per_tensor_affine_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _self)
  , $(double _scale)
  , $(int64_t _zero_point)
  , $(int64_t _quant_min)
  , $(int64_t _quant_max)));
  }|]

fake_quantize_per_channel_affine_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
fake_quantize_per_channel_affine_tttlll _self _scale _zero_point _axis _quant_min _quant_max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fake_quantize_per_channel_affine(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _scale)
  , *$(at::Tensor* _zero_point)
  , $(int64_t _axis)
  , $(int64_t _quant_min)
  , $(int64_t _quant_max)));
  }|]

fake_quantize_per_channel_affine_backward_ttttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
fake_quantize_per_channel_affine_backward_ttttlll _grad _self _scale _zero_point _axis _quant_min _quant_max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fake_quantize_per_channel_affine_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _scale)
  , *$(at::Tensor* _zero_point)
  , $(int64_t _axis)
  , $(int64_t _quant_min)
  , $(int64_t _quant_max)));
  }|]

meshgrid_l
  :: Ptr TensorList
  -> IO (Ptr TensorList)
meshgrid_l _tensors =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::meshgrid(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

cartesian_prod_l
  :: Ptr TensorList
  -> IO (Ptr Tensor)
cartesian_prod_l _tensors =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cartesian_prod(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

combinations_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
combinations_tlb _self _r _with_replacement =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::combinations(
    *$(at::Tensor* _self)
  , $(int64_t _r)
  , $(bool _with_replacement)));
  }|]

combinations_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
combinations_tl _self _r =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::combinations(
    *$(at::Tensor* _self)
  , $(int64_t _r)));
  }|]

combinations_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
combinations_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::combinations(
    *$(at::Tensor* _self)));
  }|]

result_type_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (ScalarType)
result_type_tt _tensor _other =
  [C.throwBlock| at::ScalarType { return (at::result_type(
    *$(at::Tensor* _tensor)
  , *$(at::Tensor* _other)));
  }|]

result_type_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (ScalarType)
result_type_ts _tensor _other =
  [C.throwBlock| at::ScalarType { return (at::result_type(
    *$(at::Tensor* _tensor)
  , *$(at::Scalar* _other)));
  }|]

result_type_st
  :: Ptr Scalar
  -> Ptr Tensor
  -> IO (ScalarType)
result_type_st _scalar _tensor =
  [C.throwBlock| at::ScalarType { return (at::result_type(
    *$(at::Scalar* _scalar)
  , *$(at::Tensor* _tensor)));
  }|]

result_type_ss
  :: Ptr Scalar
  -> Ptr Scalar
  -> IO (ScalarType)
result_type_ss _scalar1 _scalar2 =
  [C.throwBlock| at::ScalarType { return (at::result_type(
    *$(at::Scalar* _scalar1)
  , *$(at::Scalar* _scalar2)));
  }|]

can_cast_ss
  :: ScalarType
  -> ScalarType
  -> IO (CBool)
can_cast_ss _from _to =
  [C.throwBlock| bool { return (at::can_cast(
    $(at::ScalarType _from)
  , $(at::ScalarType _to)));
  }|]

promote_types_ss
  :: ScalarType
  -> ScalarType
  -> IO (ScalarType)
promote_types_ss _type1 _type2 =
  [C.throwBlock| at::ScalarType { return (at::promote_types(
    $(at::ScalarType _type1)
  , $(at::ScalarType _type2)));
  }|]

_local_scalar_dense_t
  :: Ptr Tensor
  -> IO (Ptr Scalar)
_local_scalar_dense_t _self =
  [C.throwBlock| at::Scalar* { return new at::Scalar(at::_local_scalar_dense(
    *$(at::Tensor* _self)));
  }|]

_thnn_fused_lstm_cell_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_thnn_fused_lstm_cell_ttttt _input_gates _hidden_gates _cx _input_bias _hidden_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_thnn_fused_lstm_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _input_bias)
  , *$(at::Tensor* _hidden_bias)));
  }|]

_thnn_fused_lstm_cell_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_thnn_fused_lstm_cell_tttt _input_gates _hidden_gates _cx _input_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_thnn_fused_lstm_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _input_bias)));
  }|]

_thnn_fused_lstm_cell_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_thnn_fused_lstm_cell_ttt _input_gates _hidden_gates _cx =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_thnn_fused_lstm_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _cx)));
  }|]

_thnn_fused_lstm_cell_backward_tttttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor,Tensor)))
_thnn_fused_lstm_cell_backward_tttttb _grad_hy _grad_cy _cx _cy _workspace _has_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_thnn_fused_lstm_cell_backward(
    *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _grad_cy)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _cy)
  , *$(at::Tensor* _workspace)
  , $(bool _has_bias)));
  }|]

_thnn_differentiable_lstm_cell_backward_tttttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor,Tensor)))
_thnn_differentiable_lstm_cell_backward_tttttttt _grad_hy _grad_cy _input_gates _hidden_gates _input_bias _hidden_bias _cx _cy =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_thnn_differentiable_lstm_cell_backward(
    *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _grad_cy)
  , *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _input_bias)
  , *$(at::Tensor* _hidden_bias)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _cy)));
  }|]

_thnn_fused_gru_cell_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_thnn_fused_gru_cell_ttttt _input_gates _hidden_gates _hx _input_bias _hidden_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_thnn_fused_gru_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _input_bias)
  , *$(at::Tensor* _hidden_bias)));
  }|]

_thnn_fused_gru_cell_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_thnn_fused_gru_cell_tttt _input_gates _hidden_gates _hx _input_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_thnn_fused_gru_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _input_bias)));
  }|]

_thnn_fused_gru_cell_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_thnn_fused_gru_cell_ttt _input_gates _hidden_gates _hx =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_thnn_fused_gru_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _hx)));
  }|]

_thnn_fused_gru_cell_backward_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor,Tensor)))
_thnn_fused_gru_cell_backward_ttb _grad_hy _workspace _has_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_thnn_fused_gru_cell_backward(
    *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _workspace)
  , $(bool _has_bias)));
  }|]

_thnn_differentiable_gru_cell_backward_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor,Tensor)))
_thnn_differentiable_gru_cell_backward_tttttt _grad_hy _input_gates _hidden_gates _hx _input_bias _hidden_bias =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_thnn_differentiable_gru_cell_backward(
    *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _input_bias)
  , *$(at::Tensor* _hidden_bias)));
  }|]

lstm_tllbldbbb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
lstm_tllbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::lstm(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

lstm_ttllbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
lstm_ttllbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::lstm(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

gru_ttlbldbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
gru_ttlbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::gru(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

gru_tttlbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
gru_tttlbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::gru(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

rnn_tanh_ttlbldbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
rnn_tanh_ttlbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::rnn_tanh(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

rnn_tanh_tttlbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
rnn_tanh_tttlbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::rnn_tanh(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

rnn_relu_ttlbldbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
rnn_relu_ttlbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::rnn_relu(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

rnn_relu_tttlbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
rnn_relu_tttlbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::rnn_relu(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

lstm_cell_tltttt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
lstm_cell_tltttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::lstm_cell(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

lstm_cell_tlttt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
lstm_cell_tlttt _input _hx _w_ih _w_hh _b_ih =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::lstm_cell(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)));
  }|]

lstm_cell_tltt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
lstm_cell_tltt _input _hx _w_ih _w_hh =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::lstm_cell(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)));
  }|]

gru_cell_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gru_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gru_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

gru_cell_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gru_cell_ttttt _input _hx _w_ih _w_hh _b_ih =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gru_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)));
  }|]

gru_cell_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gru_cell_tttt _input _hx _w_ih _w_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::gru_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)));
  }|]

rnn_tanh_cell_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_tanh_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rnn_tanh_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

rnn_tanh_cell_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_tanh_cell_ttttt _input _hx _w_ih _w_hh _b_ih =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rnn_tanh_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)));
  }|]

rnn_tanh_cell_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_tanh_cell_tttt _input _hx _w_ih _w_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rnn_tanh_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)));
  }|]

rnn_relu_cell_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_relu_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rnn_relu_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

rnn_relu_cell_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_relu_cell_ttttt _input _hx _w_ih _w_hh _b_ih =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rnn_relu_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)));
  }|]

rnn_relu_cell_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_relu_cell_tttt _input _hx _w_ih _w_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rnn_relu_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)));
  }|]

quantized_lstm_tllbldbbbsb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> ScalarType
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
quantized_lstm_tllbldbbbsb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first _dtype _use_dynamic =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::quantized_lstm(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)
  , $(at::ScalarType _dtype)
  , $(bool _use_dynamic)));
  }|]

quantized_lstm_tllbldbbbs
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> ScalarType
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
quantized_lstm_tllbldbbbs _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first _dtype =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::quantized_lstm(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)
  , $(at::ScalarType _dtype)));
  }|]

quantized_lstm_tllbldbbb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
quantized_lstm_tllbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::quantized_lstm(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

quantized_lstm_ttllbldbbsb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> ScalarType
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
quantized_lstm_ttllbldbbsb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional _dtype _use_dynamic =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::quantized_lstm(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(at::ScalarType _dtype)
  , $(bool _use_dynamic)));
  }|]

quantized_lstm_ttllbldbbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> ScalarType
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
quantized_lstm_ttllbldbbs _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional _dtype =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::quantized_lstm(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(at::ScalarType _dtype)));
  }|]

quantized_lstm_ttllbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
quantized_lstm_ttllbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::quantized_lstm(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

quantized_gru_ttlbldbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
quantized_gru_ttlbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::quantized_gru(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

quantized_gru_tttlbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
quantized_gru_tttlbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::quantized_gru(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(std::vector<at::Tensor>* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

quantized_lstm_cell_tlttttttttssss
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
quantized_lstm_cell_tlttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::quantized_lstm_cell(
    *$(at::Tensor* _input)
  , *$(std::vector<at::Tensor>* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

quantized_gru_cell_ttttttttttssss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
quantized_gru_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantized_gru_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

quantized_rnn_relu_cell_ttttttttttssss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
quantized_rnn_relu_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantized_rnn_relu_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

quantized_rnn_tanh_cell_ttttttttttssss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
quantized_rnn_tanh_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantized_rnn_tanh_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

_pack_padded_sequence_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_pack_padded_sequence_ttb _input _lengths _batch_first =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_pack_padded_sequence(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _lengths)
  , $(bool _batch_first)));
  }|]

_pack_padded_sequence_backward_tltb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_pack_padded_sequence_backward_tltb _grad _input_size _batch_sizes _batch_first =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_pack_padded_sequence_backward(
    *$(at::Tensor* _grad)
  , *$(std::vector<int64_t>* _input_size)
  , *$(at::Tensor* _batch_sizes)
  , $(bool _batch_first)));
  }|]

_pad_packed_sequence_ttbsl
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Ptr Scalar
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_pad_packed_sequence_ttbsl _data _batch_sizes _batch_first _padding_value _total_length =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_pad_packed_sequence(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , $(bool _batch_first)
  , *$(at::Scalar* _padding_value)
  , $(int64_t _total_length)));
  }|]

masked_fill_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
masked_fill_tts _self _mask _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::masked_fill(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Scalar* _value)));
  }|]

masked_fill_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_fill_ttt _self _mask _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::masked_fill(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Tensor* _value)));
  }|]

masked_scatter_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_scatter_ttt _self _mask _source =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::masked_scatter(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Tensor* _source)));
  }|]

index_add_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_add_tltt _self _dim _index _source =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_add(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

index_add_tntt
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_add_tntt _self _dim _index _source =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_add(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

index_fill_tlts
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
index_fill_tlts _self _dim _index _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_fill(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Scalar* _value)));
  }|]

index_fill_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_fill_tltt _self _dim _index _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_fill(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _value)));
  }|]

index_fill_tnts
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
index_fill_tnts _self _dim _index _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_fill(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)
  , *$(at::Scalar* _value)));
  }|]

index_fill_tntt
  :: Ptr Tensor
  -> Ptr Dimname
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_fill_tntt _self _dim _index _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::index_fill(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _value)));
  }|]

scatter_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
scatter_tltt _self _dim _index _src =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::scatter(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _src)));
  }|]

scatter_tlts
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
scatter_tlts _self _dim _index _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::scatter(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Scalar* _value)));
  }|]
