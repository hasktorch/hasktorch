
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Torch.Internal.Unmanaged.Native.Native1 where


import Foreign.C.String
import Foreign.C.Types
import Foreign
import Torch.Internal.Type

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<vector>"
C.include "<ATen/Tensor.h>"
C.include "<ATen/Functions.h>"


arctanh_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
arctanh_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arctanh(
    *$(at::Tensor* _self)));
  }|]

arctanh__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
arctanh__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arctanh_(
    *$(at::Tensor* _self)));
  }|]

arctanh_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
arctanh_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arctanh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

as_strided_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
as_strided_tlll _self _size _stride _storage_offset =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::as_strided(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)
  , $(int64_t _storage_offset)));
  }|]

as_strided_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
as_strided_tll _self _size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::as_strided(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

as_strided__tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
as_strided__tlll _self _size _stride _storage_offset =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::as_strided_(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)
  , $(int64_t _storage_offset)));
  }|]

as_strided__tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
as_strided__tll _self _size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::as_strided_(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

asin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
asin_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::asin(
    *$(at::Tensor* _self)));
  }|]

asin__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
asin__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::asin_(
    *$(at::Tensor* _self)));
  }|]

asin_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
asin_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::asin_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

arcsin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
arcsin_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arcsin(
    *$(at::Tensor* _self)));
  }|]

arcsin__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
arcsin__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arcsin_(
    *$(at::Tensor* _self)));
  }|]

arcsin_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
arcsin_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arcsin_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

atan_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
atan_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::atan(
    *$(at::Tensor* _self)));
  }|]

atan__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
atan__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::atan_(
    *$(at::Tensor* _self)));
  }|]

atan_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
atan_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::atan_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

arctan_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
arctan_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arctan(
    *$(at::Tensor* _self)));
  }|]

arctan__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
arctan__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arctan_(
    *$(at::Tensor* _self)));
  }|]

arctan_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
arctan_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::arctan_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

atleast_1d_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
atleast_1d_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::atleast_1d(
    *$(at::Tensor* _self)));
  }|]

atleast_1d_l
  :: Ptr TensorList
  -> IO (Ptr TensorList)
atleast_1d_l _tensors =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::atleast_1d(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

atleast_2d_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
atleast_2d_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::atleast_2d(
    *$(at::Tensor* _self)));
  }|]

atleast_2d_l
  :: Ptr TensorList
  -> IO (Ptr TensorList)
atleast_2d_l _tensors =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::atleast_2d(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

atleast_3d_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
atleast_3d_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::atleast_3d(
    *$(at::Tensor* _self)));
  }|]

atleast_3d_l
  :: Ptr TensorList
  -> IO (Ptr TensorList)
atleast_3d_l _tensors =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::atleast_3d(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

baddbmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
baddbmm_tttss _self _batch1 _batch2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::baddbmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

baddbmm_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
baddbmm_ttts _self _batch1 _batch2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::baddbmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)));
  }|]

baddbmm_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
baddbmm_ttt _self _batch1 _batch2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::baddbmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)));
  }|]

_baddbmm_mkl__tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_baddbmm_mkl__tttss _self _batch1 _batch2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_baddbmm_mkl_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

_baddbmm_mkl__ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_baddbmm_mkl__ttts _self _batch1 _batch2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_baddbmm_mkl_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)));
  }|]

_baddbmm_mkl__ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_baddbmm_mkl__ttt _self _batch1 _batch2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_baddbmm_mkl_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)));
  }|]

baddbmm_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
baddbmm_out_ttttss _out _self _batch1 _batch2 _beta _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::baddbmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

baddbmm_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
baddbmm_out_tttts _out _self _batch1 _batch2 _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::baddbmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)));
  }|]

baddbmm_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
baddbmm_out_tttt _out _self _batch1 _batch2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::baddbmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)));
  }|]

bartlett_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
bartlett_window_lo _window_length _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bartlett_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

bartlett_window_l
  :: Int64
  -> IO (Ptr Tensor)
bartlett_window_l _window_length =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bartlett_window(
    $(int64_t _window_length)));
  }|]

bartlett_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
bartlett_window_lbo _window_length _periodic _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bartlett_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

bartlett_window_lb
  :: Int64
  -> CBool
  -> IO (Ptr Tensor)
bartlett_window_lb _window_length _periodic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bartlett_window(
    $(int64_t _window_length)
  , $(bool _periodic)));
  }|]

batch_norm_tttttbddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
batch_norm_tttttbddb _input _weight _bias _running_mean _running_var _training _momentum _eps _cudnn_enabled =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::batch_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(double _momentum)
  , $(double _eps)
  , $(bool _cudnn_enabled)));
  }|]

quantized_batch_norm_tttttddl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
quantized_batch_norm_tttttddl _input _weight _bias _mean _var _eps _output_scale _output_zero_point =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantized_batch_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _var)
  , $(double _eps)
  , $(double _output_scale)
  , $(int64_t _output_zero_point)));
  }|]

_batch_norm_impl_index_tttttbddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor,Tensor,Int64)))
_batch_norm_impl_index_tttttbddb _input _weight _bias _running_mean _running_var _training _momentum _eps _cudnn_enabled =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,int64_t>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,int64_t>(at::_batch_norm_impl_index(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(double _momentum)
  , $(double _eps)
  , $(bool _cudnn_enabled)));
  }|]

_batch_norm_impl_index_backward_ltttttttbdat
  :: Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> Ptr (StdArray '(CBool,3))
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_batch_norm_impl_index_backward_ltttttttbdat _impl_index _input _grad_output _weight _running_mean _running_var _save_mean _save_var_transform _train _eps _output_mask _reservedSpace =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_batch_norm_impl_index_backward(
    $(int64_t _impl_index)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , *$(at::Tensor* _save_mean)
  , *$(at::Tensor* _save_var_transform)
  , $(bool _train)
  , $(double _eps)
  , *$(std::array<bool,3>* _output_mask)
  , *$(at::Tensor* _reservedSpace)));
  }|]

bernoulli_tG
  :: Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_tG _self _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bernoulli(
    *$(at::Tensor* _self)
  , *$(at::Generator* _generator)));
  }|]

bernoulli_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
bernoulli_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bernoulli(
    *$(at::Tensor* _self)));
  }|]

bernoulli_out_ttG
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_out_ttG _out _self _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bernoulli_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Generator* _generator)));
  }|]

bernoulli_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bernoulli_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bernoulli_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

bernoulli_tdG
  :: Ptr Tensor
  -> CDouble
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_tdG _self _p _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bernoulli(
    *$(at::Tensor* _self)
  , $(double _p)
  , *$(at::Generator* _generator)));
  }|]

bernoulli_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
bernoulli_td _self _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bernoulli(
    *$(at::Tensor* _self)
  , $(double _p)));
  }|]

bilinear_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bilinear_tttt _input1 _input2 _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bilinear(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

binary_cross_entropy_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_tttl _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_ttt _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

binary_cross_entropy_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

binary_cross_entropy_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_out_ttttl _out _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_out_tttt _out _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

binary_cross_entropy_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

binary_cross_entropy_backward_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_ttttl _grad_output _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_backward_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_tttt _grad_output _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

binary_cross_entropy_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_ttt _grad_output _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

binary_cross_entropy_backward_out_tttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_out_tttttl _grad_input _grad_output _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_backward_out_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_out_ttttt _grad_input _grad_output _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

binary_cross_entropy_backward_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_out_tttt _grad_input _grad_output _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

binary_cross_entropy_with_logits_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_ttttl _self _target _weight _pos_weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _pos_weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_with_logits_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_tttt _self _target _weight _pos_weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _pos_weight)));
  }|]

binary_cross_entropy_with_logits_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_ttt _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

binary_cross_entropy_with_logits_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

binary_cross_entropy_with_logits_backward_tttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_backward_tttttl _grad_output _self _target _weight _pos_weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _pos_weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_with_logits_backward_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_backward_ttttt _grad_output _self _target _weight _pos_weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _pos_weight)));
  }|]

binary_cross_entropy_with_logits_backward_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_backward_tttt _grad_output _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

binary_cross_entropy_with_logits_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_backward_ttt _grad_output _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

bincount_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
bincount_ttl _self _weights _minlength =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bincount(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weights)
  , $(int64_t _minlength)));
  }|]

bincount_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bincount_tt _self _weights =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bincount(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weights)));
  }|]

bincount_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
bincount_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bincount(
    *$(at::Tensor* _self)));
  }|]

bitwise_not_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
bitwise_not_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_not(
    *$(at::Tensor* _self)));
  }|]

bitwise_not_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bitwise_not_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bitwise_not_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

logical_not_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
logical_not_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_not(
    *$(at::Tensor* _self)));
  }|]

logical_not_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_not_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_not_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

logical_xor_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_xor_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_xor(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

logical_xor_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_xor_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_xor_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

logical_and_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_and_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_and(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

logical_and_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_and_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_and_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

logical_or_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_or_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_or(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

logical_or_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
logical_or_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logical_or_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

blackman_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
blackman_window_lo _window_length _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::blackman_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

blackman_window_l
  :: Int64
  -> IO (Ptr Tensor)
blackman_window_l _window_length =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::blackman_window(
    $(int64_t _window_length)));
  }|]

blackman_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
blackman_window_lbo _window_length _periodic _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::blackman_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

blackman_window_lb
  :: Int64
  -> CBool
  -> IO (Ptr Tensor)
blackman_window_lb _window_length _periodic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::blackman_window(
    $(int64_t _window_length)
  , $(bool _periodic)));
  }|]

bmm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bmm_tt _self _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

_bmm_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_bmm_ttb _self _mat2 _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_bmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)
  , $(bool _deterministic)));
  }|]

_bmm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_bmm_tt _self _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_bmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

bmm_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bmm_out_ttt _out _self _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::bmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

_bmm_out_tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_bmm_out_tttb _out _self _mat2 _deterministic =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_bmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)
  , $(bool _deterministic)));
  }|]

_bmm_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_bmm_out_ttt _out _self _mat2 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_bmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

broadcast_tensors_l
  :: Ptr TensorList
  -> IO (Ptr TensorList)
broadcast_tensors_l _tensors =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::broadcast_tensors(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

cat_ll
  :: Ptr TensorList
  -> Int64
  -> IO (Ptr Tensor)
cat_ll _tensors _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cat(
    *$(std::vector<at::Tensor>* _tensors)
  , $(int64_t _dim)));
  }|]

cat_l
  :: Ptr TensorList
  -> IO (Ptr Tensor)
cat_l _tensors =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cat(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

cat_out_tll
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> IO (Ptr Tensor)
cat_out_tll _out _tensors _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cat_out(
    *$(at::Tensor* _out)
  , *$(std::vector<at::Tensor>* _tensors)
  , $(int64_t _dim)));
  }|]

cat_out_tl
  :: Ptr Tensor
  -> Ptr TensorList
  -> IO (Ptr Tensor)
cat_out_tl _out _tensors =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cat_out(
    *$(at::Tensor* _out)
  , *$(std::vector<at::Tensor>* _tensors)));
  }|]

cat_ln
  :: Ptr TensorList
  -> Ptr Dimname
  -> IO (Ptr Tensor)
cat_ln _tensors _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cat(
    *$(std::vector<at::Tensor>* _tensors)
  , *$(at::Dimname* _dim)));
  }|]

cat_out_tln
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Dimname
  -> IO (Ptr Tensor)
cat_out_tln _out _tensors _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::cat_out(
    *$(at::Tensor* _out)
  , *$(std::vector<at::Tensor>* _tensors)
  , *$(at::Dimname* _dim)));
  }|]

block_diag_l
  :: Ptr TensorList
  -> IO (Ptr Tensor)
block_diag_l _tensors =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::block_diag(
    *$(std::vector<at::Tensor>* _tensors)));
  }|]

ceil_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
ceil_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ceil(
    *$(at::Tensor* _self)));
  }|]

ceil__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
ceil__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ceil_(
    *$(at::Tensor* _self)));
  }|]

ceil_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ceil_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ceil_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

chain_matmul_l
  :: Ptr TensorList
  -> IO (Ptr Tensor)
chain_matmul_l _matrices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::chain_matmul(
    *$(std::vector<at::Tensor>* _matrices)));
  }|]

unsafe_chunk_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr TensorList)
unsafe_chunk_tll _self _chunks _dim =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::unsafe_chunk(
    *$(at::Tensor* _self)
  , $(int64_t _chunks)
  , $(int64_t _dim)));
  }|]

unsafe_chunk_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr TensorList)
unsafe_chunk_tl _self _chunks =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::unsafe_chunk(
    *$(at::Tensor* _self)
  , $(int64_t _chunks)));
  }|]

chunk_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr TensorList)
chunk_tll _self _chunks _dim =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::chunk(
    *$(at::Tensor* _self)
  , $(int64_t _chunks)
  , $(int64_t _dim)));
  }|]

chunk_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr TensorList)
chunk_tl _self _chunks =
  [C.throwBlock| std::vector<at::Tensor>* { return new std::vector<at::Tensor>(at::chunk(
    *$(at::Tensor* _self)
  , $(int64_t _chunks)));
  }|]

clamp_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_tss _self _min _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

clamp_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_ts _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clamp_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
clamp_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp(
    *$(at::Tensor* _self)));
  }|]

clamp__tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp__tss _self _min _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

clamp__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp__ts _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clamp__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
clamp__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_(
    *$(at::Tensor* _self)));
  }|]

clamp_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_out_ttss _out _self _min _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

clamp_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_out_tts _out _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clamp_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
clamp_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

clamp_max_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_max_ts _self _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_max(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _max)));
  }|]

clamp_max__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_max__ts _self _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_max_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _max)));
  }|]

clamp_max_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_max_out_tts _out _self _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_max_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _max)));
  }|]

clamp_min_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_min_ts _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_min(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clamp_min__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_min__ts _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_min_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clamp_min_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_min_out_tts _out _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clamp_min_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clip_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clip_tss _self _min _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clip(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

clip_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clip_ts _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clip(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clip_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
clip_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clip(
    *$(at::Tensor* _self)));
  }|]

clip__tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clip__tss _self _min _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clip_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

clip__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clip__ts _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clip_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clip__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
clip__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clip_(
    *$(at::Tensor* _self)));
  }|]

clip_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clip_out_ttss _out _self _min _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clip_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

clip_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clip_out_tts _out _self _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clip_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clip_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
clip_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::clip_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

cudnn_is_acceptable_t
  :: Ptr Tensor
  -> IO (CBool)
cudnn_is_acceptable_t _self =
  [C.throwBlock| bool { return (at::cudnn_is_acceptable(
    *$(at::Tensor* _self)));
  }|]

complex_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
complex_tt _real _imag =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::complex(
    *$(at::Tensor* _real)
  , *$(at::Tensor* _imag)));
  }|]

complex_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
complex_out_ttt _out _real _imag =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::complex_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _real)
  , *$(at::Tensor* _imag)));
  }|]

polar_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
polar_tt _abs _angle =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::polar(
    *$(at::Tensor* _abs)
  , *$(at::Tensor* _angle)));
  }|]

polar_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
polar_out_ttt _out _abs _angle =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::polar_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _abs)
  , *$(at::Tensor* _angle)));
  }|]

constant_pad_nd_tls
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Scalar
  -> IO (Ptr Tensor)
constant_pad_nd_tls _self _pad _value =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::constant_pad_nd(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _pad)
  , *$(at::Scalar* _value)));
  }|]

constant_pad_nd_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
constant_pad_nd_tl _self _pad =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::constant_pad_nd(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _pad)));
  }|]

convolution_tttlllbll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
convolution_tttlllbll _input _weight _bias _stride _padding _dilation _transposed _output_padding _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::convolution(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)));
  }|]

convolution_overrideable_tttlllbll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
convolution_overrideable_tttlllbll _input _weight _bias _stride _padding _dilation _transposed _output_padding _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::convolution_overrideable(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)));
  }|]

convolution_backward_overrideable_tttlllblla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
convolution_backward_overrideable_tttlllblla _grad_output _input _weight _stride _padding _dilation _transposed _output_padding _groups _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::convolution_backward_overrideable(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

_convolution_tttlllbllbbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
_convolution_tttlllbllbbbb _input _weight _bias _stride _padding _dilation _transposed _output_padding _groups _benchmark _deterministic _cudnn_enabled _allow_tf32 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_convolution(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , $(bool _cudnn_enabled)
  , $(bool _allow_tf32)));
  }|]

_convolution_tttlllbllbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
_convolution_tttlllbllbbb _input _weight _bias _stride _padding _dilation _transposed _output_padding _groups _benchmark _deterministic _cudnn_enabled =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_convolution(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , $(bool _cudnn_enabled)));
  }|]

_convolution_nogroup_tttlllbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_convolution_nogroup_tttlllbl _input _weight _bias _stride _padding _dilation _transposed _output_padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_convolution_nogroup(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)));
  }|]

_convolution_double_backward_ttttttlllbllbbbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> CBool
  -> CBool
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_convolution_double_backward_ttttttlllbllbbbba _ggI _ggW _ggb _gO _weight _self _stride _padding _dilation _transposed _output_padding _groups _benchmark _deterministic _cudnn_enabled _allow_tf32 _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_convolution_double_backward(
    *$(at::Tensor* _ggI)
  , *$(at::Tensor* _ggW)
  , *$(at::Tensor* _ggb)
  , *$(at::Tensor* _gO)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , $(bool _cudnn_enabled)
  , $(bool _allow_tf32)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

conv1d_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
conv1d_tttllll _input _weight _bias _stride _padding _dilation _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)));
  }|]

conv1d_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv1d_tttlll _input _weight _bias _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

conv1d_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv1d_tttll _input _weight _bias _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

conv1d_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv1d_tttl _input _weight _bias _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)));
  }|]

conv1d_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv1d_ttt _input _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

conv1d_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
conv1d_tt _input _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)));
  }|]

conv2d_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
conv2d_tttllll _input _weight _bias _stride _padding _dilation _groups =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::conv2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)));
  }|]

