
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Torch.Internal.Unmanaged.Native.Native4 where


import Foreign.C.String
import Foreign.C.Types
import Foreign
import Torch.Internal.Type


import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<vector>"
C.include "<ATen/Tensor.h>"
C.include "<ATen/Functions.h>"


_index_put_impl__tlt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_index_put_impl__tlt _self _indices _values =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_index_put_impl_(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Tensor>* _indices)
  , *$(at::Tensor* _values)));
  }|]

instance_norm_tttttbddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
instance_norm_tttttbddb _input _weight _bias _running_mean _running_var _use_input_stats _momentum _eps _cudnn_enabled =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::instance_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _use_input_stats)
  , $(double _momentum)
  , $(double _eps)
  , $(bool _cudnn_enabled)));
  }|]

inverse_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
inverse_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::inverse(
    *$(at::Tensor* _self)));
  }|]

inverse_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
inverse_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::inverse_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_inverse_helper_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_inverse_helper_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_inverse_helper(
    *$(at::Tensor* _self)));
  }|]

isclose_ttddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
isclose_ttddb _self _other _rtol _atol _equal_nan =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::isclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)
  , $(double _atol)
  , $(bool _equal_nan)));
  }|]

isclose_ttdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
isclose_ttdd _self _other _rtol _atol =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::isclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)
  , $(double _atol)));
  }|]

isclose_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
isclose_ttd _self _other _rtol =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::isclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)));
  }|]

isclose_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
isclose_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::isclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

isnan_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
isnan_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::isnan(
    *$(at::Tensor* _self)));
  }|]

is_distributed_t
  :: Ptr Tensor
  -> IO (CBool)
is_distributed_t _self =
  [C.throwBlock| bool { return (at::is_distributed(
    *$(at::Tensor* _self)));
  }|]

is_floating_point_t
  :: Ptr Tensor
  -> IO (CBool)
is_floating_point_t _self =
  [C.throwBlock| bool { return (at::is_floating_point(
    *$(at::Tensor* _self)));
  }|]

is_complex_t
  :: Ptr Tensor
  -> IO (CBool)
is_complex_t _self =
  [C.throwBlock| bool { return (at::is_complex(
    *$(at::Tensor* _self)));
  }|]

is_nonzero_t
  :: Ptr Tensor
  -> IO (CBool)
is_nonzero_t _self =
  [C.throwBlock| bool { return (at::is_nonzero(
    *$(at::Tensor* _self)));
  }|]

is_same_size_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (CBool)
is_same_size_tt _self _other =
  [C.throwBlock| bool { return (at::is_same_size(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

is_signed_t
  :: Ptr Tensor
  -> IO (CBool)
is_signed_t _self =
  [C.throwBlock| bool { return (at::is_signed(
    *$(at::Tensor* _self)));
  }|]

kl_div_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
kl_div_ttl _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::kl_div(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

kl_div_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
kl_div_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::kl_div(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

kl_div_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
kl_div_backward_tttl _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::kl_div_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

kl_div_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
kl_div_backward_ttt _grad_output _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::kl_div_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

kthvalue_tllb
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_tllb _self _k _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

kthvalue_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_tll _self _k _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)));
  }|]

kthvalue_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_tl _self _k =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue(
    *$(at::Tensor* _self)
  , $(int64_t _k)));
  }|]

kthvalue_out_tttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_out_tttllb _values _indices _self _k _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

kthvalue_out_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_out_tttll _values _indices _self _k _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)));
  }|]

kthvalue_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_out_tttl _values _indices _self _k =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)));
  }|]

kthvalue_tlnb
  :: Ptr Tensor
  -> Int64
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_tlnb _self _k _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

kthvalue_tln
  :: Ptr Tensor
  -> Int64
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_tln _self _k _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , *$(at::Dimname* _dim)));
  }|]

kthvalue_out_tttlnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_out_tttlnb _values _indices _self _k _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

kthvalue_out_tttln
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
kthvalue_out_tttln _values _indices _self _k _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , *$(at::Dimname* _dim)));
  }|]

layer_norm_tlttdb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
layer_norm_tlttdb _input _normalized_shape _weight _bias _eps _cudnn_enable =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::layer_norm(
    *$(at::Tensor* _input)
  , *$(std::vector<int64_t>* _normalized_shape)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(double _eps)
  , $(bool _cudnn_enable)));
  }|]

layer_norm_tlttd
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
layer_norm_tlttd _input _normalized_shape _weight _bias _eps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::layer_norm(
    *$(at::Tensor* _input)
  , *$(std::vector<int64_t>* _normalized_shape)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(double _eps)));
  }|]

layer_norm_tltt
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
layer_norm_tltt _input _normalized_shape _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::layer_norm(
    *$(at::Tensor* _input)
  , *$(std::vector<int64_t>* _normalized_shape)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

layer_norm_tlt
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
layer_norm_tlt _input _normalized_shape _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::layer_norm(
    *$(at::Tensor* _input)
  , *$(std::vector<int64_t>* _normalized_shape)
  , *$(at::Tensor* _weight)));
  }|]

layer_norm_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
layer_norm_tl _input _normalized_shape =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::layer_norm(
    *$(at::Tensor* _input)
  , *$(std::vector<int64_t>* _normalized_shape)));
  }|]

native_layer_norm_tttlld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CDouble
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
native_layer_norm_tttlld _input _weight _bias _M _N _eps =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native_layer_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(int64_t _M)
  , $(int64_t _N)
  , $(double _eps)));
  }|]

native_layer_norm_backward_tttttlla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr (StdArray '(CBool,3))
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
native_layer_norm_backward_tttttlla _grad_out _input _mean _rstd _weight _M _N _output_mask =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native_layer_norm_backward(
    *$(at::Tensor* _grad_out)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _rstd)
  , *$(at::Tensor* _weight)
  , $(int64_t _M)
  , $(int64_t _N)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

linear_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
linear_ttt _input _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linear(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

linear_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
linear_tt _input _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linear(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)));
  }|]

mkldnn_linear_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mkldnn_linear_ttt _input _weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_linear(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

mkldnn_linear_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mkldnn_linear_tt _input _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_linear(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)));
  }|]

fbgemm_linear_int8_weight_fp32_activation_ttttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_linear_int8_weight_fp32_activation_ttttsst _input _weight _packed _col_offsets _weight_scale _weight_zero_point _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_linear_int8_weight_fp32_activation(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _packed)
  , *$(at::Tensor* _col_offsets)
  , *$(at::Scalar* _weight_scale)
  , *$(at::Scalar* _weight_zero_point)
  , *$(at::Tensor* _bias)));
  }|]

fbgemm_linear_int8_weight_ttttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_linear_int8_weight_ttttsst _input _weight _packed _col_offsets _weight_scale _weight_zero_point _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_linear_int8_weight(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _packed)
  , *$(at::Tensor* _col_offsets)
  , *$(at::Scalar* _weight_scale)
  , *$(at::Scalar* _weight_zero_point)
  , *$(at::Tensor* _bias)));
  }|]

fbgemm_linear_quantize_weight_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,CDouble,Int64)))
fbgemm_linear_quantize_weight_t _input =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,double,int64_t>* { return new std::tuple<at::Tensor,at::Tensor,double,int64_t>(at::fbgemm_linear_quantize_weight(
    *$(at::Tensor* _input)));
  }|]

fbgemm_pack_gemm_matrix_fp16_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_pack_gemm_matrix_fp16_t _input =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_pack_gemm_matrix_fp16(
    *$(at::Tensor* _input)));
  }|]

fbgemm_linear_fp16_weight_fp32_activation_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_linear_fp16_weight_fp32_activation_ttt _input _packed_weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_linear_fp16_weight_fp32_activation(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _packed_weight)
  , *$(at::Tensor* _bias)));
  }|]

fbgemm_linear_fp16_weight_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_linear_fp16_weight_ttt _input _packed_weight _bias =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_linear_fp16_weight(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _packed_weight)
  , *$(at::Tensor* _bias)));
  }|]

fbgemm_pack_quantized_matrix_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_pack_quantized_matrix_t _input =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_pack_quantized_matrix(
    *$(at::Tensor* _input)));
  }|]

fbgemm_pack_quantized_matrix_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
fbgemm_pack_quantized_matrix_tll _input _K _N =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fbgemm_pack_quantized_matrix(
    *$(at::Tensor* _input)
  , $(int64_t _K)
  , $(int64_t _N)));
  }|]

linspace_sslo
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
linspace_sslo _start _end _steps _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)
  , *$(at::TensorOptions* _options)));
  }|]

linspace_ssl
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> IO (Ptr Tensor)
linspace_ssl _start _end _steps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)));
  }|]

linspace_ss
  :: Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
linspace_ss _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

linspace_out_tssl
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> IO (Ptr Tensor)
linspace_out_tssl _out _start _end _steps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linspace_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)));
  }|]

linspace_out_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
linspace_out_tss _out _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::linspace_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

log_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log(
    *$(at::Tensor* _self)));
  }|]

log__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_(
    *$(at::Tensor* _self)));
  }|]

log_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

log10_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log10_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log10(
    *$(at::Tensor* _self)));
  }|]

log10__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log10__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log10_(
    *$(at::Tensor* _self)));
  }|]

log10_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log10_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log10_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

log1p_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log1p_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log1p(
    *$(at::Tensor* _self)));
  }|]

log1p__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log1p__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log1p_(
    *$(at::Tensor* _self)));
  }|]

log1p_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log1p_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log1p_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

log2_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log2_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log2(
    *$(at::Tensor* _self)));
  }|]

log2__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log2__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log2_(
    *$(at::Tensor* _self)));
  }|]

log2_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log2_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log2_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

logdet_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
logdet_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logdet(
    *$(at::Tensor* _self)));
  }|]

logspace_ssldo
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> CDouble
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
logspace_ssldo _start _end _steps _base _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)
  , $(double _base)
  , *$(at::TensorOptions* _options)));
  }|]

logspace_ssld
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> CDouble
  -> IO (Ptr Tensor)
logspace_ssld _start _end _steps _base =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)
  , $(double _base)));
  }|]

logspace_ssl
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> IO (Ptr Tensor)
logspace_ssl _start _end _steps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)));
  }|]

logspace_ss
  :: Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
logspace_ss _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

logspace_out_tssld
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> CDouble
  -> IO (Ptr Tensor)
logspace_out_tssld _out _start _end _steps _base =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)
  , $(double _base)));
  }|]

logspace_out_tssl
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> IO (Ptr Tensor)
logspace_out_tssl _out _start _end _steps =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)));
  }|]

logspace_out_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
logspace_out_tss _out _start _end =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logspace_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)));
  }|]

log_softmax_tls
  :: Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
log_softmax_tls _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

log_softmax_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
log_softmax_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

log_softmax_tns
  :: Ptr Tensor
  -> Ptr Dimname
  -> ScalarType
  -> IO (Ptr Tensor)
log_softmax_tns _self _dim _dtype =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_softmax(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(at::ScalarType _dtype)));
  }|]

log_softmax_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
log_softmax_tn _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_softmax(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

_log_softmax_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
_log_softmax_tlb _self _dim _half_to_float =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_log_softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _half_to_float)));
  }|]

_log_softmax_backward_data_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_log_softmax_backward_data_ttlt _grad_output _output _dim _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_log_softmax_backward_data(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)
  , $(int64_t _dim)
  , *$(at::Tensor* _self)));
  }|]

logsumexp_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
logsumexp_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

logsumexp_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
logsumexp_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

logsumexp_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
logsumexp_out_ttlb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

logsumexp_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
logsumexp_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

logsumexp_tNb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
logsumexp_tNb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)));
  }|]

logsumexp_tN
  :: Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
logsumexp_tN _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

logsumexp_out_ttNb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
logsumexp_out_ttNb _out _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)));
  }|]

logsumexp_out_ttN
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
logsumexp_out_ttN _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::logsumexp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

margin_ranking_loss_tttdl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
margin_ranking_loss_tttdl _input1 _input2 _target _margin _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::margin_ranking_loss(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _target)
  , $(double _margin)
  , $(int64_t _reduction)));
  }|]

margin_ranking_loss_tttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
margin_ranking_loss_tttd _input1 _input2 _target _margin =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::margin_ranking_loss(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _target)
  , $(double _margin)));
  }|]

margin_ranking_loss_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
margin_ranking_loss_ttt _input1 _input2 _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::margin_ranking_loss(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _target)));
  }|]

matmul_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
matmul_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matmul(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

matmul_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
matmul_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matmul_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

matrix_rank_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
matrix_rank_tdb _self _tol _symmetric =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matrix_rank(
    *$(at::Tensor* _self)
  , $(double _tol)
  , $(bool _symmetric)));
  }|]

matrix_rank_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
matrix_rank_td _self _tol =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matrix_rank(
    *$(at::Tensor* _self)
  , $(double _tol)));
  }|]

matrix_rank_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
matrix_rank_tb _self _symmetric =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matrix_rank(
    *$(at::Tensor* _self)
  , $(bool _symmetric)));
  }|]

matrix_rank_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
matrix_rank_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matrix_rank(
    *$(at::Tensor* _self)));
  }|]

matrix_power_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
matrix_power_tl _self _n =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::matrix_power(
    *$(at::Tensor* _self)
  , $(int64_t _n)));
  }|]

max_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_tlb _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

max_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

max_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_out_tttlb _max _max_values _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_out(
    *$(at::Tensor* _max)
  , *$(at::Tensor* _max_values)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

max_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_out_tttl _max _max_values _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_out(
    *$(at::Tensor* _max)
  , *$(at::Tensor* _max_values)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

max_values_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
max_values_tlb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_values(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

max_values_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_values_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_values(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

max_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_tnb _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

max_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_tn _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

max_out_tttnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_out_tttnb _max _max_values _self _dim _keepdim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_out(
    *$(at::Tensor* _max)
  , *$(at::Tensor* _max_values)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _keepdim)));
  }|]

max_out_tttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_out_tttn _max _max_values _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_out(
    *$(at::Tensor* _max)
  , *$(at::Tensor* _max_values)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

max_values_tNb
  :: Ptr Tensor
  -> Ptr DimnameList
  -> CBool
  -> IO (Ptr Tensor)
max_values_tNb _self _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_values(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)
  , $(bool _keepdim)));
  }|]

max_values_tN
  :: Ptr Tensor
  -> Ptr DimnameList
  -> IO (Ptr Tensor)
max_values_tN _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_values(
    *$(at::Tensor* _self)
  , *$(std::vector<at::Dimname>* _dim)));
  }|]

max_pool1d_with_indices_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool1d_with_indices_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool1d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool1d_with_indices_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool1d_with_indices_tllll _self _kernel_size _stride _padding _dilation =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool1d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

max_pool1d_with_indices_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool1d_with_indices_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool1d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_pool1d_with_indices_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool1d_with_indices_tll _self _kernel_size _stride =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool1d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

max_pool1d_with_indices_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
max_pool1d_with_indices_tl _self _kernel_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool1d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

max_pool1d_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
max_pool1d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool1d_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool1d_tllll _self _kernel_size _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

max_pool1d_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool1d_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_pool1d_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool1d_tll _self _kernel_size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

max_pool1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool1d_tl _self _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]

max_pool2d_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
max_pool2d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool2d_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool2d_tllll _self _kernel_size _stride _padding _dilation =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

max_pool2d_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool2d_tlll _self _kernel_size _stride _padding =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_pool2d_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool2d_tll _self _kernel_size _stride =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)));
  }|]

max_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_pool2d_tl _self _kernel_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)));
  }|]
