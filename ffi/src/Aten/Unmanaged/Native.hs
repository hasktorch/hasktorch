
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Aten.Unmanaged.Native where


import Foreign.C.String
import Foreign.C.Types
import Foreign
import Aten.Type
import Aten.Class

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<ATen/ATen.h>"
C.include "<vector>"


_cast_Byte_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Byte_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::_cast_Byte(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Char_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Char_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::_cast_Char(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Double_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Double_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::_cast_Double(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Float_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Float_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::_cast_Float(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Int_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Int_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::_cast_Int(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Long_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Long_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::_cast_Long(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Short_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Short_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::_cast_Short(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Half_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Half_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::_cast_Half(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cudnn_ctc_loss_ttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
_cudnn_ctc_loss_ttlllbb _log_probs _targets _input_lengths _target_lengths _blank _deterministic _zero_infinity =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_cudnn_ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , $(int64_t _blank)
  , $(bool _deterministic)
  , $(bool _zero_infinity)));
  }|]

_cudnn_rnn_flatten_weight_llllllbb
  :: Ptr TensorList
  -> Int64
  -> Int64
  -> Int64
  -> Int64
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
_cudnn_rnn_flatten_weight_llllllbb _weight_arr _weight_stride0 _input_size _mode _hidden_size _num_layers _batch_first _bidirectional =
  [C.block| at::Tensor* { return new at::Tensor(at::_cudnn_rnn_flatten_weight(
    *$(at::TensorList* _weight_arr)
  , $(int64_t _weight_stride0)
  , $(int64_t _input_size)
  , $(int64_t _mode)
  , $(int64_t _hidden_size)
  , $(int64_t _num_layers)
  , $(bool _batch_first)
  , $(bool _bidirectional)));
  }|]

_cudnn_rnn_tlltttlllbdbblt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> CBool
  -> CDouble
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor,Tensor,Tensor))
_cudnn_rnn_tlltttlllbdbblt _input _weight _weight_stride0 _weight_buf _hx _cx _mode _hidden_size _num_layers _batch_first _dropout _train _bidirectional _batch_sizes _dropout_state =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_cudnn_rnn(
    *$(at::Tensor* _input)
  , *$(at::TensorList* _weight)
  , $(int64_t _weight_stride0)
  , *$(at::Tensor* _weight_buf)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _cx)
  , $(int64_t _mode)
  , $(int64_t _hidden_size)
  , $(int64_t _num_layers)
  , $(bool _batch_first)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , *$(std::vector<int64_t>* _batch_sizes)
  , *$(at::Tensor* _dropout_state)));
  }|]

_cudnn_rnn_backward_tlltttttttlllbdbbltta
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> CBool
  -> CDouble
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray CBool 4)
  -> IO (Ptr (Tensor,Tensor,Tensor,TensorList))
_cudnn_rnn_backward_tlltttttttlllbdbbltta _input _weight _weight_stride0 _weight_buf _hx _cx _output _grad_output _grad_hy _grad_cy _mode _hidden_size _num_layers _batch_first _dropout _train _bidirectional _batch_sizes _dropout_state _reserve _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::TensorList>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::TensorList>(at::_cudnn_rnn_backward(
    *$(at::Tensor* _input)
  , *$(at::TensorList* _weight)
  , $(int64_t _weight_stride0)
  , *$(at::Tensor* _weight_buf)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _output)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _grad_cy)
  , $(int64_t _mode)
  , $(int64_t _hidden_size)
  , $(int64_t _num_layers)
  , $(bool _batch_first)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , *$(std::vector<int64_t>* _batch_sizes)
  , *$(at::Tensor* _dropout_state)
  , *$(at::Tensor* _reserve)
  , *$(std::array<bool,4>* _output_mask)));
  }|]

_cudnn_init_dropout_state_dblo
  :: CDouble
  -> CBool
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_cudnn_init_dropout_state_dblo _dropout _train _dropout_seed _options =
  [C.block| at::Tensor* { return new at::Tensor(at::_cudnn_init_dropout_state(
    $(double _dropout)
  , $(bool _train)
  , $(int64_t _dropout_seed)
  , *$(at::TensorOptions* _options)));
  }|]

_debug_has_internal_overlap_t
  :: Ptr Tensor
  -> IO (Int64)
_debug_has_internal_overlap_t _self =
  [C.block| int64_t { return (at::_debug_has_internal_overlap(
    *$(at::Tensor* _self)));
  }|]

_fused_dropout_tdp
  :: Ptr Tensor
  -> CDouble
  -> Ptr Generator
  -> IO (Ptr (Tensor,Tensor))
_fused_dropout_tdp _self _p _generator =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_fused_dropout(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(at::Generator * _generator)));
  }|]

_masked_scale_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
_masked_scale_ttd _self _mask _scale =
  [C.block| at::Tensor* { return new at::Tensor(at::_masked_scale(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , $(double _scale)));
  }|]

_reshape_from_tensor_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_reshape_from_tensor_tt _self _shape =
  [C.block| at::Tensor* { return new at::Tensor(at::_reshape_from_tensor(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _shape)));
  }|]

_shape_as_tensor_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_shape_as_tensor_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::_shape_as_tensor(
    *$(at::Tensor* _self)));
  }|]

dropout_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
dropout_tdb _input _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::dropout(
    *$(at::Tensor* _input)
  , $(double _p)
  , $(bool _train)));
  }|]

dropout__tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
dropout__tdb _self _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::dropout_(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(bool _train)));
  }|]

feature_dropout_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
feature_dropout_tdb _input _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::feature_dropout(
    *$(at::Tensor* _input)
  , $(double _p)
  , $(bool _train)));
  }|]

feature_dropout__tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
feature_dropout__tdb _self _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::feature_dropout_(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(bool _train)));
  }|]

alpha_dropout_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
alpha_dropout_tdb _input _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::alpha_dropout(
    *$(at::Tensor* _input)
  , $(double _p)
  , $(bool _train)));
  }|]

alpha_dropout__tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
alpha_dropout__tdb _self _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::alpha_dropout_(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(bool _train)));
  }|]

feature_alpha_dropout_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
feature_alpha_dropout_tdb _input _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::feature_alpha_dropout(
    *$(at::Tensor* _input)
  , $(double _p)
  , $(bool _train)));
  }|]

feature_alpha_dropout__tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
feature_alpha_dropout__tdb _self _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::feature_alpha_dropout_(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(bool _train)));
  }|]

abs_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
abs_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::abs(
    *$(at::Tensor* _self)));
  }|]

abs__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
abs__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::abs_(
    *$(at::Tensor* _self)));
  }|]

abs_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
abs_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::abs_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

acos_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
acos_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::acos(
    *$(at::Tensor* _self)));
  }|]

acos__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
acos__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::acos_(
    *$(at::Tensor* _self)));
  }|]

acos_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
acos_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::acos_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

avg_pool1d_tlllbb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool1d_tlllbb _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

adaptive_avg_pool1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool1d_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool1d_tl _self _output_size =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

add_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_tts _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::add(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

add_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_out_ttts _out _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::add_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

add_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_tss _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::add(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

addmv_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv_tttss _self _mat _vec _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::addmv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmv__tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv__tttss _self _mat _vec _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::addmv_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmv_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv_out_ttttss _out _self _mat _vec _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::addmv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addr_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addr_tttss _self _vec1 _vec2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::addr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addr_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addr_out_ttttss _out _self _vec1 _vec2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::addr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

affine_grid_generator_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
affine_grid_generator_tl _theta _size =
  [C.block| at::Tensor* { return new at::Tensor(at::affine_grid_generator(
    *$(at::Tensor* _theta)
  , *$(std::vector<int64_t>* _size)));
  }|]

affine_grid_generator_backward_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
affine_grid_generator_backward_tl _grad _size =
  [C.block| at::Tensor* { return new at::Tensor(at::affine_grid_generator_backward(
    *$(at::Tensor* _grad)
  , *$(std::vector<int64_t>* _size)));
  }|]

all_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
all_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::all(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

all_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
all_out_ttlb _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::all_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

allclose_ttddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (CBool)
allclose_ttddb _self _other _rtol _atol _equal_nan =
  [C.block| bool { return (at::allclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)
  , $(double _atol)
  , $(bool _equal_nan)));
  }|]

any_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
any_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::any(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

any_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
any_out_ttlb _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::any_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

arange_so
  :: Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_so _end _options =
  [C.block| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _end)
  , *$(at::TensorOptions* _options)));
  }|]

arange_sso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_sso _start _end _options =
  [C.block| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::TensorOptions* _options)));
  }|]

arange_ssso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_ssso _start _end _step _options =
  [C.block| at::Tensor* { return new at::Tensor(at::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)
  , *$(at::TensorOptions* _options)));
  }|]

arange_out_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_out_ts _out _end =
  [C.block| at::Tensor* { return new at::Tensor(at::arange_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _end)));
  }|]

arange_out_tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_out_tsss _out _start _end _step =
  [C.block| at::Tensor* { return new at::Tensor(at::arange_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)));
  }|]

_dim_arange_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_dim_arange_tl _like _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::_dim_arange(
    *$(at::Tensor* _like)
  , $(int64_t _dim)));
  }|]

argmax_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
argmax_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::argmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

argmax_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
argmax_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::argmax(
    *$(at::Tensor* _self)));
  }|]

_argmax_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
_argmax_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::_argmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

argmin_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
argmin_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::argmin(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

argmin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
argmin_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::argmin(
    *$(at::Tensor* _self)));
  }|]

_argmin_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
_argmin_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::_argmin(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

as_strided_tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
as_strided_tlll _self _size _stride _storage_offset =
  [C.block| at::Tensor* { return new at::Tensor(at::as_strided(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)
  , $(int64_t _storage_offset)));
  }|]

as_strided__tlll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
as_strided__tlll _self _size _stride _storage_offset =
  [C.block| at::Tensor* { return new at::Tensor(at::as_strided_(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)
  , $(int64_t _storage_offset)));
  }|]

asin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
asin_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::asin(
    *$(at::Tensor* _self)));
  }|]

asin__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
asin__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::asin_(
    *$(at::Tensor* _self)));
  }|]

asin_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
asin_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::asin_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

atan_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
atan_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::atan(
    *$(at::Tensor* _self)));
  }|]

atan__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
atan__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::atan_(
    *$(at::Tensor* _self)));
  }|]

atan_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
atan_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::atan_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

baddbmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
baddbmm_tttss _self _batch1 _batch2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::baddbmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

_baddbmm_mkl__tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_baddbmm_mkl__tttss _self _batch1 _batch2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::_baddbmm_mkl_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

baddbmm_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
baddbmm_out_ttttss _out _self _batch1 _batch2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::baddbmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

bartlett_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
bartlett_window_lo _window_length _options =
  [C.block| at::Tensor* { return new at::Tensor(at::bartlett_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

bartlett_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
bartlett_window_lbo _window_length _periodic _options =
  [C.block| at::Tensor* { return new at::Tensor(at::bartlett_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

batch_norm_tttttbddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
batch_norm_tttttbddb _input _weight _bias _running_mean _running_var _training _momentum _eps _cudnn_enabled =
  [C.block| at::Tensor* { return new at::Tensor(at::batch_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(double _momentum)
  , $(double _eps)
  , $(bool _cudnn_enabled)));
  }|]

_batch_norm_impl_index_tttttbddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor,Int64))
_batch_norm_impl_index_tttttbddb _input _weight _bias _running_mean _running_var _training _momentum _eps _cudnn_enabled =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,int64_t>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,int64_t>(at::_batch_norm_impl_index(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(double _momentum)
  , $(double _eps)
  , $(bool _cudnn_enabled)));
  }|]

_batch_norm_impl_index_backward_ltttttttbda
  :: Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
_batch_norm_impl_index_backward_ltttttttbda _impl_index _input _grad_output _weight _running_mean _running_var _save_mean _save_var_transform _train _eps _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_batch_norm_impl_index_backward(
    $(int64_t _impl_index)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , *$(at::Tensor* _save_mean)
  , *$(at::Tensor* _save_var_transform)
  , $(bool _train)
  , $(double _eps)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

bernoulli_tp
  :: Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_tp _self _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::bernoulli(
    *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

bernoulli_out_ttp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_out_ttp _out _self _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::bernoulli_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

bernoulli_tdp
  :: Ptr Tensor
  -> CDouble
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_tdp _self _p _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::bernoulli(
    *$(at::Tensor* _self)
  , $(double _p)
  , $(at::Generator * _generator)));
  }|]

bilinear_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bilinear_tttt _input1 _input2 _weight _bias =
  [C.block| at::Tensor* { return new at::Tensor(at::bilinear(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

binary_cross_entropy_with_logits_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_ttttl _self _target _weight _pos_weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _pos_weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_with_logits_backward_tttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_backward_tttttl _grad_output _self _target _weight _pos_weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_with_logits_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _pos_weight)
  , $(int64_t _reduction)));
  }|]

bincount_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
bincount_ttl _self _weights _minlength =
  [C.block| at::Tensor* { return new at::Tensor(at::bincount(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weights)
  , $(int64_t _minlength)));
  }|]

blackman_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
blackman_window_lo _window_length _options =
  [C.block| at::Tensor* { return new at::Tensor(at::blackman_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

blackman_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
blackman_window_lbo _window_length _periodic _options =
  [C.block| at::Tensor* { return new at::Tensor(at::blackman_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

bmm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bmm_tt _self _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::bmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

bmm_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bmm_out_ttt _out _self _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::bmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

broadcast_tensors_l
  :: Ptr TensorList
  -> IO (Ptr TensorList)
broadcast_tensors_l _tensors =
  [C.block| at::TensorList* { return new at::TensorList(at::broadcast_tensors(
    *$(at::TensorList* _tensors)));
  }|]

cat_ll
  :: Ptr TensorList
  -> Int64
  -> IO (Ptr Tensor)
cat_ll _tensors _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::cat(
    *$(at::TensorList* _tensors)
  , $(int64_t _dim)));
  }|]

cat_out_tll
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> IO (Ptr Tensor)
cat_out_tll _out _tensors _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::cat_out(
    *$(at::Tensor* _out)
  , *$(at::TensorList* _tensors)
  , $(int64_t _dim)));
  }|]

ceil_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
ceil_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::ceil(
    *$(at::Tensor* _self)));
  }|]

ceil__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
ceil__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::ceil_(
    *$(at::Tensor* _self)));
  }|]

ceil_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ceil_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::ceil_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

chain_matmul_l
  :: Ptr TensorList
  -> IO (Ptr Tensor)
chain_matmul_l _matrices =
  [C.block| at::Tensor* { return new at::Tensor(at::chain_matmul(
    *$(at::TensorList* _matrices)));
  }|]

chunk_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr TensorList)
chunk_tll _self _chunks _dim =
  [C.block| at::TensorList* { return new at::TensorList(at::chunk(
    *$(at::Tensor* _self)
  , $(int64_t _chunks)
  , $(int64_t _dim)));
  }|]

clamp_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_tss _self _min _max =
  [C.block| at::Tensor* { return new at::Tensor(at::clamp(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

clamp__tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp__tss _self _min _max =
  [C.block| at::Tensor* { return new at::Tensor(at::clamp_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

clamp_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_out_ttss _out _self _min _max =
  [C.block| at::Tensor* { return new at::Tensor(at::clamp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

clamp_max_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_max_ts _self _max =
  [C.block| at::Tensor* { return new at::Tensor(at::clamp_max(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _max)));
  }|]

clamp_max__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_max__ts _self _max =
  [C.block| at::Tensor* { return new at::Tensor(at::clamp_max_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _max)));
  }|]

clamp_max_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_max_out_tts _out _self _max =
  [C.block| at::Tensor* { return new at::Tensor(at::clamp_max_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _max)));
  }|]

clamp_min_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_min_ts _self _min =
  [C.block| at::Tensor* { return new at::Tensor(at::clamp_min(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clamp_min__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_min__ts _self _min =
  [C.block| at::Tensor* { return new at::Tensor(at::clamp_min_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

clamp_min_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_min_out_tts _out _self _min =
  [C.block| at::Tensor* { return new at::Tensor(at::clamp_min_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

cudnn_is_acceptable_t
  :: Ptr Tensor
  -> IO (CBool)
cudnn_is_acceptable_t _self =
  [C.block| bool { return (at::cudnn_is_acceptable(
    *$(at::Tensor* _self)));
  }|]

constant_pad_nd_tls
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Scalar
  -> IO (Ptr Tensor)
constant_pad_nd_tls _self _pad _value =
  [C.block| at::Tensor* { return new at::Tensor(at::constant_pad_nd(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _pad)
  , *$(at::Scalar* _value)));
  }|]

convolution_tttlllbll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
convolution_tttlllbll _input _weight _bias _stride _padding _dilation _transposed _output_padding _groups =
  [C.block| at::Tensor* { return new at::Tensor(at::convolution(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)));
  }|]

_convolution_tttlllbllbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
_convolution_tttlllbllbbb _input _weight _bias _stride _padding _dilation _transposed _output_padding _groups _benchmark _deterministic _cudnn_enabled =
  [C.block| at::Tensor* { return new at::Tensor(at::_convolution(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , $(bool _cudnn_enabled)));
  }|]

_convolution_nogroup_tttlllbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_convolution_nogroup_tttlllbl _input _weight _bias _stride _padding _dilation _transposed _output_padding =
  [C.block| at::Tensor* { return new at::Tensor(at::_convolution_nogroup(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)));
  }|]

_convolution_double_backward_ttttttlllbllbbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> CBool
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
_convolution_double_backward_ttttttlllbllbbba _ggI _ggW _ggb _gO _weight _self _stride _padding _dilation _transposed _output_padding _groups _benchmark _deterministic _cudnn_enabled _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_convolution_double_backward(
    *$(at::Tensor* _ggI)
  , *$(at::Tensor* _ggW)
  , *$(at::Tensor* _ggb)
  , *$(at::Tensor* _gO)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _transposed)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , $(bool _cudnn_enabled)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

conv1d_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
conv1d_tttllll _input _weight _bias _stride _padding _dilation _groups =
  [C.block| at::Tensor* { return new at::Tensor(at::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)));
  }|]

conv2d_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
conv2d_tttllll _input _weight _bias _stride _padding _dilation _groups =
  [C.block| at::Tensor* { return new at::Tensor(at::conv2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)));
  }|]

conv3d_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
conv3d_tttllll _input _weight _bias _stride _padding _dilation _groups =
  [C.block| at::Tensor* { return new at::Tensor(at::conv3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)));
  }|]

conv_tbc_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
conv_tbc_tttl _self _weight _bias _pad =
  [C.block| at::Tensor* { return new at::Tensor(at::conv_tbc(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(int64_t _pad)));
  }|]

conv_tbc_backward_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (Tensor,Tensor,Tensor))
conv_tbc_backward_ttttl _self _input _weight _bias _pad =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::conv_tbc_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(int64_t _pad)));
  }|]

conv_transpose1d_tttlllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose1d_tttlllll _input _weight _bias _stride _padding _output_padding _groups _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::conv_transpose1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

conv_transpose2d_tttlllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose2d_tttlllll _input _weight _bias _stride _padding _output_padding _groups _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::conv_transpose2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

conv_transpose3d_tttlllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
conv_transpose3d_tttlllll _input _weight _bias _stride _padding _output_padding _groups _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::conv_transpose3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , $(int64_t _groups)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

s_copy__ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
s_copy__ttb _self _src _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::s_copy_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _src)
  , $(bool _non_blocking)));
  }|]

_s_copy_from_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_s_copy_from_ttb _self _dst _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::_s_copy_from(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _dst)
  , $(bool _non_blocking)));
  }|]

_copy_same_type__tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (())
_copy_same_type__tt _self _src =
  [C.block| void {  (at::_copy_same_type_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _src)));
  }|]

cos_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cos_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::cos(
    *$(at::Tensor* _self)));
  }|]

cos__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cos__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::cos_(
    *$(at::Tensor* _self)));
  }|]

cos_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cos_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::cos_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

cosh_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cosh_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::cosh(
    *$(at::Tensor* _self)));
  }|]

cosh__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cosh__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::cosh_(
    *$(at::Tensor* _self)));
  }|]

cosh_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cosh_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::cosh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

cosine_embedding_loss_tttdl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
cosine_embedding_loss_tttdl _input1 _input2 _target _margin _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::cosine_embedding_loss(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _target)
  , $(double _margin)
  , $(int64_t _reduction)));
  }|]

cudnn_affine_grid_generator_tllll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
cudnn_affine_grid_generator_tllll _theta _N _C _H _W =
  [C.block| at::Tensor* { return new at::Tensor(at::cudnn_affine_grid_generator(
    *$(at::Tensor* _theta)
  , $(int64_t _N)
  , $(int64_t _C)
  , $(int64_t _H)
  , $(int64_t _W)));
  }|]

cudnn_affine_grid_generator_backward_tllll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
cudnn_affine_grid_generator_backward_tllll _grad _N _C _H _W =
  [C.block| at::Tensor* { return new at::Tensor(at::cudnn_affine_grid_generator_backward(
    *$(at::Tensor* _grad)
  , $(int64_t _N)
  , $(int64_t _C)
  , $(int64_t _H)
  , $(int64_t _W)));
  }|]

cudnn_batch_norm_tttttbdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr (Tensor,Tensor,Tensor))
cudnn_batch_norm_tttttbdd _input _weight _bias _running_mean _running_var _training _exponential_average_factor _epsilon =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::cudnn_batch_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(double _exponential_average_factor)
  , $(double _epsilon)));
  }|]

cudnn_batch_norm_backward_tttttttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr (Tensor,Tensor,Tensor))
cudnn_batch_norm_backward_tttttttd _input _grad_output _weight _running_mean _running_var _save_mean _save_var _epsilon =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::cudnn_batch_norm_backward(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , *$(at::Tensor* _save_mean)
  , *$(at::Tensor* _save_var)
  , $(double _epsilon)));
  }|]

cudnn_convolution_tttllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_tttllllbb _self _weight _bias _padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::cudnn_convolution(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_convolution_backward_input_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_backward_input_lttllllbb _self_size _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::cudnn_convolution_backward_input(
    *$(std::vector<int64_t>* _self_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_convolution_backward_tttllllbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
cudnn_convolution_backward_tttllllbba _self _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::cudnn_convolution_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

cudnn_convolution_backward_bias_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cudnn_convolution_backward_bias_t _grad_output =
  [C.block| at::Tensor* { return new at::Tensor(at::cudnn_convolution_backward_bias(
    *$(at::Tensor* _grad_output)));
  }|]

cudnn_convolution_backward_weight_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_backward_weight_lttllllbb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::cudnn_convolution_backward_weight(
    *$(std::vector<int64_t>* _weight_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_convolution_transpose_tttlllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_transpose_tttlllllbb _self _weight _bias _padding _output_padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::cudnn_convolution_transpose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_convolution_transpose_backward_tttlllllbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
cudnn_convolution_transpose_backward_tttlllllbba _self _grad_output _weight _padding _output_padding _stride _dilation _groups _benchmark _deterministic _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::cudnn_convolution_transpose_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

cudnn_convolution_transpose_backward_bias_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cudnn_convolution_transpose_backward_bias_t _grad_output =
  [C.block| at::Tensor* { return new at::Tensor(at::cudnn_convolution_transpose_backward_bias(
    *$(at::Tensor* _grad_output)));
  }|]

cudnn_convolution_transpose_backward_input_ttllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_transpose_backward_input_ttllllbb _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::cudnn_convolution_transpose_backward_input(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_convolution_transpose_backward_weight_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
cudnn_convolution_transpose_backward_weight_lttllllbb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::cudnn_convolution_transpose_backward_weight(
    *$(std::vector<int64_t>* _weight_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

cudnn_grid_sampler_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
cudnn_grid_sampler_tt _self _grid =
  [C.block| at::Tensor* { return new at::Tensor(at::cudnn_grid_sampler(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grid)));
  }|]

cudnn_grid_sampler_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
cudnn_grid_sampler_backward_ttt _self _grid _grad_output =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::cudnn_grid_sampler_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grid)
  , *$(at::Tensor* _grad_output)));
  }|]

cumsum_tls
  :: Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
cumsum_tls _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::cumsum(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

cumsum_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cumsum_tl _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::cumsum(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

cumsum_out_ttls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
cumsum_out_ttls _out _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::cumsum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

cumsum_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cumsum_out_ttl _out _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::cumsum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

cumprod_tls
  :: Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
cumprod_tls _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::cumprod(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

cumprod_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cumprod_tl _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::cumprod(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

cumprod_out_ttls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
cumprod_out_ttls _out _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::cumprod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

cumprod_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cumprod_out_ttl _out _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::cumprod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

ctc_loss_ttllllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
ctc_loss_ttllllb _log_probs _targets _input_lengths _target_lengths _blank _reduction _zero_infinity =
  [C.block| at::Tensor* { return new at::Tensor(at::ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , $(int64_t _blank)
  , $(int64_t _reduction)
  , $(bool _zero_infinity)));
  }|]

ctc_loss_ttttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
ctc_loss_ttttllb _log_probs _targets _input_lengths _target_lengths _blank _reduction _zero_infinity =
  [C.block| at::Tensor* { return new at::Tensor(at::ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(at::Tensor* _input_lengths)
  , *$(at::Tensor* _target_lengths)
  , $(int64_t _blank)
  , $(int64_t _reduction)
  , $(bool _zero_infinity)));
  }|]

_ctc_loss_ttlllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
_ctc_loss_ttlllb _log_probs _targets _input_lengths _target_lengths _blank _zero_infinity =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , $(int64_t _blank)
  , $(bool _zero_infinity)));
  }|]

_ctc_loss_backward_tttllttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
_ctc_loss_backward_tttllttlb _grad _log_probs _targets _input_lengths _target_lengths _neg_log_likelihood _log_alpha _blank _zero_infinity =
  [C.block| at::Tensor* { return new at::Tensor(at::_ctc_loss_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(std::vector<int64_t>* _input_lengths)
  , *$(std::vector<int64_t>* _target_lengths)
  , *$(at::Tensor* _neg_log_likelihood)
  , *$(at::Tensor* _log_alpha)
  , $(int64_t _blank)
  , $(bool _zero_infinity)));
  }|]

det_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
det_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::det(
    *$(at::Tensor* _self)));
  }|]

diag_embed_tlll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
diag_embed_tlll _self _offset _dim1 _dim2 =
  [C.block| at::Tensor* { return new at::Tensor(at::diag_embed(
    *$(at::Tensor* _self)
  , $(int64_t _offset)
  , $(int64_t _dim1)
  , $(int64_t _dim2)));
  }|]

diagflat_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
diagflat_tl _self _offset =
  [C.block| at::Tensor* { return new at::Tensor(at::diagflat(
    *$(at::Tensor* _self)
  , $(int64_t _offset)));
  }|]

diagonal_tlll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
diagonal_tlll _self _offset _dim1 _dim2 =
  [C.block| at::Tensor* { return new at::Tensor(at::diagonal(
    *$(at::Tensor* _self)
  , $(int64_t _offset)
  , $(int64_t _dim1)
  , $(int64_t _dim2)));
  }|]

div_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
div_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::div(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

div_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
div_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::div_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

div_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
div_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::div(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

dot_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
dot_tt _self _tensor =
  [C.block| at::Tensor* { return new at::Tensor(at::dot(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor)));
  }|]

dot_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
dot_out_ttt _out _self _tensor =
  [C.block| at::Tensor* { return new at::Tensor(at::dot_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor)));
  }|]

einsum_sl
  :: Ptr StdString
  -> Ptr TensorList
  -> IO (Ptr Tensor)
einsum_sl _equation _tensors =
  [C.block| at::Tensor* { return new at::Tensor(at::einsum(
    *$(std::string* _equation)
  , *$(at::TensorList* _tensors)));
  }|]

embedding_ttlbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
embedding_ttlbb _weight _indices _padding_idx _scale_grad_by_freq _sparse =
  [C.block| at::Tensor* { return new at::Tensor(at::embedding(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , $(int64_t _padding_idx)
  , $(bool _scale_grad_by_freq)
  , $(bool _sparse)));
  }|]

embedding_backward_ttllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
embedding_backward_ttllbb _grad _indices _num_weights _padding_idx _scale_grad_by_freq _sparse =
  [C.block| at::Tensor* { return new at::Tensor(at::embedding_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , $(int64_t _num_weights)
  , $(int64_t _padding_idx)
  , $(bool _scale_grad_by_freq)
  , $(bool _sparse)));
  }|]

embedding_dense_backward_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
embedding_dense_backward_ttllb _grad _indices _num_weights _padding_idx _scale_grad_by_freq =
  [C.block| at::Tensor* { return new at::Tensor(at::embedding_dense_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , $(int64_t _num_weights)
  , $(int64_t _padding_idx)
  , $(bool _scale_grad_by_freq)));
  }|]

embedding_renorm__ttdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> IO (Ptr Tensor)
embedding_renorm__ttdd _self _indices _max_norm _norm_type =
  [C.block| at::Tensor* { return new at::Tensor(at::embedding_renorm_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , $(double _max_norm)
  , $(double _norm_type)));
  }|]

embedding_sparse_backward_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
embedding_sparse_backward_ttllb _grad _indices _num_weights _padding_idx _scale_grad_by_freq =
  [C.block| at::Tensor* { return new at::Tensor(at::embedding_sparse_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , $(int64_t _num_weights)
  , $(int64_t _padding_idx)
  , $(bool _scale_grad_by_freq)));
  }|]

embedding_bag_tttblb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor,Tensor))
embedding_bag_tttblb _weight _indices _offsets _scale_grad_by_freq _mode _sparse =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)
  , $(bool _sparse)));
  }|]

_embedding_bag_tttblb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor,Tensor))
_embedding_bag_tttblb _weight _indices _offsets _scale_grad_by_freq _mode _sparse =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)
  , $(bool _sparse)));
  }|]

_embedding_bag_backward_ttttttlblb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
_embedding_bag_backward_ttttttlblb _grad _indices _offsets _offset2bag _bag_size _maximum_indices _num_weights _scale_grad_by_freq _mode _sparse =
  [C.block| at::Tensor* { return new at::Tensor(at::_embedding_bag_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , *$(at::Tensor* _offset2bag)
  , *$(at::Tensor* _bag_size)
  , *$(at::Tensor* _maximum_indices)
  , $(int64_t _num_weights)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)
  , $(bool _sparse)));
  }|]

_embedding_bag_sparse_backward_tttttlbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> Int64
  -> IO (Ptr Tensor)
_embedding_bag_sparse_backward_tttttlbl _grad _indices _offsets _offset2bag _bag_size _num_weights _scale_grad_by_freq _mode =
  [C.block| at::Tensor* { return new at::Tensor(at::_embedding_bag_sparse_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , *$(at::Tensor* _offset2bag)
  , *$(at::Tensor* _bag_size)
  , $(int64_t _num_weights)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)));
  }|]

_embedding_bag_dense_backward_ttttttlbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> Int64
  -> IO (Ptr Tensor)
_embedding_bag_dense_backward_ttttttlbl _grad _indices _offsets _offset2bag _bag_size _maximum_indices _num_weights _scale_grad_by_freq _mode =
  [C.block| at::Tensor* { return new at::Tensor(at::_embedding_bag_dense_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , *$(at::Tensor* _offset2bag)
  , *$(at::Tensor* _bag_size)
  , *$(at::Tensor* _maximum_indices)
  , $(int64_t _num_weights)
  , $(bool _scale_grad_by_freq)
  , $(int64_t _mode)));
  }|]

empty_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_lo _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::empty(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

empty_out_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
empty_out_tl _out _size =
  [C.block| at::Tensor* { return new at::Tensor(at::empty_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)));
  }|]

empty_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
empty_like_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::empty_like(
    *$(at::Tensor* _self)));
  }|]

empty_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_like_to _self _options =
  [C.block| at::Tensor* { return new at::Tensor(at::empty_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

empty_strided_llo
  :: Ptr IntArray
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_strided_llo _size _stride _options =
  [C.block| at::Tensor* { return new at::Tensor(at::empty_strided(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)
  , *$(at::TensorOptions* _options)));
  }|]

erf_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erf_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::erf(
    *$(at::Tensor* _self)));
  }|]

erf__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erf__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::erf_(
    *$(at::Tensor* _self)));
  }|]

erf_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
erf_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::erf_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

erfc_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erfc_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::erfc(
    *$(at::Tensor* _self)));
  }|]

erfc__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erfc__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::erfc_(
    *$(at::Tensor* _self)));
  }|]

erfc_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
erfc_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::erfc_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

exp_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
exp_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::exp(
    *$(at::Tensor* _self)));
  }|]

exp__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
exp__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::exp_(
    *$(at::Tensor* _self)));
  }|]

exp_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
exp_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::exp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

expm1_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
expm1_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::expm1(
    *$(at::Tensor* _self)));
  }|]

expm1__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
expm1__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::expm1_(
    *$(at::Tensor* _self)));
  }|]

expm1_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
expm1_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::expm1_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

eye_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
eye_lo _n _options =
  [C.block| at::Tensor* { return new at::Tensor(at::eye(
    $(int64_t _n)
  , *$(at::TensorOptions* _options)));
  }|]

eye_llo
  :: Int64
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
eye_llo _n _m _options =
  [C.block| at::Tensor* { return new at::Tensor(at::eye(
    $(int64_t _n)
  , $(int64_t _m)
  , *$(at::TensorOptions* _options)));
  }|]

eye_out_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
eye_out_tl _out _n =
  [C.block| at::Tensor* { return new at::Tensor(at::eye_out(
    *$(at::Tensor* _out)
  , $(int64_t _n)));
  }|]

eye_out_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
eye_out_tll _out _n _m =
  [C.block| at::Tensor* { return new at::Tensor(at::eye_out(
    *$(at::Tensor* _out)
  , $(int64_t _n)
  , $(int64_t _m)));
  }|]

flatten_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
flatten_tll _self _start_dim _end_dim =
  [C.block| at::Tensor* { return new at::Tensor(at::flatten(
    *$(at::Tensor* _self)
  , $(int64_t _start_dim)
  , $(int64_t _end_dim)));
  }|]

fill__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
fill__ts _self _value =
  [C.block| at::Tensor* { return new at::Tensor(at::fill_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _value)));
  }|]

fill__tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fill__tt _self _value =
  [C.block| at::Tensor* { return new at::Tensor(at::fill_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _value)));
  }|]

floor_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
floor_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::floor(
    *$(at::Tensor* _self)));
  }|]

floor__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
floor__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::floor_(
    *$(at::Tensor* _self)));
  }|]

floor_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
floor_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::floor_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

full_lso
  :: Ptr IntArray
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
full_lso _size _fill_value _options =
  [C.block| at::Tensor* { return new at::Tensor(at::full(
    *$(std::vector<int64_t>* _size)
  , *$(at::Scalar* _fill_value)
  , *$(at::TensorOptions* _options)));
  }|]

full_out_tls
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Scalar
  -> IO (Ptr Tensor)
full_out_tls _out _size _fill_value =
  [C.block| at::Tensor* { return new at::Tensor(at::full_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)
  , *$(at::Scalar* _fill_value)));
  }|]

full_like_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
full_like_ts _self _fill_value =
  [C.block| at::Tensor* { return new at::Tensor(at::full_like(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _fill_value)));
  }|]

full_like_tso
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
full_like_tso _self _fill_value _options =
  [C.block| at::Tensor* { return new at::Tensor(at::full_like(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _fill_value)
  , *$(at::TensorOptions* _options)));
  }|]

grid_sampler_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
grid_sampler_ttll _input _grid _interpolation_mode _padding_mode =
  [C.block| at::Tensor* { return new at::Tensor(at::grid_sampler(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int64_t _interpolation_mode)
  , $(int64_t _padding_mode)));
  }|]

grid_sampler_2d_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
grid_sampler_2d_ttll _input _grid _interpolation_mode _padding_mode =
  [C.block| at::Tensor* { return new at::Tensor(at::grid_sampler_2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int64_t _interpolation_mode)
  , $(int64_t _padding_mode)));
  }|]

grid_sampler_2d_backward_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (Tensor,Tensor))
grid_sampler_2d_backward_tttll _grad_output _input _grid _interpolation_mode _padding_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::grid_sampler_2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int64_t _interpolation_mode)
  , $(int64_t _padding_mode)));
  }|]

grid_sampler_3d_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
grid_sampler_3d_ttll _input _grid _interpolation_mode _padding_mode =
  [C.block| at::Tensor* { return new at::Tensor(at::grid_sampler_3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int64_t _interpolation_mode)
  , $(int64_t _padding_mode)));
  }|]

grid_sampler_3d_backward_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (Tensor,Tensor))
grid_sampler_3d_backward_tttll _grad_output _input _grid _interpolation_mode _padding_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::grid_sampler_3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int64_t _interpolation_mode)
  , $(int64_t _padding_mode)));
  }|]

hann_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hann_window_lo _window_length _options =
  [C.block| at::Tensor* { return new at::Tensor(at::hann_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

hann_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hann_window_lbo _window_length _periodic _options =
  [C.block| at::Tensor* { return new at::Tensor(at::hann_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_lo _window_length _options =
  [C.block| at::Tensor* { return new at::Tensor(at::hamming_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_lbo _window_length _periodic _options =
  [C.block| at::Tensor* { return new at::Tensor(at::hamming_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_lbdo
  :: Int64
  -> CBool
  -> CDouble
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_lbdo _window_length _periodic _alpha _options =
  [C.block| at::Tensor* { return new at::Tensor(at::hamming_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , $(double _alpha)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_lbddo
  :: Int64
  -> CBool
  -> CDouble
  -> CDouble
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_lbddo _window_length _periodic _alpha _beta _options =
  [C.block| at::Tensor* { return new at::Tensor(at::hamming_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , $(double _alpha)
  , $(double _beta)
  , *$(at::TensorOptions* _options)));
  }|]

hinge_embedding_loss_ttdl
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
hinge_embedding_loss_ttdl _self _target _margin _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::hinge_embedding_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(double _margin)
  , $(int64_t _reduction)));
  }|]

ger_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ger_tt _self _vec2 =
  [C.block| at::Tensor* { return new at::Tensor(at::ger(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec2)));
  }|]

ger_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ger_out_ttt _out _self _vec2 =
  [C.block| at::Tensor* { return new at::Tensor(at::ger_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec2)));
  }|]

group_norm_tlttdb
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
group_norm_tlttdb _input _num_groups _weight _bias _eps _cudnn_enabled =
  [C.block| at::Tensor* { return new at::Tensor(at::group_norm(
    *$(at::Tensor* _input)
  , $(int64_t _num_groups)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(double _eps)
  , $(bool _cudnn_enabled)));
  }|]

fft_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
fft_tlb _self _signal_ndim _normalized =
  [C.block| at::Tensor* { return new at::Tensor(at::fft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)
  , $(bool _normalized)));
  }|]

ifft_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
ifft_tlb _self _signal_ndim _normalized =
  [C.block| at::Tensor* { return new at::Tensor(at::ifft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)
  , $(bool _normalized)));
  }|]

rfft_tlbb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
rfft_tlbb _self _signal_ndim _normalized _onesided =
  [C.block| at::Tensor* { return new at::Tensor(at::rfft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)
  , $(bool _normalized)
  , $(bool _onesided)));
  }|]

irfft_tlbbl
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> IO (Ptr Tensor)
irfft_tlbbl _self _signal_ndim _normalized _onesided _signal_sizes =
  [C.block| at::Tensor* { return new at::Tensor(at::irfft(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)
  , $(bool _normalized)
  , $(bool _onesided)
  , *$(std::vector<int64_t>* _signal_sizes)));
  }|]

_fft_with_size_tlbbblbbl
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_fft_with_size_tlbbblbbl _self _signal_ndim _complex_input _complex_output _inverse _checked_signal_sizes _normalized _onesided _output_sizes =
  [C.block| at::Tensor* { return new at::Tensor(at::_fft_with_size(
    *$(at::Tensor* _self)
  , $(int64_t _signal_ndim)
  , $(bool _complex_input)
  , $(bool _complex_output)
  , $(bool _inverse)
  , *$(std::vector<int64_t>* _checked_signal_sizes)
  , $(bool _normalized)
  , $(bool _onesided)
  , *$(std::vector<int64_t>* _output_sizes)));
  }|]

_cufft_get_plan_cache_size_
  :: IO (Int64)
_cufft_get_plan_cache_size_  =
  [C.block| int64_t { return (at::_cufft_get_plan_cache_size(
    ));
  }|]

_cufft_get_plan_cache_max_size_
  :: IO (Int64)
_cufft_get_plan_cache_max_size_  =
  [C.block| int64_t { return (at::_cufft_get_plan_cache_max_size(
    ));
  }|]

_cufft_set_plan_cache_max_size_l
  :: Int64
  -> IO (())
_cufft_set_plan_cache_max_size_l _max_size =
  [C.block| void {  (at::_cufft_set_plan_cache_max_size(
    $(int64_t _max_size)));
  }|]

_cufft_clear_plan_cache_
  :: IO (())
_cufft_clear_plan_cache_  =
  [C.block| void {  (at::_cufft_clear_plan_cache(
    ));
  }|]

index_tl
  :: Ptr Tensor
  -> Ptr TensorList
  -> IO (Ptr Tensor)
index_tl _self _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::index(
    *$(at::Tensor* _self)
  , *$(at::TensorList* _indices)));
  }|]

index_copy_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_copy_tltt _self _dim _index _source =
  [C.block| at::Tensor* { return new at::Tensor(at::index_copy(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

index_put__tltb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
index_put__tltb _self _indices _values _accumulate =
  [C.block| at::Tensor* { return new at::Tensor(at::index_put_(
    *$(at::Tensor* _self)
  , *$(at::TensorList* _indices)
  , *$(at::Tensor* _values)
  , $(bool _accumulate)));
  }|]

index_put_tltb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
index_put_tltb _self _indices _values _accumulate =
  [C.block| at::Tensor* { return new at::Tensor(at::index_put(
    *$(at::Tensor* _self)
  , *$(at::TensorList* _indices)
  , *$(at::Tensor* _values)
  , $(bool _accumulate)));
  }|]

instance_norm_tttttbddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
instance_norm_tttttbddb _input _weight _bias _running_mean _running_var _use_input_stats _momentum _eps _cudnn_enabled =
  [C.block| at::Tensor* { return new at::Tensor(at::instance_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _use_input_stats)
  , $(double _momentum)
  , $(double _eps)
  , $(bool _cudnn_enabled)));
  }|]

inverse_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
inverse_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::inverse(
    *$(at::Tensor* _self)));
  }|]

inverse_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
inverse_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::inverse_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_inverse_helper_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_inverse_helper_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::_inverse_helper(
    *$(at::Tensor* _self)));
  }|]

isclose_ttddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
isclose_ttddb _self _other _rtol _atol _equal_nan =
  [C.block| at::Tensor* { return new at::Tensor(at::isclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(double _rtol)
  , $(double _atol)
  , $(bool _equal_nan)));
  }|]

isnan_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
isnan_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::isnan(
    *$(at::Tensor* _self)));
  }|]

is_distributed_t
  :: Ptr Tensor
  -> IO (CBool)
is_distributed_t _self =
  [C.block| bool { return (at::is_distributed(
    *$(at::Tensor* _self)));
  }|]

is_floating_point_t
  :: Ptr Tensor
  -> IO (CBool)
is_floating_point_t _self =
  [C.block| bool { return (at::is_floating_point(
    *$(at::Tensor* _self)));
  }|]

is_complex_t
  :: Ptr Tensor
  -> IO (CBool)
is_complex_t _self =
  [C.block| bool { return (at::is_complex(
    *$(at::Tensor* _self)));
  }|]

is_nonzero_t
  :: Ptr Tensor
  -> IO (CBool)
is_nonzero_t _self =
  [C.block| bool { return (at::is_nonzero(
    *$(at::Tensor* _self)));
  }|]

is_same_size_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (CBool)
is_same_size_tt _self _other =
  [C.block| bool { return (at::is_same_size(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

is_signed_t
  :: Ptr Tensor
  -> IO (CBool)
is_signed_t _self =
  [C.block| bool { return (at::is_signed(
    *$(at::Tensor* _self)));
  }|]

kl_div_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
kl_div_ttl _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::kl_div(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

kl_div_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
kl_div_backward_tttl _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::kl_div_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

kthvalue_tllb
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
kthvalue_tllb _self _k _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

kthvalue_out_tttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
kthvalue_out_tttllb _values _indices _self _k _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::kthvalue_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

layer_norm_tlttdb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
layer_norm_tlttdb _input _normalized_shape _weight _bias _eps _cudnn_enable =
  [C.block| at::Tensor* { return new at::Tensor(at::layer_norm(
    *$(at::Tensor* _input)
  , *$(std::vector<int64_t>* _normalized_shape)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(double _eps)
  , $(bool _cudnn_enable)));
  }|]

linear_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
linear_ttt _input _weight _bias =
  [C.block| at::Tensor* { return new at::Tensor(at::linear(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

fbgemm_linear_int8_weight_ttttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_linear_int8_weight_ttttsst _input _weight _packed _col_offsets _weight_scale _weight_zero_point _bias =
  [C.block| at::Tensor* { return new at::Tensor(at::fbgemm_linear_int8_weight(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _packed)
  , *$(at::Tensor* _col_offsets)
  , *$(at::Scalar* _weight_scale)
  , *$(at::Scalar* _weight_zero_point)
  , *$(at::Tensor* _bias)));
  }|]

fbgemm_linear_quantize_weight_t
  :: Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,CDouble,Int64))
fbgemm_linear_quantize_weight_t _input =
  [C.block| std::tuple<at::Tensor,at::Tensor,double,int64_t>* { return new std::tuple<at::Tensor,at::Tensor,double,int64_t>(at::fbgemm_linear_quantize_weight(
    *$(at::Tensor* _input)));
  }|]

fbgemm_pack_quantized_matrix_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
fbgemm_pack_quantized_matrix_tll _input _K _N =
  [C.block| at::Tensor* { return new at::Tensor(at::fbgemm_pack_quantized_matrix(
    *$(at::Tensor* _input)
  , $(int64_t _K)
  , $(int64_t _N)));
  }|]

fbgemm_is_cpu_supported_
  :: IO (CBool)
fbgemm_is_cpu_supported_  =
  [C.block| bool { return (at::fbgemm_is_cpu_supported(
    ));
  }|]

linspace_sslo
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
linspace_sslo _start _end _steps _options =
  [C.block| at::Tensor* { return new at::Tensor(at::linspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)
  , *$(at::TensorOptions* _options)));
  }|]

linspace_out_tssl
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> IO (Ptr Tensor)
linspace_out_tssl _out _start _end _steps =
  [C.block| at::Tensor* { return new at::Tensor(at::linspace_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)));
  }|]

log_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log(
    *$(at::Tensor* _self)));
  }|]

log__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log_(
    *$(at::Tensor* _self)));
  }|]

log_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

log10_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log10_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log10(
    *$(at::Tensor* _self)));
  }|]

log10__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log10__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log10_(
    *$(at::Tensor* _self)));
  }|]

log10_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log10_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log10_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

log1p_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log1p_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log1p(
    *$(at::Tensor* _self)));
  }|]

log1p__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log1p__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log1p_(
    *$(at::Tensor* _self)));
  }|]

log1p_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log1p_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log1p_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

log2_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log2_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log2(
    *$(at::Tensor* _self)));
  }|]

log2__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log2__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log2_(
    *$(at::Tensor* _self)));
  }|]

log2_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log2_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log2_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

logdet_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
logdet_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::logdet(
    *$(at::Tensor* _self)));
  }|]

logspace_sslo
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
logspace_sslo _start _end _steps _options =
  [C.block| at::Tensor* { return new at::Tensor(at::logspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)
  , *$(at::TensorOptions* _options)));
  }|]

logspace_out_tssl
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> IO (Ptr Tensor)
logspace_out_tssl _out _start _end _steps =
  [C.block| at::Tensor* { return new at::Tensor(at::logspace_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)));
  }|]

log_softmax_tls
  :: Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
log_softmax_tls _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::log_softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

log_softmax_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
log_softmax_tl _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::log_softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

_log_softmax_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
_log_softmax_tlb _self _dim _half_to_float =
  [C.block| at::Tensor* { return new at::Tensor(at::_log_softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _half_to_float)));
  }|]

_log_softmax_backward_data_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_log_softmax_backward_data_ttlt _grad_output _output _dim _self =
  [C.block| at::Tensor* { return new at::Tensor(at::_log_softmax_backward_data(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)
  , $(int64_t _dim)
  , *$(at::Tensor* _self)));
  }|]

logsumexp_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
logsumexp_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::logsumexp(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

logsumexp_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
logsumexp_out_ttlb _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::logsumexp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

margin_ranking_loss_tttdl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
margin_ranking_loss_tttdl _input1 _input2 _target _margin _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::margin_ranking_loss(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _target)
  , $(double _margin)
  , $(int64_t _reduction)));
  }|]

matmul_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
matmul_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::matmul(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

matmul_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
matmul_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::matmul_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

matrix_rank_tdb
  :: Ptr Tensor
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
matrix_rank_tdb _self _tol _symmetric =
  [C.block| at::Tensor* { return new at::Tensor(at::matrix_rank(
    *$(at::Tensor* _self)
  , $(double _tol)
  , $(bool _symmetric)));
  }|]

matrix_rank_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
matrix_rank_tb _self _symmetric =
  [C.block| at::Tensor* { return new at::Tensor(at::matrix_rank(
    *$(at::Tensor* _self)
  , $(bool _symmetric)));
  }|]

matrix_power_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
matrix_power_tl _self _n =
  [C.block| at::Tensor* { return new at::Tensor(at::matrix_power(
    *$(at::Tensor* _self)
  , $(int64_t _n)));
  }|]

max_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_tlb _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

max_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_out_tttlb _max _max_values _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_out(
    *$(at::Tensor* _max)
  , *$(at::Tensor* _max_values)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

max_values_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
max_values_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::max_values(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

max_pool1d_with_indices_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_pool1d_with_indices_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool1d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool1d_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
max_pool1d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| at::Tensor* { return new at::Tensor(at::max_pool1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool2d_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
max_pool2d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| at::Tensor* { return new at::Tensor(at::max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool3d_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
max_pool3d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| at::Tensor* { return new at::Tensor(at::max_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

mean_ts
  :: Ptr Tensor
  -> ScalarType
  -> IO (Ptr Tensor)
mean_ts _self _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::mean(
    *$(at::Tensor* _self)
  , $(at::ScalarType _dtype)));
  }|]

mean_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
mean_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::mean(
    *$(at::Tensor* _self)));
  }|]

mean_tlbs
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
mean_tlbs _self _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::mean(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

mean_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
mean_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::mean(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

mean_tls
  :: Ptr Tensor
  -> Ptr IntArray
  -> ScalarType
  -> IO (Ptr Tensor)
mean_tls _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::mean(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(at::ScalarType _dtype)));
  }|]

mean_out_ttlbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
mean_out_ttlbs _out _self _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::mean_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

mean_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
mean_out_ttlb _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::mean_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

mean_out_ttls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> ScalarType
  -> IO (Ptr Tensor)
mean_out_ttls _out _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::mean_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(at::ScalarType _dtype)));
  }|]

median_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
median_tlb _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::median(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

median_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
median_out_tttlb _values _indices _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::median_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

min_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
min_tlb _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::min(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

min_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
min_out_tttlb _min _min_indices _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::min_out(
    *$(at::Tensor* _min)
  , *$(at::Tensor* _min_indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

min_values_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
min_values_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::min_values(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

mkldnn_convolution_tttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
mkldnn_convolution_tttllll _self _weight _bias _padding _stride _dilation _groups =
  [C.block| at::Tensor* { return new at::Tensor(at::mkldnn_convolution(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)));
  }|]

mkldnn_convolution_backward_input_lttllllb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
mkldnn_convolution_backward_input_lttllllb _self_size _grad_output _weight _padding _stride _dilation _groups _bias_defined =
  [C.block| at::Tensor* { return new at::Tensor(at::mkldnn_convolution_backward_input(
    *$(std::vector<int64_t>* _self_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _bias_defined)));
  }|]

mkldnn_convolution_backward_weights_lttllllb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
mkldnn_convolution_backward_weights_lttllllb _weight_size _grad_output _self _padding _stride _dilation _groups _bias_defined =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mkldnn_convolution_backward_weights(
    *$(std::vector<int64_t>* _weight_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _bias_defined)));
  }|]

mkldnn_convolution_backward_tttlllla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
mkldnn_convolution_backward_tttlllla _self _grad_output _weight _padding _stride _dilation _groups _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::mkldnn_convolution_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

miopen_batch_norm_tttttbdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr (Tensor,Tensor,Tensor))
miopen_batch_norm_tttttbdd _input _weight _bias _running_mean _running_var _training _exponential_average_factor _epsilon =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::miopen_batch_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(double _exponential_average_factor)
  , $(double _epsilon)));
  }|]

miopen_batch_norm_backward_tttttttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr (Tensor,Tensor,Tensor))
miopen_batch_norm_backward_tttttttd _input _grad_output _weight _running_mean _running_var _save_mean _save_var _epsilon =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::miopen_batch_norm_backward(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , *$(at::Tensor* _save_mean)
  , *$(at::Tensor* _save_var)
  , $(double _epsilon)));
  }|]

miopen_convolution_tttllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_convolution_tttllllbb _self _weight _bias _padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::miopen_convolution(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_convolution_backward_input_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_convolution_backward_input_lttllllbb _self_size _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::miopen_convolution_backward_input(
    *$(std::vector<int64_t>* _self_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_convolution_backward_tttllllbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
miopen_convolution_backward_tttllllbba _self _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::miopen_convolution_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

miopen_convolution_backward_bias_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
miopen_convolution_backward_bias_t _grad_output =
  [C.block| at::Tensor* { return new at::Tensor(at::miopen_convolution_backward_bias(
    *$(at::Tensor* _grad_output)));
  }|]

miopen_convolution_backward_weight_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_convolution_backward_weight_lttllllbb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::miopen_convolution_backward_weight(
    *$(std::vector<int64_t>* _weight_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_convolution_transpose_tttlllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_convolution_transpose_tttlllllbb _self _weight _bias _padding _output_padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::miopen_convolution_transpose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_convolution_transpose_backward_tttlllllbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
miopen_convolution_transpose_backward_tttlllllbba _self _grad_output _weight _padding _output_padding _stride _dilation _groups _benchmark _deterministic _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::miopen_convolution_transpose_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

miopen_convolution_transpose_backward_input_ttllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_convolution_transpose_backward_input_ttllllbb _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::miopen_convolution_transpose_backward_input(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_convolution_transpose_backward_weight_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_convolution_transpose_backward_weight_lttllllbb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::miopen_convolution_transpose_backward_weight(
    *$(std::vector<int64_t>* _weight_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_depthwise_convolution_tttllllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_depthwise_convolution_tttllllbb _self _weight _bias _padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::miopen_depthwise_convolution(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_depthwise_convolution_backward_input_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_depthwise_convolution_backward_input_lttllllbb _self_size _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::miopen_depthwise_convolution_backward_input(
    *$(std::vector<int64_t>* _self_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

miopen_depthwise_convolution_backward_tttllllbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
miopen_depthwise_convolution_backward_tttllllbba _self _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::miopen_depthwise_convolution_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

miopen_depthwise_convolution_backward_weight_lttllllbb
  :: Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
miopen_depthwise_convolution_backward_weight_lttllllbb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic =
  [C.block| at::Tensor* { return new at::Tensor(at::miopen_depthwise_convolution_backward_weight(
    *$(std::vector<int64_t>* _weight_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _dilation)
  , $(int64_t _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)));
  }|]

mm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mm_tt _self _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::mm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

mm_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mm_out_ttt _out _self _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::mm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

_sparse_mm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_sparse_mm_tt _sparse _dense =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_mm(
    *$(at::Tensor* _sparse)
  , *$(at::Tensor* _dense)));
  }|]

mode_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
mode_tlb _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mode(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

mode_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
mode_out_tttlb _values _indices _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::mode_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

mul_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mul_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::mul(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

mul_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mul_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::mul_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

mul_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
mul_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::mul(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

mv_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mv_tt _self _vec =
  [C.block| at::Tensor* { return new at::Tensor(at::mv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec)));
  }|]

mv_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mv_out_ttt _out _self _vec =
  [C.block| at::Tensor* { return new at::Tensor(at::mv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec)));
  }|]

mvlgamma_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mvlgamma_tl _self _p =
  [C.block| at::Tensor* { return new at::Tensor(at::mvlgamma(
    *$(at::Tensor* _self)
  , $(int64_t _p)));
  }|]

narrow_tlll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
narrow_tlll _self _dim _start _length =
  [C.block| at::Tensor* { return new at::Tensor(at::narrow(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(int64_t _start)
  , $(int64_t _length)));
  }|]

native_batch_norm_tttttbdd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> CDouble
  -> IO (Ptr (Tensor,Tensor,Tensor))
native_batch_norm_tttttbdd _input _weight _bias _running_mean _running_var _training _momentum _eps =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native_batch_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(double _momentum)
  , $(double _eps)));
  }|]

batch_norm_stats_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr (Tensor,Tensor))
batch_norm_stats_td _input _eps =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::batch_norm_stats(
    *$(at::Tensor* _input)
  , $(double _eps)));
  }|]

batch_norm_elemt_tttttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
batch_norm_elemt_tttttd _input _weight _bias _mean _invstd _eps =
  [C.block| at::Tensor* { return new at::Tensor(at::batch_norm_elemt(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _invstd)
  , $(double _eps)));
  }|]

batch_norm_gather_stats_tttttddl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> Int64
  -> IO (Ptr (Tensor,Tensor))
batch_norm_gather_stats_tttttddl _input _mean _invstd _running_mean _running_var _momentum _eps _count =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::batch_norm_gather_stats(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _invstd)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(double _momentum)
  , $(double _eps)
  , $(int64_t _count)));
  }|]

native_batch_norm_backward_tttttttbda
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CDouble
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
native_batch_norm_backward_tttttttbda _grad_out _input _weight _running_mean _running_var _save_mean _save_invstd _train _eps _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native_batch_norm_backward(
    *$(at::Tensor* _grad_out)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , *$(at::Tensor* _save_mean)
  , *$(at::Tensor* _save_invstd)
  , $(bool _train)
  , $(double _eps)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

batch_norm_backward_reduce_ttttbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor,Tensor))
batch_norm_backward_reduce_ttttbbb _grad_out _input _mean _invstd _input_g _weight_g _bias_g =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::batch_norm_backward_reduce(
    *$(at::Tensor* _grad_out)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _invstd)
  , $(bool _input_g)
  , $(bool _weight_g)
  , $(bool _bias_g)));
  }|]

batch_norm_backward_elemt_ttttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
batch_norm_backward_elemt_ttttttt _grad_out _input _mean _invstd _weight _mean_dy _mean_dy_xmu =
  [C.block| at::Tensor* { return new at::Tensor(at::batch_norm_backward_elemt(
    *$(at::Tensor* _grad_out)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _invstd)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _mean_dy)
  , *$(at::Tensor* _mean_dy_xmu)));
  }|]

batch_norm_update_stats_tttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr (Tensor,Tensor))
batch_norm_update_stats_tttd _input _running_mean _running_var _momentum =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::batch_norm_update_stats(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(double _momentum)));
  }|]

_nnpack_available_
  :: IO (CBool)
_nnpack_available_  =
  [C.block| bool { return (at::_nnpack_available(
    ));
  }|]

_nnpack_spatial_convolution_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_nnpack_spatial_convolution_tttl _input _weight _bias _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::_nnpack_spatial_convolution(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _padding)));
  }|]

_nnpack_spatial_convolution_backward_tttla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
_nnpack_spatial_convolution_backward_tttla _input _grad_output _weight _padding _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_nnpack_spatial_convolution_backward(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

_nnpack_spatial_convolution_backward_input_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_nnpack_spatial_convolution_backward_input_tttl _input _grad_output _weight _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::_nnpack_spatial_convolution_backward_input(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _padding)));
  }|]

_nnpack_spatial_convolution_backward_weight_tltl
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_nnpack_spatial_convolution_backward_weight_tltl _input _weightsize _grad_output _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::_nnpack_spatial_convolution_backward_weight(
    *$(at::Tensor* _input)
  , *$(std::vector<int64_t>* _weightsize)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _padding)));
  }|]

ones_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
ones_lo _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::ones(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

ones_out_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
ones_out_tl _out _size =
  [C.block| at::Tensor* { return new at::Tensor(at::ones_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)));
  }|]

ones_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
ones_like_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::ones_like(
    *$(at::Tensor* _self)));
  }|]

ones_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
ones_like_to _self _options =
  [C.block| at::Tensor* { return new at::Tensor(at::ones_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

pairwise_distance_ttddb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> CBool
  -> IO (Ptr Tensor)
pairwise_distance_ttddb _x1 _x2 _p _eps _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::pairwise_distance(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(double _p)
  , $(double _eps)
  , $(bool _keepdim)));
  }|]

cdist_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
cdist_ttd _x1 _x2 _p =
  [C.block| at::Tensor* { return new at::Tensor(at::cdist(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(double _p)));
  }|]

pdist_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
pdist_td _self _p =
  [C.block| at::Tensor* { return new at::Tensor(at::pdist(
    *$(at::Tensor* _self)
  , $(double _p)));
  }|]

_pdist_forward_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
_pdist_forward_td _self _p =
  [C.block| at::Tensor* { return new at::Tensor(at::_pdist_forward(
    *$(at::Tensor* _self)
  , $(double _p)));
  }|]

_pdist_backward_ttdt
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_pdist_backward_ttdt _grad _self _p _pdist =
  [C.block| at::Tensor* { return new at::Tensor(at::_pdist_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _self)
  , $(double _p)
  , *$(at::Tensor* _pdist)));
  }|]

cosine_similarity_ttld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CDouble
  -> IO (Ptr Tensor)
cosine_similarity_ttld _x1 _x2 _dim _eps =
  [C.block| at::Tensor* { return new at::Tensor(at::cosine_similarity(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(int64_t _dim)
  , $(double _eps)));
  }|]

pixel_shuffle_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
pixel_shuffle_tl _self _upscale_factor =
  [C.block| at::Tensor* { return new at::Tensor(at::pixel_shuffle(
    *$(at::Tensor* _self)
  , $(int64_t _upscale_factor)));
  }|]

pin_memory_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
pin_memory_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::pin_memory(
    *$(at::Tensor* _self)));
  }|]

pinverse_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
pinverse_td _self _rcond =
  [C.block| at::Tensor* { return new at::Tensor(at::pinverse(
    *$(at::Tensor* _self)
  , $(double _rcond)));
  }|]

scalar_tensor_so
  :: Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
scalar_tensor_so _s _options =
  [C.block| at::Tensor* { return new at::Tensor(at::scalar_tensor(
    *$(at::Scalar* _s)
  , *$(at::TensorOptions* _options)));
  }|]

rand_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lo _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

rand_lpo
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lpo _size _generator _options =
  [C.block| at::Tensor* { return new at::Tensor(at::rand(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

rand_out_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
rand_out_tl _out _size =
  [C.block| at::Tensor* { return new at::Tensor(at::rand_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)));
  }|]

rand_out_tlp
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
rand_out_tlp _out _size _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::rand_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

rand_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rand_like_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::rand_like(
    *$(at::Tensor* _self)));
  }|]

rand_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_like_to _self _options =
  [C.block| at::Tensor* { return new at::Tensor(at::rand_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

randint_llo
  :: Int64
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_llo _high _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randint_llpo
  :: Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_llpo _high _size _generator _options =
  [C.block| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randint_lllo
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_lllo _low _high _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randint_lllpo
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_lllpo _low _high _size _generator _options =
  [C.block| at::Tensor* { return new at::Tensor(at::randint(
    $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randint_out_tll
  :: Ptr Tensor
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
randint_out_tll _out _high _size =
  [C.block| at::Tensor* { return new at::Tensor(at::randint_out(
    *$(at::Tensor* _out)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)));
  }|]

randint_out_tllp
  :: Ptr Tensor
  -> Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randint_out_tllp _out _high _size _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::randint_out(
    *$(at::Tensor* _out)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randint_out_tlll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
randint_out_tlll _out _low _high _size =
  [C.block| at::Tensor* { return new at::Tensor(at::randint_out(
    *$(at::Tensor* _out)
  , $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)));
  }|]

randint_out_tlllp
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randint_out_tlllp _out _low _high _size _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::randint_out(
    *$(at::Tensor* _out)
  , $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randint_like_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
randint_like_tl _self _high =
  [C.block| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _high)));
  }|]

randint_like_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
randint_like_tll _self _low _high =
  [C.block| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _low)
  , $(int64_t _high)));
  }|]

randint_like_tlo
  :: Ptr Tensor
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_like_tlo _self _high _options =
  [C.block| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _high)
  , *$(at::TensorOptions* _options)));
  }|]

randint_like_tllo
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_like_tllo _self _low _high _options =
  [C.block| at::Tensor* { return new at::Tensor(at::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _low)
  , $(int64_t _high)
  , *$(at::TensorOptions* _options)));
  }|]

randn_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lo _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randn_lpo
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lpo _size _generator _options =
  [C.block| at::Tensor* { return new at::Tensor(at::randn(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randn_out_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
randn_out_tl _out _size =
  [C.block| at::Tensor* { return new at::Tensor(at::randn_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)));
  }|]

randn_out_tlp
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
randn_out_tlp _out _size _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::randn_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)));
  }|]

randn_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
randn_like_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::randn_like(
    *$(at::Tensor* _self)));
  }|]

randn_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_like_to _self _options =
  [C.block| at::Tensor* { return new at::Tensor(at::randn_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

randperm_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randperm_lo _n _options =
  [C.block| at::Tensor* { return new at::Tensor(at::randperm(
    $(int64_t _n)
  , *$(at::TensorOptions* _options)));
  }|]

randperm_lpo
  :: Int64
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randperm_lpo _n _generator _options =
  [C.block| at::Tensor* { return new at::Tensor(at::randperm(
    $(int64_t _n)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randperm_out_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
randperm_out_tl _out _n =
  [C.block| at::Tensor* { return new at::Tensor(at::randperm_out(
    *$(at::Tensor* _out)
  , $(int64_t _n)));
  }|]

randperm_out_tlp
  :: Ptr Tensor
  -> Int64
  -> Ptr Generator
  -> IO (Ptr Tensor)
randperm_out_tlp _out _n _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::randperm_out(
    *$(at::Tensor* _out)
  , $(int64_t _n)
  , $(at::Generator * _generator)));
  }|]

range_ssso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
range_ssso _start _end _step _options =
  [C.block| at::Tensor* { return new at::Tensor(at::range(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)
  , *$(at::TensorOptions* _options)));
  }|]

range_sso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
range_sso _start _end _options =
  [C.block| at::Tensor* { return new at::Tensor(at::range(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::TensorOptions* _options)));
  }|]

range_out_tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
range_out_tsss _out _start _end _step =
  [C.block| at::Tensor* { return new at::Tensor(at::range_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)));
  }|]

reshape_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reshape_tl _self _shape =
  [C.block| at::Tensor* { return new at::Tensor(at::reshape(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _shape)));
  }|]

round_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
round_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::round(
    *$(at::Tensor* _self)));
  }|]

round__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
round__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::round_(
    *$(at::Tensor* _self)));
  }|]

round_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
round_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::round_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

rrelu_tssbp
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_tssbp _self _lower _upper _training _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::rrelu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

rrelu__tssbp
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu__tssbp _self _lower _upper _training _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::rrelu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

relu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
relu_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::relu(
    *$(at::Tensor* _self)));
  }|]

relu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
relu__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::relu_(
    *$(at::Tensor* _self)));
  }|]

prelu_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
prelu_tt _self _weight =
  [C.block| at::Tensor* { return new at::Tensor(at::prelu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)));
  }|]

prelu_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
prelu_backward_ttt _grad_output _self _weight =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::prelu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)));
  }|]

hardshrink_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardshrink_ts _self _lambd =
  [C.block| at::Tensor* { return new at::Tensor(at::hardshrink(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

hardshrink_backward_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardshrink_backward_tts _grad_out _self _lambd =
  [C.block| at::Tensor* { return new at::Tensor(at::hardshrink_backward(
    *$(at::Tensor* _grad_out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

rsqrt_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rsqrt_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::rsqrt(
    *$(at::Tensor* _self)));
  }|]

rsqrt__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rsqrt__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::rsqrt_(
    *$(at::Tensor* _self)));
  }|]

rsqrt_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rsqrt_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::rsqrt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

select_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
select_tll _self _dim _index =
  [C.block| at::Tensor* { return new at::Tensor(at::select(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(int64_t _index)));
  }|]

selu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
selu_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::selu(
    *$(at::Tensor* _self)));
  }|]

selu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
selu__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::selu_(
    *$(at::Tensor* _self)));
  }|]

celu_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
celu_ts _self _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::celu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

celu__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
celu__ts _self _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::celu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

sigmoid_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sigmoid(
    *$(at::Tensor* _self)));
  }|]

sigmoid__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sigmoid_(
    *$(at::Tensor* _self)));
  }|]

sigmoid_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sigmoid_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

sin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sin_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sin(
    *$(at::Tensor* _self)));
  }|]

sin__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sin__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sin_(
    *$(at::Tensor* _self)));
  }|]

sin_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sin_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sin_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

sinh_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sinh_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sinh(
    *$(at::Tensor* _self)));
  }|]

sinh__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sinh__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sinh_(
    *$(at::Tensor* _self)));
  }|]

sinh_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sinh_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sinh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

detach_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
detach_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::detach(
    *$(at::Tensor* _self)));
  }|]

detach__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
detach__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::detach_(
    *$(at::Tensor* _self)));
  }|]

size_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Int64)
size_tl _self _dim =
  [C.block| int64_t { return (at::size(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

slice_tllll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
slice_tllll _self _dim _start _end _step =
  [C.block| at::Tensor* { return new at::Tensor(at::slice(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(int64_t _start)
  , $(int64_t _end)
  , $(int64_t _step)));
  }|]

slogdet_t
  :: Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
slogdet_t _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::slogdet(
    *$(at::Tensor* _self)));
  }|]

smm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
smm_tt _self _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::smm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

softmax_tls
  :: Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
softmax_tls _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

softmax_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
softmax_tl _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

_softmax_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
_softmax_tlb _self _dim _half_to_float =
  [C.block| at::Tensor* { return new at::Tensor(at::_softmax(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _half_to_float)));
  }|]

_softmax_backward_data_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_softmax_backward_data_ttlt _grad_output _output _dim _self =
  [C.block| at::Tensor* { return new at::Tensor(at::_softmax_backward_data(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)
  , $(int64_t _dim)
  , *$(at::Tensor* _self)));
  }|]

_sparse_add_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_sparse_add_out_ttts _out _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_add_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

_sparse_dense_add_out_ttrs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr SparseTensorRef
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_sparse_dense_add_out_ttrs _out _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_dense_add_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::SparseTensorRef* _other)
  , *$(at::Scalar* _alpha)));
  }|]

_sparse_div_zerodim_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_sparse_div_zerodim_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_div_zerodim_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

_sparse_div_scalar_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_sparse_div_scalar_out_tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_div_scalar_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

_sparse_mul_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_sparse_mul_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_mul_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

_sparse_mul_zerodim_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_sparse_mul_zerodim_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_mul_zerodim_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

_sparse_mul_scalar_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_sparse_mul_scalar_out_tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_mul_scalar_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

split_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr TensorList)
split_tll _self _split_size _dim =
  [C.block| at::TensorList* { return new at::TensorList(at::split(
    *$(at::Tensor* _self)
  , $(int64_t _split_size)
  , $(int64_t _dim)));
  }|]

split_with_sizes_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr TensorList)
split_with_sizes_tll _self _split_sizes _dim =
  [C.block| at::TensorList* { return new at::TensorList(at::split_with_sizes(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _split_sizes)
  , $(int64_t _dim)));
  }|]

squeeze_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
squeeze_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::squeeze(
    *$(at::Tensor* _self)));
  }|]

squeeze_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
squeeze_tl _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::squeeze(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

sspaddmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sspaddmm_tttss _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::sspaddmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

sspaddmm_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sspaddmm_out_ttttss _out _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::sspaddmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

stack_ll
  :: Ptr TensorList
  -> Int64
  -> IO (Ptr Tensor)
stack_ll _tensors _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::stack(
    *$(at::TensorList* _tensors)
  , $(int64_t _dim)));
  }|]

stack_out_tll
  :: Ptr Tensor
  -> Ptr TensorList
  -> Int64
  -> IO (Ptr Tensor)
stack_out_tll _out _tensors _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::stack_out(
    *$(at::Tensor* _out)
  , *$(at::TensorList* _tensors)
  , $(int64_t _dim)));
  }|]

stft_tllltbb
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
stft_tllltbb _self _n_fft _hop_length _win_length _window _normalized _onesided =
  [C.block| at::Tensor* { return new at::Tensor(at::stft(
    *$(at::Tensor* _self)
  , $(int64_t _n_fft)
  , $(int64_t _hop_length)
  , $(int64_t _win_length)
  , *$(at::Tensor* _window)
  , $(bool _normalized)
  , $(bool _onesided)));
  }|]

stride_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Int64)
stride_tl _self _dim =
  [C.block| int64_t { return (at::stride(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

sum_ts
  :: Ptr Tensor
  -> ScalarType
  -> IO (Ptr Tensor)
sum_ts _self _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::sum(
    *$(at::Tensor* _self)
  , $(at::ScalarType _dtype)));
  }|]

sum_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sum_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sum(
    *$(at::Tensor* _self)));
  }|]

sum_tlbs
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
sum_tlbs _self _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::sum(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

sum_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
sum_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::sum(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

sum_tls
  :: Ptr Tensor
  -> Ptr IntArray
  -> ScalarType
  -> IO (Ptr Tensor)
sum_tls _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::sum(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(at::ScalarType _dtype)));
  }|]

sum_out_ttlbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
sum_out_ttlbs _out _self _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::sum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

sum_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
sum_out_ttlb _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::sum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

sum_out_ttls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> ScalarType
  -> IO (Ptr Tensor)
sum_out_ttls _out _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::sum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(at::ScalarType _dtype)));
  }|]

sqrt_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sqrt_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sqrt(
    *$(at::Tensor* _self)));
  }|]

sqrt__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sqrt__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sqrt_(
    *$(at::Tensor* _self)));
  }|]

sqrt_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sqrt_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sqrt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

std_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
std_tb _self _unbiased =
  [C.block| at::Tensor* { return new at::Tensor(at::std(
    *$(at::Tensor* _self)
  , $(bool _unbiased)));
  }|]

std_tlbb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
std_tlbb _self _dim _unbiased _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::std(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

std_out_ttlbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
std_out_ttlbb _out _self _dim _unbiased _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::std_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

prod_ts
  :: Ptr Tensor
  -> ScalarType
  -> IO (Ptr Tensor)
prod_ts _self _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::prod(
    *$(at::Tensor* _self)
  , $(at::ScalarType _dtype)));
  }|]

prod_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
prod_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::prod(
    *$(at::Tensor* _self)));
  }|]

prod_tlbs
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
prod_tlbs _self _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::prod(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

prod_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
prod_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::prod(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

prod_tls
  :: Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
prod_tls _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::prod(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

prod_out_ttlbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
prod_out_ttlbs _out _self _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::prod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

prod_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
prod_out_ttlb _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::prod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

prod_out_ttls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> ScalarType
  -> IO (Ptr Tensor)
prod_out_ttls _out _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::prod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(at::ScalarType _dtype)));
  }|]

t_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
t_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::t(
    *$(at::Tensor* _self)));
  }|]

tan_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
tan_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::tan(
    *$(at::Tensor* _self)));
  }|]

tan__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
tan__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::tan_(
    *$(at::Tensor* _self)));
  }|]

tan_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
tan_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::tan_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

tanh_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
tanh_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::tanh(
    *$(at::Tensor* _self)));
  }|]

tanh__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
tanh__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::tanh_(
    *$(at::Tensor* _self)));
  }|]

tanh_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
tanh_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::tanh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

tensordot_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
tensordot_ttll _self _other _dims_self _dims_other =
  [C.block| at::Tensor* { return new at::Tensor(at::tensordot(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(std::vector<int64_t>* _dims_self)
  , *$(std::vector<int64_t>* _dims_other)));
  }|]

threshold_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
threshold_tss _self _threshold _value =
  [C.block| at::Tensor* { return new at::Tensor(at::threshold(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _threshold)
  , *$(at::Scalar* _value)));
  }|]

threshold__tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
threshold__tss _self _threshold _value =
  [C.block| at::Tensor* { return new at::Tensor(at::threshold_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _threshold)
  , *$(at::Scalar* _value)));
  }|]

threshold_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
threshold_out_ttss _out _self _threshold _value =
  [C.block| at::Tensor* { return new at::Tensor(at::threshold_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _threshold)
  , *$(at::Scalar* _value)));
  }|]

threshold_backward_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
threshold_backward_tts _grad_output _self _threshold =
  [C.block| at::Tensor* { return new at::Tensor(at::threshold_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _threshold)));
  }|]

transpose_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
transpose_tll _self _dim0 _dim1 =
  [C.block| at::Tensor* { return new at::Tensor(at::transpose(
    *$(at::Tensor* _self)
  , $(int64_t _dim0)
  , $(int64_t _dim1)));
  }|]

one_hot_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
one_hot_tl _self _num_classes =
  [C.block| at::Tensor* { return new at::Tensor(at::one_hot(
    *$(at::Tensor* _self)
  , $(int64_t _num_classes)));
  }|]

flip_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
flip_tl _self _dims =
  [C.block| at::Tensor* { return new at::Tensor(at::flip(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dims)));
  }|]

roll_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
roll_tll _self _shifts _dims =
  [C.block| at::Tensor* { return new at::Tensor(at::roll(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _shifts)
  , *$(std::vector<int64_t>* _dims)));
  }|]

rot90_tll
  :: Ptr Tensor
  -> Int64
  -> Ptr IntArray
  -> IO (Ptr Tensor)
rot90_tll _self _k _dims =
  [C.block| at::Tensor* { return new at::Tensor(at::rot90(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , *$(std::vector<int64_t>* _dims)));
  }|]

_trilinear_tttlllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Int64
  -> IO (Ptr Tensor)
_trilinear_tttlllll _i1 _i2 _i3 _expand1 _expand2 _expand3 _sumdim _unroll_dim =
  [C.block| at::Tensor* { return new at::Tensor(at::_trilinear(
    *$(at::Tensor* _i1)
  , *$(at::Tensor* _i2)
  , *$(at::Tensor* _i3)
  , *$(std::vector<int64_t>* _expand1)
  , *$(std::vector<int64_t>* _expand2)
  , *$(std::vector<int64_t>* _expand3)
  , *$(std::vector<int64_t>* _sumdim)
  , $(int64_t _unroll_dim)));
  }|]

triplet_margin_loss_tttdddbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> CDouble
  -> CDouble
  -> CBool
  -> Int64
  -> IO (Ptr Tensor)
triplet_margin_loss_tttdddbl _anchor _positive _negative _margin _p _eps _swap _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::triplet_margin_loss(
    *$(at::Tensor* _anchor)
  , *$(at::Tensor* _positive)
  , *$(at::Tensor* _negative)
  , $(double _margin)
  , $(double _p)
  , $(double _eps)
  , $(bool _swap)
  , $(int64_t _reduction)));
  }|]

trunc_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
trunc_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::trunc(
    *$(at::Tensor* _self)));
  }|]

trunc__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
trunc__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::trunc_(
    *$(at::Tensor* _self)));
  }|]

trunc_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
trunc_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::trunc_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_unique_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
_unique_tbb _self _sorted _return_inverse =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_unique(
    *$(at::Tensor* _self)
  , $(bool _sorted)
  , $(bool _return_inverse)));
  }|]

_unique_dim_tlbb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
_unique_dim_tlbb _self _dim _sorted _return_inverse =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_unique_dim(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _sorted)
  , $(bool _return_inverse)));
  }|]

_unsafe_view_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_unsafe_view_tl _self _size =
  [C.block| at::Tensor* { return new at::Tensor(at::_unsafe_view(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _size)));
  }|]

unsqueeze_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
unsqueeze_tl _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::unsqueeze(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

var_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
var_tb _self _unbiased =
  [C.block| at::Tensor* { return new at::Tensor(at::var(
    *$(at::Tensor* _self)
  , $(bool _unbiased)));
  }|]

var_tlbb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
var_tlbb _self _dim _unbiased _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::var(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

var_out_ttlbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
var_out_ttlbb _out _self _dim _unbiased _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::var_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

where_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
where_ttt _condition _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::where(
    *$(at::Tensor* _condition)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

_s_where_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_s_where_ttt _condition _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::_s_where(
    *$(at::Tensor* _condition)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

norm_except_dim_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
norm_except_dim_tll _v _pow _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::norm_except_dim(
    *$(at::Tensor* _v)
  , $(int64_t _pow)
  , $(int64_t _dim)));
  }|]

_weight_norm_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_weight_norm_ttl _v _g _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::_weight_norm(
    *$(at::Tensor* _v)
  , *$(at::Tensor* _g)
  , $(int64_t _dim)));
  }|]

_weight_norm_cuda_interface_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (Tensor,Tensor))
_weight_norm_cuda_interface_ttl _v _g _dim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_weight_norm_cuda_interface(
    *$(at::Tensor* _v)
  , *$(at::Tensor* _g)
  , $(int64_t _dim)));
  }|]

_weight_norm_cuda_interface_backward_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (Tensor,Tensor))
_weight_norm_cuda_interface_backward_ttttl _grad_w _saved_v _saved_g _saved_norms _dim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_weight_norm_cuda_interface_backward(
    *$(at::Tensor* _grad_w)
  , *$(at::Tensor* _saved_v)
  , *$(at::Tensor* _saved_g)
  , *$(at::Tensor* _saved_norms)
  , $(int64_t _dim)));
  }|]

_weight_norm_differentiable_backward_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (Tensor,Tensor))
_weight_norm_differentiable_backward_ttttl _grad_w _saved_v _saved_g _saved_norms _dim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_weight_norm_differentiable_backward(
    *$(at::Tensor* _grad_w)
  , *$(at::Tensor* _saved_v)
  , *$(at::Tensor* _saved_g)
  , *$(at::Tensor* _saved_norms)
  , $(int64_t _dim)));
  }|]

zeros_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
zeros_lo _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::zeros(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

zeros_out_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
zeros_out_tl _out _size =
  [C.block| at::Tensor* { return new at::Tensor(at::zeros_out(
    *$(at::Tensor* _out)
  , *$(std::vector<int64_t>* _size)));
  }|]

zeros_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
zeros_like_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::zeros_like(
    *$(at::Tensor* _self)));
  }|]

zeros_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
zeros_like_to _self _options =
  [C.block| at::Tensor* { return new at::Tensor(at::zeros_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

_standard_gamma_grad_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_standard_gamma_grad_tt _self _output =
  [C.block| at::Tensor* { return new at::Tensor(at::_standard_gamma_grad(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _output)));
  }|]

_standard_gamma_tp
  :: Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
_standard_gamma_tp _self _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::_standard_gamma(
    *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

poisson_tp
  :: Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
poisson_tp _self _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::poisson(
    *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

native_norm_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
native_norm_ts _self _p =
  [C.block| at::Tensor* { return new at::Tensor(at::native_norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)));
  }|]

_sparse_sum_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_sparse_sum_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_sum(
    *$(at::Tensor* _self)));
  }|]

_sparse_sum_ts
  :: Ptr Tensor
  -> ScalarType
  -> IO (Ptr Tensor)
_sparse_sum_ts _self _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_sum(
    *$(at::Tensor* _self)
  , $(at::ScalarType _dtype)));
  }|]

_sparse_sum_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_sparse_sum_tl _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_sum(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

_sparse_sum_tls
  :: Ptr Tensor
  -> Ptr IntArray
  -> ScalarType
  -> IO (Ptr Tensor)
_sparse_sum_tls _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_sum(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(at::ScalarType _dtype)));
  }|]

_sparse_sum_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_sparse_sum_backward_ttl _grad _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_sum_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)));
  }|]

norm_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> ScalarType
  -> IO (Ptr Tensor)
norm_tss _self _p _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , $(at::ScalarType _dtype)));
  }|]

norm_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
norm_ts _self _p =
  [C.block| at::Tensor* { return new at::Tensor(at::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)));
  }|]

norm_tslbs
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntArray
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
norm_tslbs _self _p _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

norm_tslb
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
norm_tslb _self _p _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

norm_out_ttslbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntArray
  -> CBool
  -> ScalarType
  -> IO (Ptr Tensor)
norm_out_ttslbs _out _self _p _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)
  , $(at::ScalarType _dtype)));
  }|]

norm_out_ttslb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
norm_out_ttslb _out _self _p _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

frobenius_norm_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
frobenius_norm_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::frobenius_norm(
    *$(at::Tensor* _self)));
  }|]

frobenius_norm_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
frobenius_norm_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::frobenius_norm(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

frobenius_norm_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
frobenius_norm_out_ttlb _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::frobenius_norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _dim)
  , $(bool _keepdim)));
  }|]

nuclear_norm_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
nuclear_norm_tb _self _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::nuclear_norm(
    *$(at::Tensor* _self)
  , $(bool _keepdim)));
  }|]

nuclear_norm_out_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
nuclear_norm_out_ttb _out _self _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::nuclear_norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(bool _keepdim)));
  }|]

native_clone_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
native_clone_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native_clone(
    *$(at::Tensor* _self)));
  }|]

clone_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
clone_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::clone(
    *$(at::Tensor* _self)));
  }|]

native_resize_as__tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
native_resize_as__tt _self _the_template =
  [C.block| at::Tensor* { return new at::Tensor(at::native_resize_as_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _the_template)));
  }|]

resize_as__tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
resize_as__tt _self _the_template =
  [C.block| at::Tensor* { return new at::Tensor(at::resize_as_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _the_template)));
  }|]

native_pow_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
native_pow_out_tts _out _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::native_pow_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _exponent)));
  }|]

native_pow_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
native_pow_ts _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::native_pow(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _exponent)));
  }|]

pow_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
pow_out_tts _out _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::pow_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _exponent)));
  }|]

pow_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
pow_ts _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::pow(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _exponent)));
  }|]

native_zero__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
native_zero__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native_zero_(
    *$(at::Tensor* _self)));
  }|]

zero__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
zero__t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::zero_(
    *$(at::Tensor* _self)));
  }|]

sub_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_out_ttts _out _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::sub_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

sub_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_tts _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::sub(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

sub_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_tss _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::sub(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

rsub_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rsub_tts _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::rsub(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

rsub_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rsub_tss _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::rsub(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

s_native_addmm_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
s_native_addmm_out_ttttss _out _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::s_native_addmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

s_native_addmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
s_native_addmm_tttss _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::s_native_addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

s_native_addmm__tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
s_native_addmm__tttss _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::s_native_addmm_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

_sparse_addmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_sparse_addmm_tttss _self _sparse _dense _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _sparse)
  , *$(at::Tensor* _dense)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmm_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmm_out_ttttss _out _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::addmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmm_tttss _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

sparse_coo_tensor_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_lo _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::sparse_coo_tensor(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_coo_tensor_tto
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_tto _indices _values _options =
  [C.block| at::Tensor* { return new at::Tensor(at::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_coo_tensor_ttlo
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_ttlo _indices _values _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

_sparse_coo_tensor_unsafe_ttlo
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_sparse_coo_tensor_unsafe_ttlo _indices _values _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_coo_tensor_unsafe(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

_sparse_coo_tensor_with_dims_lllo
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_sparse_coo_tensor_with_dims_lllo _sparse_dim _dense_dim _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_coo_tensor_with_dims(
    $(int64_t _sparse_dim)
  , $(int64_t _dense_dim)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

_sparse_coo_tensor_with_dims_and_tensors_llltto
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_sparse_coo_tensor_with_dims_and_tensors_llltto _sparse_dim _dense_dim _size _indices _values _options =
  [C.block| at::Tensor* { return new at::Tensor(at::_sparse_coo_tensor_with_dims_and_tensors(
    $(int64_t _sparse_dim)
  , $(int64_t _dense_dim)
  , *$(std::vector<int64_t>* _size)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(at::TensorOptions* _options)));
  }|]

hspmm_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hspmm_out_ttt _out _mat1 _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::hspmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

hspmm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hspmm_tt _mat1 _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::hspmm(
    *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

copy_sparse_to_sparse__ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
copy_sparse_to_sparse__ttb _self _src _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::copy_sparse_to_sparse_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _src)
  , $(bool _non_blocking)));
  }|]

numel_t
  :: Ptr Tensor
  -> IO (Int64)
numel_t _self =
  [C.block| int64_t { return (at::numel(
    *$(at::Tensor* _self)));
  }|]

unbind_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr TensorList)
unbind_tl _self _dim =
  [C.block| at::TensorList* { return new at::TensorList(at::unbind(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

meshgrid_l
  :: Ptr TensorList
  -> IO (Ptr TensorList)
meshgrid_l _tensors =
  [C.block| at::TensorList* { return new at::TensorList(at::meshgrid(
    *$(at::TensorList* _tensors)));
  }|]

cartesian_prod_l
  :: Ptr TensorList
  -> IO (Ptr Tensor)
cartesian_prod_l _tensors =
  [C.block| at::Tensor* { return new at::Tensor(at::cartesian_prod(
    *$(at::TensorList* _tensors)));
  }|]

combinations_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
combinations_tlb _self _r _with_replacement =
  [C.block| at::Tensor* { return new at::Tensor(at::combinations(
    *$(at::Tensor* _self)
  , $(int64_t _r)
  , $(bool _with_replacement)));
  }|]

_local_scalar_dense_t
  :: Ptr Tensor
  -> IO (Ptr Scalar)
_local_scalar_dense_t _self =
  [C.block| at::Scalar* { return new at::Scalar(at::_local_scalar_dense(
    *$(at::Tensor* _self)));
  }|]

_thnn_fused_lstm_cell_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor))
_thnn_fused_lstm_cell_ttttt _input_gates _hidden_gates _cx _input_bias _hidden_bias =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_thnn_fused_lstm_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _input_bias)
  , *$(at::Tensor* _hidden_bias)));
  }|]

_thnn_fused_lstm_cell_backward_tttttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor,Tensor,Tensor))
_thnn_fused_lstm_cell_backward_tttttb _grad_hy _grad_cy _cx _cy _workspace _has_bias =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_thnn_fused_lstm_cell_backward(
    *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _grad_cy)
  , *$(at::Tensor* _cx)
  , *$(at::Tensor* _cy)
  , *$(at::Tensor* _workspace)
  , $(bool _has_bias)));
  }|]

_thnn_fused_gru_cell_ttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
_thnn_fused_gru_cell_ttttt _input_gates _hidden_gates _hx _input_bias _hidden_bias =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_thnn_fused_gru_cell(
    *$(at::Tensor* _input_gates)
  , *$(at::Tensor* _hidden_gates)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _input_bias)
  , *$(at::Tensor* _hidden_bias)));
  }|]

_thnn_fused_gru_cell_backward_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor,Tensor,Tensor))
_thnn_fused_gru_cell_backward_ttb _grad_hy _workspace _has_bias =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::_thnn_fused_gru_cell_backward(
    *$(at::Tensor* _grad_hy)
  , *$(at::Tensor* _workspace)
  , $(bool _has_bias)));
  }|]

lstm_tllbldbbb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
lstm_tllbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::lstm(
    *$(at::Tensor* _input)
  , *$(at::TensorList* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

lstm_ttllbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
lstm_ttllbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::lstm(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::TensorList* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

gru_ttlbldbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
gru_ttlbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::gru(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

gru_tttlbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
gru_tttlbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::gru(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

rnn_tanh_ttlbldbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
rnn_tanh_ttlbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::rnn_tanh(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

rnn_tanh_tttlbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
rnn_tanh_tttlbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::rnn_tanh(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

rnn_relu_ttlbldbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
rnn_relu_ttlbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::rnn_relu(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

rnn_relu_tttlbldbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
rnn_relu_tttlbldbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::rnn_relu(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

lstm_cell_tltttt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
lstm_cell_tltttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::lstm_cell(
    *$(at::Tensor* _input)
  , *$(at::TensorList* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

gru_cell_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gru_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.block| at::Tensor* { return new at::Tensor(at::gru_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

rnn_tanh_cell_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_tanh_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.block| at::Tensor* { return new at::Tensor(at::rnn_tanh_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

rnn_relu_cell_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_relu_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.block| at::Tensor* { return new at::Tensor(at::rnn_relu_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

quantized_lstm_tllbldbbb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> Int64
  -> CDouble
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
quantized_lstm_tllbldbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::quantized_lstm(
    *$(at::Tensor* _input)
  , *$(at::TensorList* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int64_t _num_layers)
  , $(double _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

quantized_lstm_cell_tlttttttttssss
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr (Tensor,Tensor))
quantized_lstm_cell_tlttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::quantized_lstm_cell(
    *$(at::Tensor* _input)
  , *$(at::TensorList* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

quantized_gru_cell_ttttttttttssss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
quantized_gru_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.block| at::Tensor* { return new at::Tensor(at::quantized_gru_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

quantized_rnn_relu_cell_ttttttttttssss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
quantized_rnn_relu_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.block| at::Tensor* { return new at::Tensor(at::quantized_rnn_relu_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

quantized_rnn_tanh_cell_ttttttttttssss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
quantized_rnn_tanh_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.block| at::Tensor* { return new at::Tensor(at::quantized_rnn_tanh_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

_pack_padded_sequence_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
_pack_padded_sequence_ttb _input _lengths _batch_first =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_pack_padded_sequence(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _lengths)
  , $(bool _batch_first)));
  }|]

_pack_padded_sequence_backward_tltb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_pack_padded_sequence_backward_tltb _grad _input_size _batch_sizes _batch_first =
  [C.block| at::Tensor* { return new at::Tensor(at::_pack_padded_sequence_backward(
    *$(at::Tensor* _grad)
  , *$(std::vector<int64_t>* _input_size)
  , *$(at::Tensor* _batch_sizes)
  , $(bool _batch_first)));
  }|]

_pad_packed_sequence_ttbsl
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Ptr Scalar
  -> Int64
  -> IO (Ptr (Tensor,Tensor))
_pad_packed_sequence_ttbsl _data _batch_sizes _batch_first _padding_value _total_length =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_pad_packed_sequence(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , $(bool _batch_first)
  , *$(at::Scalar* _padding_value)
  , $(int64_t _total_length)));
  }|]

masked_fill_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
masked_fill_tts _self _mask _value =
  [C.block| at::Tensor* { return new at::Tensor(at::masked_fill(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Scalar* _value)));
  }|]

masked_fill_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_fill_ttt _self _mask _value =
  [C.block| at::Tensor* { return new at::Tensor(at::masked_fill(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Tensor* _value)));
  }|]

masked_scatter_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_scatter_ttt _self _mask _source =
  [C.block| at::Tensor* { return new at::Tensor(at::masked_scatter(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Tensor* _source)));
  }|]

index_add_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_add_tltt _self _dim _index _source =
  [C.block| at::Tensor* { return new at::Tensor(at::index_add(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

index_fill_tlts
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
index_fill_tlts _self _dim _index _value =
  [C.block| at::Tensor* { return new at::Tensor(at::index_fill(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Scalar* _value)));
  }|]

index_fill_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_fill_tltt _self _dim _index _value =
  [C.block| at::Tensor* { return new at::Tensor(at::index_fill(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _value)));
  }|]

scatter_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
scatter_tltt _self _dim _index _src =
  [C.block| at::Tensor* { return new at::Tensor(at::scatter(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _src)));
  }|]

scatter_tlts
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
scatter_tlts _self _dim _index _value =
  [C.block| at::Tensor* { return new at::Tensor(at::scatter(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Scalar* _value)));
  }|]

scatter_add_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
scatter_add_tltt _self _dim _index _src =
  [C.block| at::Tensor* { return new at::Tensor(at::scatter_add(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _src)));
  }|]

__and___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__and___ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::__and__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__and___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__and___tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::__and__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__or___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__or___ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::__or__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__or___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__or___tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::__or__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__xor___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__xor___ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::__xor__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__xor___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__xor___tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::__xor__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__lshift___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__lshift___ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::__lshift__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__lshift___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__lshift___tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::__lshift__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__rshift___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__rshift___ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::__rshift__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__rshift___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__rshift___tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::__rshift__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

addbmm_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addbmm_out_ttttss _out _self _batch1 _batch2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::addbmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addbmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addbmm_tttss _self _batch1 _batch2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::addbmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

diag_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
diag_out_ttl _out _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::diag_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _diagonal)));
  }|]

diag_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
diag_tl _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::diag(
    *$(at::Tensor* _self)
  , $(int64_t _diagonal)));
  }|]

cross_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cross_out_tttl _out _self _other _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::cross_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(int64_t _dim)));
  }|]

cross_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
cross_ttl _self _other _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::cross(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(int64_t _dim)));
  }|]

triu_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
triu_out_ttl _out _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::triu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _diagonal)));
  }|]

triu_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
triu_tl _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::triu(
    *$(at::Tensor* _self)
  , $(int64_t _diagonal)));
  }|]

tril_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
tril_out_ttl _out _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::tril_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _diagonal)));
  }|]

tril_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
tril_tl _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::tril(
    *$(at::Tensor* _self)
  , $(int64_t _diagonal)));
  }|]

tril_indices_lllo
  :: Int64
  -> Int64
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
tril_indices_lllo _row _col _offset _options =
  [C.block| at::Tensor* { return new at::Tensor(at::tril_indices(
    $(int64_t _row)
  , $(int64_t _col)
  , $(int64_t _offset)
  , *$(at::TensorOptions* _options)));
  }|]

triu_indices_lllo
  :: Int64
  -> Int64
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
triu_indices_lllo _row _col _offset _options =
  [C.block| at::Tensor* { return new at::Tensor(at::triu_indices(
    $(int64_t _row)
  , $(int64_t _col)
  , $(int64_t _offset)
  , *$(at::TensorOptions* _options)));
  }|]

trace_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
trace_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::trace(
    *$(at::Tensor* _self)));
  }|]

ne_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ne_out_tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::ne_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ne_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ne_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::ne(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ne_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ne_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::ne_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

ne_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ne_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::ne(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

eq_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
eq_out_tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::eq_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

eq_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
eq_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::eq(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

eq_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
eq_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::eq_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

eq_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
eq_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::eq(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

ge_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ge_out_tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::ge_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ge_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ge_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::ge(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ge_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ge_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::ge_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

ge_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ge_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::ge(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

le_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
le_out_tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::le_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

le_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
le_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::le(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

le_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
le_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::le_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

le_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
le_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::le(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

gt_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
gt_out_tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::gt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

gt_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
gt_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::gt(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

gt_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gt_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::gt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

gt_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gt_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::gt(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

lt_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lt_out_tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::lt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

lt_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lt_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::lt(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

lt_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lt_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::lt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

lt_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lt_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::lt(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

take_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
take_out_ttt _out _self _index =
  [C.block| at::Tensor* { return new at::Tensor(at::take_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _index)));
  }|]

take_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
take_tt _self _index =
  [C.block| at::Tensor* { return new at::Tensor(at::take(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _index)));
  }|]

index_select_out_ttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_select_out_ttlt _out _self _dim _index =
  [C.block| at::Tensor* { return new at::Tensor(at::index_select_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)));
  }|]

index_select_tlt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_select_tlt _self _dim _index =
  [C.block| at::Tensor* { return new at::Tensor(at::index_select(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)));
  }|]

masked_select_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_select_out_ttt _out _self _mask =
  [C.block| at::Tensor* { return new at::Tensor(at::masked_select_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)));
  }|]

masked_select_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_select_tt _self _mask =
  [C.block| at::Tensor* { return new at::Tensor(at::masked_select(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)));
  }|]

nonzero_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nonzero_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::nonzero_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

nonzero_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
nonzero_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::nonzero(
    *$(at::Tensor* _self)));
  }|]

gather_out_ttltb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
gather_out_ttltb _out _self _dim _index _sparse_grad =
  [C.block| at::Tensor* { return new at::Tensor(at::gather_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , $(bool _sparse_grad)));
  }|]

gather_tltb
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
gather_tltb _self _dim _index _sparse_grad =
  [C.block| at::Tensor* { return new at::Tensor(at::gather(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , $(bool _sparse_grad)));
  }|]

_gather_sparse_backward_tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_gather_sparse_backward_tltt _self _dim _index _grad =
  [C.block| at::Tensor* { return new at::Tensor(at::_gather_sparse_backward(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _grad)));
  }|]

addcmul_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcmul_out_tttts _out _self _tensor1 _tensor2 _value =
  [C.block| at::Tensor* { return new at::Tensor(at::addcmul_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

addcmul_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcmul_ttts _self _tensor1 _tensor2 _value =
  [C.block| at::Tensor* { return new at::Tensor(at::addcmul(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

addcdiv_out_tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcdiv_out_tttts _out _self _tensor1 _tensor2 _value =
  [C.block| at::Tensor* { return new at::Tensor(at::addcdiv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

addcdiv_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcdiv_ttts _self _tensor1 _tensor2 _value =
  [C.block| at::Tensor* { return new at::Tensor(at::addcdiv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

gels_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
gels_out_tttt _X _qr _self _A =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::gels_out(
    *$(at::Tensor* _X)
  , *$(at::Tensor* _qr)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

gels_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
gels_tt _self _A =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::gels(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

trtrs_out_ttttbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
trtrs_out_ttttbbb _X _M _self _A _upper _transpose _unitriangular =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::trtrs_out(
    *$(at::Tensor* _X)
  , *$(at::Tensor* _M)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)
  , $(bool _transpose)
  , $(bool _unitriangular)));
  }|]

trtrs_ttbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
trtrs_ttbbb _self _A _upper _transpose _unitriangular =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::trtrs(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)
  , $(bool _transpose)
  , $(bool _unitriangular)));
  }|]

symeig_out_tttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
symeig_out_tttbb _e _V _self _eigenvectors _upper =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::symeig_out(
    *$(at::Tensor* _e)
  , *$(at::Tensor* _V)
  , *$(at::Tensor* _self)
  , $(bool _eigenvectors)
  , $(bool _upper)));
  }|]

symeig_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
symeig_tbb _self _eigenvectors _upper =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::symeig(
    *$(at::Tensor* _self)
  , $(bool _eigenvectors)
  , $(bool _upper)));
  }|]

eig_out_tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
eig_out_tttb _e _v _self _eigenvectors =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::eig_out(
    *$(at::Tensor* _e)
  , *$(at::Tensor* _v)
  , *$(at::Tensor* _self)
  , $(bool _eigenvectors)));
  }|]

eig_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
eig_tb _self _eigenvectors =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::eig(
    *$(at::Tensor* _self)
  , $(bool _eigenvectors)));
  }|]

svd_out_ttttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
svd_out_ttttbb _U _S _V _self _some _compute_uv =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::svd_out(
    *$(at::Tensor* _U)
  , *$(at::Tensor* _S)
  , *$(at::Tensor* _V)
  , *$(at::Tensor* _self)
  , $(bool _some)
  , $(bool _compute_uv)));
  }|]

svd_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
svd_tbb _self _some _compute_uv =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::svd(
    *$(at::Tensor* _self)
  , $(bool _some)
  , $(bool _compute_uv)));
  }|]

cholesky_out_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_out_ttb _out _self _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::cholesky_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

cholesky_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_tb _self _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::cholesky(
    *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

_cholesky_helper_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cholesky_helper_tb _self _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::_cholesky_helper(
    *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

cholesky_solve_out_tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_solve_out_tttb _out _self _input2 _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::cholesky_solve_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , $(bool _upper)));
  }|]

cholesky_solve_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_solve_ttb _self _input2 _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::cholesky_solve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , $(bool _upper)));
  }|]

_cholesky_solve_helper_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cholesky_solve_helper_ttb _self _A _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::_cholesky_solve_helper(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)));
  }|]

solve_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
solve_tt _self _A =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::solve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

solve_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
solve_out_tttt _solution _lu _self _A =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::solve_out(
    *$(at::Tensor* _solution)
  , *$(at::Tensor* _lu)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

_solve_helper_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
_solve_helper_tt _self _A =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_solve_helper(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

potri_out_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
potri_out_ttb _out _self _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::potri_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

potri_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
potri_tb _self _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::potri(
    *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

pstrf_out_tttbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Ptr Scalar
  -> IO (Ptr (Tensor,Tensor))
pstrf_out_tttbs _u _pivot _self _upper _tol =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::pstrf_out(
    *$(at::Tensor* _u)
  , *$(at::Tensor* _pivot)
  , *$(at::Tensor* _self)
  , $(bool _upper)
  , *$(at::Scalar* _tol)));
  }|]

pstrf_tbs
  :: Ptr Tensor
  -> CBool
  -> Ptr Scalar
  -> IO (Ptr (Tensor,Tensor))
pstrf_tbs _self _upper _tol =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::pstrf(
    *$(at::Tensor* _self)
  , $(bool _upper)
  , *$(at::Scalar* _tol)));
  }|]

qr_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
qr_out_ttt _Q _R _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::qr_out(
    *$(at::Tensor* _Q)
  , *$(at::Tensor* _R)
  , *$(at::Tensor* _self)));
  }|]

qr_t
  :: Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
qr_t _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::qr(
    *$(at::Tensor* _self)));
  }|]

geqrf_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
geqrf_out_ttt _a _tau _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::geqrf_out(
    *$(at::Tensor* _a)
  , *$(at::Tensor* _tau)
  , *$(at::Tensor* _self)));
  }|]

geqrf_t
  :: Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
geqrf_t _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::geqrf(
    *$(at::Tensor* _self)));
  }|]

orgqr_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
orgqr_out_ttt _out _self _input2 =
  [C.block| at::Tensor* { return new at::Tensor(at::orgqr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)));
  }|]

orgqr_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
orgqr_tt _self _input2 =
  [C.block| at::Tensor* { return new at::Tensor(at::orgqr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)));
  }|]

ormqr_out_ttttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
ormqr_out_ttttbb _out _self _input2 _input3 _left _transpose =
  [C.block| at::Tensor* { return new at::Tensor(at::ormqr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)
  , $(bool _left)
  , $(bool _transpose)));
  }|]

ormqr_tttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
ormqr_tttbb _self _input2 _input3 _left _transpose =
  [C.block| at::Tensor* { return new at::Tensor(at::ormqr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)
  , $(bool _left)
  , $(bool _transpose)));
  }|]

btrifact_out_tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
btrifact_out_tttb _A_LU _pivots _self _pivot =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::btrifact_out(
    *$(at::Tensor* _A_LU)
  , *$(at::Tensor* _pivots)
  , *$(at::Tensor* _self)
  , $(bool _pivot)));
  }|]

btrifact_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
btrifact_tb _self _pivot =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::btrifact(
    *$(at::Tensor* _self)
  , $(bool _pivot)));
  }|]

btrifact_with_info_out_ttttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
btrifact_with_info_out_ttttb _A_LU _pivots _info _self _pivot =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::btrifact_with_info_out(
    *$(at::Tensor* _A_LU)
  , *$(at::Tensor* _pivots)
  , *$(at::Tensor* _info)
  , *$(at::Tensor* _self)
  , $(bool _pivot)));
  }|]

btrifact_with_info_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
btrifact_with_info_tb _self _pivot =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::btrifact_with_info(
    *$(at::Tensor* _self)
  , $(bool _pivot)));
  }|]

_btrifact_helper_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
_btrifact_helper_tb _self _pivot =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_btrifact_helper(
    *$(at::Tensor* _self)
  , $(bool _pivot)));
  }|]

btrisolve_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
btrisolve_out_tttt _out _self _LU_data _LU_pivots =
  [C.block| at::Tensor* { return new at::Tensor(at::btrisolve_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _LU_data)
  , *$(at::Tensor* _LU_pivots)));
  }|]

btrisolve_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
btrisolve_ttt _self _LU_data _LU_pivots =
  [C.block| at::Tensor* { return new at::Tensor(at::btrisolve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _LU_data)
  , *$(at::Tensor* _LU_pivots)));
  }|]

multinomial_out_ttlbp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
multinomial_out_ttlbp _out _self _num_samples _replacement _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::multinomial_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _num_samples)
  , $(bool _replacement)
  , $(at::Generator * _generator)));
  }|]

multinomial_tlbp
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
multinomial_tlbp _self _num_samples _replacement _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::multinomial(
    *$(at::Tensor* _self)
  , $(int64_t _num_samples)
  , $(bool _replacement)
  , $(at::Generator * _generator)));
  }|]

lgamma_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lgamma_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::lgamma_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

lgamma_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
lgamma_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::lgamma(
    *$(at::Tensor* _self)));
  }|]

digamma_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
digamma_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::digamma_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

digamma_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
digamma_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::digamma(
    *$(at::Tensor* _self)));
  }|]

polygamma_out_tlt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
polygamma_out_tlt _out _n _self =
  [C.block| at::Tensor* { return new at::Tensor(at::polygamma_out(
    *$(at::Tensor* _out)
  , $(int64_t _n)
  , *$(at::Tensor* _self)));
  }|]

polygamma_lt
  :: Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
polygamma_lt _n _self =
  [C.block| at::Tensor* { return new at::Tensor(at::polygamma(
    $(int64_t _n)
  , *$(at::Tensor* _self)));
  }|]

erfinv_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
erfinv_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::erfinv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

erfinv_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erfinv_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::erfinv(
    *$(at::Tensor* _self)));
  }|]

frac_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
frac_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::frac_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

frac_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
frac_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::frac(
    *$(at::Tensor* _self)));
  }|]

dist_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
dist_tts _self _other _p =
  [C.block| at::Tensor* { return new at::Tensor(at::dist(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _p)));
  }|]

reciprocal_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
reciprocal_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::reciprocal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

reciprocal_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
reciprocal_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::reciprocal(
    *$(at::Tensor* _self)));
  }|]

neg_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
neg_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::neg_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

neg_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
neg_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::neg(
    *$(at::Tensor* _self)));
  }|]

atan2_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
atan2_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::atan2_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

atan2_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
atan2_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::atan2(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

lerp_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lerp_out_ttts _out _self _end _weight =
  [C.block| at::Tensor* { return new at::Tensor(at::lerp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Scalar* _weight)));
  }|]

lerp_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lerp_out_tttt _out _self _end _weight =
  [C.block| at::Tensor* { return new at::Tensor(at::lerp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Tensor* _weight)));
  }|]

lerp_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lerp_tts _self _end _weight =
  [C.block| at::Tensor* { return new at::Tensor(at::lerp(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Scalar* _weight)));
  }|]

lerp_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lerp_ttt _self _end _weight =
  [C.block| at::Tensor* { return new at::Tensor(at::lerp(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Tensor* _weight)));
  }|]

histc_out_ttlss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
histc_out_ttlss _out _self _bins _min _max =
  [C.block| at::Tensor* { return new at::Tensor(at::histc_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _bins)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

histc_tlss
  :: Ptr Tensor
  -> Int64
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
histc_tlss _self _bins _min _max =
  [C.block| at::Tensor* { return new at::Tensor(at::histc(
    *$(at::Tensor* _self)
  , $(int64_t _bins)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

sign_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sign_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sign_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

sign_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sign_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::sign(
    *$(at::Tensor* _self)));
  }|]

fmod_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
fmod_out_tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::fmod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

fmod_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
fmod_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::fmod(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

fmod_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fmod_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::fmod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

fmod_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fmod_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::fmod(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

remainder_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
remainder_out_tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::remainder_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

remainder_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
remainder_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::remainder(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

remainder_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
remainder_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::remainder_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

remainder_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
remainder_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::remainder(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

min_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
min_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::min_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

min_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
min_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::min(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

min_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
min_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::min(
    *$(at::Tensor* _self)));
  }|]

max_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_out_ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::max_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

max_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::max(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

max_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
max_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::max(
    *$(at::Tensor* _self)));
  }|]

median_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
median_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::median(
    *$(at::Tensor* _self)));
  }|]

sort_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
sort_out_tttlb _values _indices _self _dim _descending =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _descending)));
  }|]

sort_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
sort_tlb _self _dim _descending =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _descending)));
  }|]

argsort_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
argsort_tlb _self _dim _descending =
  [C.block| at::Tensor* { return new at::Tensor(at::argsort(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _descending)));
  }|]

topk_out_tttllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
topk_out_tttllbb _values _indices _self _k _dim _largest _sorted =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _largest)
  , $(bool _sorted)));
  }|]

topk_tllbb
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
topk_tllbb _self _k _dim _largest _sorted =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _largest)
  , $(bool _sorted)));
  }|]

all_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
all_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::all(
    *$(at::Tensor* _self)));
  }|]

any_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
any_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::any(
    *$(at::Tensor* _self)));
  }|]

renorm_out_ttsls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Int64
  -> Ptr Scalar
  -> IO (Ptr Tensor)
renorm_out_ttsls _out _self _p _dim _maxnorm =
  [C.block| at::Tensor* { return new at::Tensor(at::renorm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , $(int64_t _dim)
  , *$(at::Scalar* _maxnorm)));
  }|]

renorm_tsls
  :: Ptr Tensor
  -> Ptr Scalar
  -> Int64
  -> Ptr Scalar
  -> IO (Ptr Tensor)
renorm_tsls _self _p _dim _maxnorm =
  [C.block| at::Tensor* { return new at::Tensor(at::renorm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , $(int64_t _dim)
  , *$(at::Scalar* _maxnorm)));
  }|]

equal_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (CBool)
equal_tt _self _other =
  [C.block| bool { return (at::equal(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

pow_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_out_ttt _out _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::pow_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _exponent)));
  }|]

pow_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_tt _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::pow(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _exponent)));
  }|]

pow_out_tst
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_out_tst _out _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::pow_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _self)
  , *$(at::Tensor* _exponent)));
  }|]

pow_st
  :: Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_st _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::pow(
    *$(at::Scalar* _self)
  , *$(at::Tensor* _exponent)));
  }|]

normal_out_ttdp
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_ttdp _out _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mean)
  , $(double _std)
  , $(at::Generator * _generator)));
  }|]

normal_tdp
  :: Ptr Tensor
  -> CDouble
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_tdp _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::normal(
    *$(at::Tensor* _mean)
  , $(double _std)
  , $(at::Generator * _generator)));
  }|]

normal_out_tdtp
  :: Ptr Tensor
  -> CDouble
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_tdtp _out _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , $(double _mean)
  , *$(at::Tensor* _std)
  , $(at::Generator * _generator)));
  }|]

normal_dtp
  :: CDouble
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_dtp _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::normal(
    $(double _mean)
  , *$(at::Tensor* _std)
  , $(at::Generator * _generator)));
  }|]

normal_out_tttp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_tttp _out _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _std)
  , $(at::Generator * _generator)));
  }|]

normal_ttp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_ttp _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::normal(
    *$(at::Tensor* _mean)
  , *$(at::Tensor* _std)
  , $(at::Generator * _generator)));
  }|]

alias_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
alias_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::alias(
    *$(at::Tensor* _self)));
  }|]

_dirichlet_grad_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_dirichlet_grad_out_tttt _out _x _alpha _total =
  [C.block| at::Tensor* { return new at::Tensor(at::_dirichlet_grad_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _x)
  , *$(at::Tensor* _alpha)
  , *$(at::Tensor* _total)));
  }|]

_dirichlet_grad_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_dirichlet_grad_ttt _x _alpha _total =
  [C.block| at::Tensor* { return new at::Tensor(at::_dirichlet_grad(
    *$(at::Tensor* _x)
  , *$(at::Tensor* _alpha)
  , *$(at::Tensor* _total)));
  }|]

binary_cross_entropy_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_out_ttttl _out _self _target _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_tttl _self _target _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::binary_cross_entropy(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_backward_out_tttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_out_tttttl _grad_input _grad_output _self _target _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

binary_cross_entropy_backward_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_ttttl _grad_output _self _target _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::binary_cross_entropy_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

mse_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mse_loss_out_tttl _out _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::mse_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

mse_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mse_loss_ttl _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::mse_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

mse_loss_backward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mse_loss_backward_out_ttttl _grad_input _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::mse_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

mse_loss_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mse_loss_backward_tttl _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::mse_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

l1_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
l1_loss_out_tttl _out _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::l1_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

l1_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
l1_loss_ttl _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::l1_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

l1_loss_backward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
l1_loss_backward_out_ttttl _grad_input _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::l1_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

l1_loss_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
l1_loss_backward_tttl _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::l1_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_out_tttsstl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multi_margin_loss_out_tttsstl _out _self _target _p _margin _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::multi_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_ttsstl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multi_margin_loss_ttsstl _self _target _p _margin _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::multi_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_backward_out_ttttsstl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multi_margin_loss_backward_out_ttttsstl _grad_input _grad_output _self _target _p _margin _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_backward_tttsstl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multi_margin_loss_backward_tttsstl _grad_output _self _target _p _margin _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

multilabel_margin_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multilabel_margin_loss_out_tttl _out _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multilabel_margin_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multilabel_margin_loss_ttl _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multilabel_margin_loss_forward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (Tensor,Tensor))
multilabel_margin_loss_forward_out_ttttl _output _is_target _self _target _reduction =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::multilabel_margin_loss_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _is_target)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multilabel_margin_loss_forward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (Tensor,Tensor))
multilabel_margin_loss_forward_ttl _self _target _reduction =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::multilabel_margin_loss_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multilabel_margin_loss_backward_out_ttttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multilabel_margin_loss_backward_out_ttttlt _grad_input _grad_output _self _target _reduction _is_target =
  [C.block| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)
  , *$(at::Tensor* _is_target)));
  }|]

multilabel_margin_loss_backward_tttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multilabel_margin_loss_backward_tttlt _grad_output _self _target _reduction _is_target =
  [C.block| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)
  , *$(at::Tensor* _is_target)));
  }|]

nll_loss_out_ttttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
nll_loss_out_ttttll _out _self _target _weight _reduction _ignore_index =
  [C.block| at::Tensor* { return new at::Tensor(at::nll_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
nll_loss_tttll _self _target _weight _reduction _ignore_index =
  [C.block| at::Tensor* { return new at::Tensor(at::nll_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss_forward_out_tttttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (Tensor,Tensor))
nll_loss_forward_out_tttttll _output _total_weight _self _target _weight _reduction _ignore_index =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::nll_loss_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _total_weight)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss_forward_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (Tensor,Tensor))
nll_loss_forward_tttll _self _target _weight _reduction _ignore_index =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::nll_loss_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss_backward_out_tttttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_backward_out_tttttllt _grad_input _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.block| at::Tensor* { return new at::Tensor(at::nll_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

nll_loss_backward_ttttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_backward_ttttllt _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.block| at::Tensor* { return new at::Tensor(at::nll_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

nll_loss2d_out_ttttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
nll_loss2d_out_ttttll _out _self _target _weight _reduction _ignore_index =
  [C.block| at::Tensor* { return new at::Tensor(at::nll_loss2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss2d_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
nll_loss2d_tttll _self _target _weight _reduction _ignore_index =
  [C.block| at::Tensor* { return new at::Tensor(at::nll_loss2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss2d_forward_out_tttttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (Tensor,Tensor))
nll_loss2d_forward_out_tttttll _output _total_weight _self _target _weight _reduction _ignore_index =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::nll_loss2d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _total_weight)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss2d_forward_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (Tensor,Tensor))
nll_loss2d_forward_tttll _self _target _weight _reduction _ignore_index =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::nll_loss2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss2d_backward_out_tttttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_backward_out_tttttllt _grad_input _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.block| at::Tensor* { return new at::Tensor(at::nll_loss2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

nll_loss2d_backward_ttttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_backward_ttttllt _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.block| at::Tensor* { return new at::Tensor(at::nll_loss2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

smooth_l1_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
smooth_l1_loss_out_tttl _out _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::smooth_l1_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

smooth_l1_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
smooth_l1_loss_ttl _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::smooth_l1_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

smooth_l1_loss_backward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
smooth_l1_loss_backward_out_ttttl _grad_input _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::smooth_l1_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

smooth_l1_loss_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
smooth_l1_loss_backward_tttl _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::smooth_l1_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

soft_margin_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
soft_margin_loss_out_tttl _out _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::soft_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

soft_margin_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
soft_margin_loss_ttl _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::soft_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

soft_margin_loss_backward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
soft_margin_loss_backward_out_ttttl _grad_input _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::soft_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

soft_margin_loss_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
soft_margin_loss_backward_tttl _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::soft_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

elu_out_ttsss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_out_ttsss _out _self _alpha _scale _input_scale =
  [C.block| at::Tensor* { return new at::Tensor(at::elu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)));
  }|]

elu_tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_tsss _self _alpha _scale _input_scale =
  [C.block| at::Tensor* { return new at::Tensor(at::elu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)));
  }|]

elu_backward_out_ttssst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
elu_backward_out_ttssst _grad_input _grad_output _alpha _scale _input_scale _output =
  [C.block| at::Tensor* { return new at::Tensor(at::elu_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)
  , *$(at::Tensor* _output)));
  }|]

elu_backward_tssst
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
elu_backward_tssst _grad_output _alpha _scale _input_scale _output =
  [C.block| at::Tensor* { return new at::Tensor(at::elu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)
  , *$(at::Tensor* _output)));
  }|]

elu__tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu__tsss _self _alpha _scale _input_scale =
  [C.block| at::Tensor* { return new at::Tensor(at::elu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)));
  }|]

glu_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
glu_out_ttl _out _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::glu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

glu_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
glu_tl _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::glu(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

glu_backward_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
glu_backward_out_tttl _grad_input _grad_output _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::glu_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

glu_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
glu_backward_ttl _grad_output _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::glu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

hardtanh_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_out_ttss _out _self _min_val _max_val =
  [C.block| at::Tensor* { return new at::Tensor(at::hardtanh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_tss _self _min_val _max_val =
  [C.block| at::Tensor* { return new at::Tensor(at::hardtanh(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh_backward_out_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_backward_out_tttss _grad_input _grad_output _self _min_val _max_val =
  [C.block| at::Tensor* { return new at::Tensor(at::hardtanh_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh_backward_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_backward_ttss _grad_output _self _min_val _max_val =
  [C.block| at::Tensor* { return new at::Tensor(at::hardtanh_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh__tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh__tss _self _min_val _max_val =
  [C.block| at::Tensor* { return new at::Tensor(at::hardtanh_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

leaky_relu_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu_out_tts _out _self _negative_slope =
  [C.block| at::Tensor* { return new at::Tensor(at::leaky_relu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu_ts _self _negative_slope =
  [C.block| at::Tensor* { return new at::Tensor(at::leaky_relu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu_backward_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu_backward_out_ttts _grad_input _grad_output _self _negative_slope =
  [C.block| at::Tensor* { return new at::Tensor(at::leaky_relu_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu_backward_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu_backward_tts _grad_output _self _negative_slope =
  [C.block| at::Tensor* { return new at::Tensor(at::leaky_relu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu__ts _self _negative_slope =
  [C.block| at::Tensor* { return new at::Tensor(at::leaky_relu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

log_sigmoid_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_out_tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log_sigmoid_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

log_sigmoid_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::log_sigmoid(
    *$(at::Tensor* _self)));
  }|]

log_sigmoid_forward_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
log_sigmoid_forward_out_ttt _output _buffer _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::log_sigmoid_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _buffer)
  , *$(at::Tensor* _self)));
  }|]

log_sigmoid_forward_t
  :: Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
log_sigmoid_forward_t _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::log_sigmoid_forward(
    *$(at::Tensor* _self)));
  }|]

log_sigmoid_backward_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_backward_out_tttt _grad_input _grad_output _self _buffer =
  [C.block| at::Tensor* { return new at::Tensor(at::log_sigmoid_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _buffer)));
  }|]

log_sigmoid_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_backward_ttt _grad_output _self _buffer =
  [C.block| at::Tensor* { return new at::Tensor(at::log_sigmoid_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _buffer)));
  }|]

rrelu_with_noise_out_tttssbp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_with_noise_out_tttssbp _out _self _noise _lower _upper _training _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

rrelu_with_noise_ttssbp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_with_noise_ttssbp _self _noise _lower _upper _training _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::rrelu_with_noise(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

rrelu_with_noise_backward_out_ttttssb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu_with_noise_backward_out_ttttssb _grad_input _grad_output _self _noise _lower _upper _training =
  [C.block| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu_with_noise_backward_tttssb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu_with_noise_backward_tttssb _grad_output _self _noise _lower _upper _training =
  [C.block| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu_with_noise__ttssbp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_with_noise__ttssbp _self _noise _lower _upper _training _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

softplus_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softplus_out_ttss _out _self _beta _threshold =
  [C.block| at::Tensor* { return new at::Tensor(at::softplus_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)));
  }|]

softplus_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softplus_tss _self _beta _threshold =
  [C.block| at::Tensor* { return new at::Tensor(at::softplus(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)));
  }|]

softplus_backward_out_tttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
softplus_backward_out_tttsst _grad_input _grad_output _self _beta _threshold _output =
  [C.block| at::Tensor* { return new at::Tensor(at::softplus_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)
  , *$(at::Tensor* _output)));
  }|]

softplus_backward_ttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
softplus_backward_ttsst _grad_output _self _beta _threshold _output =
  [C.block| at::Tensor* { return new at::Tensor(at::softplus_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)
  , *$(at::Tensor* _output)));
  }|]

softshrink_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_out_tts _out _self _lambd =
  [C.block| at::Tensor* { return new at::Tensor(at::softshrink_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

softshrink_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_ts _self _lambd =
  [C.block| at::Tensor* { return new at::Tensor(at::softshrink(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

softshrink_backward_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_backward_out_ttts _grad_input _grad_output _self _lambd =
  [C.block| at::Tensor* { return new at::Tensor(at::softshrink_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

softshrink_backward_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_backward_tts _grad_output _self _lambd =
  [C.block| at::Tensor* { return new at::Tensor(at::softshrink_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

adaptive_avg_pool2d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool2d_out_ttl _out _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_avg_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool2d_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

_adaptive_avg_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_adaptive_avg_pool2d_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::_adaptive_avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

_adaptive_avg_pool2d_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_adaptive_avg_pool2d_backward_tt _grad_output _self =
  [C.block| at::Tensor* { return new at::Tensor(at::_adaptive_avg_pool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

adaptive_avg_pool3d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_out_ttl _out _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_avg_pool3d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_avg_pool3d_backward_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_backward_out_ttt _grad_input _grad_output _self =
  [C.block| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

adaptive_avg_pool3d_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_backward_tt _grad_output _self =
  [C.block| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

adaptive_max_pool2d_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool2d_out_tttl _output _indices _self _output_size =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool2d_tl _self _output_size =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool2d_backward_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool2d_backward_out_tttt _grad_input _grad_output _self _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::adaptive_max_pool2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

adaptive_max_pool2d_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool2d_backward_ttt _grad_output _self _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::adaptive_max_pool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

adaptive_max_pool3d_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool3d_out_tttl _output _indices _self _output_size =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool3d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool3d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool3d_tl _self _output_size =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool3d_backward_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool3d_backward_out_tttt _grad_input _grad_output _self _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::adaptive_max_pool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

adaptive_max_pool3d_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool3d_backward_ttt _grad_output _self _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::adaptive_max_pool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

avg_pool2d_out_ttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool2d_out_ttlllbb _out _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::avg_pool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool2d_tlllbb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool2d_tlllbb _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool2d_backward_out_tttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool2d_backward_out_tttlllbb _grad_input _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::avg_pool2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool2d_backward_ttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool2d_backward_ttlllbb _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::avg_pool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool3d_out_ttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool3d_out_ttlllbb _out _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::avg_pool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool3d_tlllbb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool3d_tlllbb _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::avg_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool3d_backward_out_tttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool3d_backward_out_tttlllbb _grad_input _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::avg_pool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool3d_backward_ttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool3d_backward_ttlllbb _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::avg_pool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

fractional_max_pool2d_out_tttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
fractional_max_pool2d_out_tttllt _output _indices _self _kernel_size _output_size _random_samples =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::fractional_max_pool2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _random_samples)));
  }|]

fractional_max_pool2d_tllt
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
fractional_max_pool2d_tllt _self _kernel_size _output_size _random_samples =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::fractional_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _random_samples)));
  }|]

fractional_max_pool2d_backward_out_tttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fractional_max_pool2d_backward_out_tttllt _grad_input _grad_output _self _kernel_size _output_size _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::fractional_max_pool2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _indices)));
  }|]

fractional_max_pool2d_backward_ttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fractional_max_pool2d_backward_ttllt _grad_output _self _kernel_size _output_size _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::fractional_max_pool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _indices)));
  }|]

fractional_max_pool3d_out_tttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
fractional_max_pool3d_out_tttllt _output _indices _self _kernel_size _output_size _random_samples =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::fractional_max_pool3d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _random_samples)));
  }|]

fractional_max_pool3d_tllt
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
fractional_max_pool3d_tllt _self _kernel_size _output_size _random_samples =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::fractional_max_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _random_samples)));
  }|]

fractional_max_pool3d_backward_out_tttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fractional_max_pool3d_backward_out_tttllt _grad_input _grad_output _self _kernel_size _output_size _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::fractional_max_pool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _indices)));
  }|]

fractional_max_pool3d_backward_ttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fractional_max_pool3d_backward_ttllt _grad_output _self _kernel_size _output_size _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::fractional_max_pool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _output_size)
  , *$(at::Tensor* _indices)));
  }|]

max_pool2d_with_indices_out_tttllllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_pool2d_with_indices_out_tttllllb _output _indices _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool2d_with_indices_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool2d_with_indices_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_pool2d_with_indices_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool2d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool2d_with_indices_backward_out_tttllllbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_pool2d_with_indices_backward_out_tttllllbt _grad_input _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::max_pool2d_with_indices_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)
  , *$(at::Tensor* _indices)));
  }|]

max_pool2d_with_indices_backward_ttllllbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_pool2d_with_indices_backward_ttllllbt _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::max_pool2d_with_indices_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)
  , *$(at::Tensor* _indices)));
  }|]

max_pool3d_with_indices_out_tttllllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_pool3d_with_indices_out_tttllllb _output _indices _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool3d_with_indices_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool3d_with_indices_tllllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_pool3d_with_indices_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::max_pool3d_with_indices(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool3d_with_indices_backward_out_tttllllbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_pool3d_with_indices_backward_out_tttllllbt _grad_input _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::max_pool3d_with_indices_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)
  , *$(at::Tensor* _indices)));
  }|]

max_pool3d_with_indices_backward_ttllllbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_pool3d_with_indices_backward_ttllllbt _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::max_pool3d_with_indices_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , $(bool _ceil_mode)
  , *$(at::Tensor* _indices)));
  }|]

max_unpool2d_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool2d_out_tttl _out _self _indices _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::max_unpool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

max_unpool2d_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool2d_ttl _self _indices _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::max_unpool2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

max_unpool2d_backward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool2d_backward_out_ttttl _grad_input _grad_output _self _indices _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::max_unpool2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

max_unpool2d_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool2d_backward_tttl _grad_output _self _indices _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::max_unpool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

max_unpool3d_out_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool3d_out_tttlll _out _self _indices _output_size _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::max_unpool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_unpool3d_ttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool3d_ttlll _self _indices _output_size _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::max_unpool3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_unpool3d_backward_out_ttttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool3d_backward_out_ttttlll _grad_input _grad_output _self _indices _output_size _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::max_unpool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

max_unpool3d_backward_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
max_unpool3d_backward_tttlll _grad_output _self _indices _output_size _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::max_unpool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad1d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad1d_out_ttl _out _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::reflection_pad1d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad1d_tl _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::reflection_pad1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad1d_backward_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad1d_backward_out_tttl _grad_input _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::reflection_pad1d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad1d_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad1d_backward_ttl _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::reflection_pad1d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad2d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad2d_out_ttl _out _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::reflection_pad2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad2d_tl _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::reflection_pad2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad2d_backward_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad2d_backward_out_tttl _grad_input _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::reflection_pad2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

reflection_pad2d_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
reflection_pad2d_backward_ttl _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::reflection_pad2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad1d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad1d_out_ttl _out _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::replication_pad1d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad1d_tl _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::replication_pad1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad1d_backward_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad1d_backward_out_tttl _grad_input _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::replication_pad1d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad1d_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad1d_backward_ttl _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::replication_pad1d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad2d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad2d_out_ttl _out _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::replication_pad2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad2d_tl _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::replication_pad2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad2d_backward_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad2d_backward_out_tttl _grad_input _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::replication_pad2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad2d_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad2d_backward_ttl _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::replication_pad2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad3d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad3d_out_ttl _out _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::replication_pad3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad3d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad3d_tl _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::replication_pad3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad3d_backward_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad3d_backward_out_tttl _grad_input _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::replication_pad3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

replication_pad3d_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
replication_pad3d_backward_ttl _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::replication_pad3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _padding)));
  }|]

upsample_linear1d_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_linear1d_out_ttlb _out _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_linear1d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_linear1d_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_linear1d_tlb _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_linear1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_linear1d_backward_out_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_linear1d_backward_out_ttllb _grad_input _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_linear1d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_linear1d_backward_tllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_linear1d_backward_tllb _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_linear1d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_bilinear2d_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bilinear2d_out_ttlb _out _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_bilinear2d_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bilinear2d_tlb _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_bilinear2d_backward_out_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bilinear2d_backward_out_ttllb _grad_input _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_bilinear2d_backward_tllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bilinear2d_backward_tllb _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_bilinear2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_bicubic2d_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bicubic2d_out_ttlb _out _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_bicubic2d_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bicubic2d_tlb _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_bicubic2d_backward_out_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bicubic2d_backward_out_ttllb _grad_input _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_bicubic2d_backward_tllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_bicubic2d_backward_tllb _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_bicubic2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_trilinear3d_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_trilinear3d_out_ttlb _out _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_trilinear3d_tlb
  :: Ptr Tensor
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_trilinear3d_tlb _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_trilinear3d_backward_out_ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_trilinear3d_backward_out_ttllb _grad_input _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_trilinear3d_backward_tllb
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> CBool
  -> IO (Ptr Tensor)
upsample_trilinear3d_backward_tllb _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_trilinear3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_nearest1d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest1d_out_ttl _out _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_nearest1d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

upsample_nearest1d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest1d_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_nearest1d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

upsample_nearest1d_backward_out_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest1d_backward_out_ttll _grad_input _grad_output _output_size _input_size =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_nearest1d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)));
  }|]

upsample_nearest1d_backward_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest1d_backward_tll _grad_output _output_size _input_size =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_nearest1d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)));
  }|]

upsample_nearest2d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest2d_out_ttl _out _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_nearest2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

upsample_nearest2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest2d_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_nearest2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

upsample_nearest2d_backward_out_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest2d_backward_out_ttll _grad_input _grad_output _output_size _input_size =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_nearest2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)));
  }|]

upsample_nearest2d_backward_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest2d_backward_tll _grad_output _output_size _input_size =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_nearest2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)));
  }|]

upsample_nearest3d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest3d_out_ttl _out _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

upsample_nearest3d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest3d_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_nearest3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

upsample_nearest3d_backward_out_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest3d_backward_out_ttll _grad_input _grad_output _output_size _input_size =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)));
  }|]

upsample_nearest3d_backward_tll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
upsample_nearest3d_backward_tll _grad_output _output_size _input_size =
  [C.block| at::Tensor* { return new at::Tensor(at::upsample_nearest3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _input_size)));
  }|]

sigmoid_backward_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid_backward_out_ttt _grad_input _grad_output _output =
  [C.block| at::Tensor* { return new at::Tensor(at::sigmoid_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)));
  }|]

sigmoid_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid_backward_tt _grad_output _output =
  [C.block| at::Tensor* { return new at::Tensor(at::sigmoid_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)));
  }|]

tanh_backward_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
tanh_backward_out_ttt _grad_input _grad_output _output =
  [C.block| at::Tensor* { return new at::Tensor(at::tanh_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)));
  }|]

tanh_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
tanh_backward_tt _grad_output _output =
  [C.block| at::Tensor* { return new at::Tensor(at::tanh_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)));
  }|]

thnn_conv_transpose2d_out_tttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_transpose2d_out_tttltllll _out _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv_transpose2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_transpose2d_ttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_transpose2d_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv_transpose2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_transpose2d_forward_out_tttttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose2d_forward_out_tttttltllll _output _columns _ones _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_transpose2d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_transpose2d_forward_ttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose2d_forward_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_transpose2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_transpose2d_backward_out_ttttttllllltt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose2d_backward_out_ttttttllllltt _grad_input _grad_weight _grad_bias _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _columns _ones =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_transpose2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)));
  }|]

thnn_conv_transpose2d_backward_tttllllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose2d_backward_tttllllltta _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _columns _ones _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_transpose2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_conv_transpose3d_out_tttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_transpose3d_out_tttltllll _out _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv_transpose3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_transpose3d_ttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_transpose3d_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv_transpose3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_transpose3d_forward_out_tttttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose3d_forward_out_tttttltllll _output _finput _fgrad_input _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_transpose3d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_transpose3d_forward_ttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose3d_forward_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_transpose3d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_transpose3d_backward_out_ttttttllllltt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose3d_backward_out_ttttttllllltt _grad_input _grad_weight _grad_bias _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _finput _fgrad_input =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_transpose3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)));
  }|]

thnn_conv_transpose3d_backward_tttllllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose3d_backward_tttllllltta _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _finput _fgrad_input _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_transpose3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _output_padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_conv2d_out_tttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv2d_out_tttltll _out _self _weight _kernel_size _bias _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv2d_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv2d_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv2d_forward_out_tttttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv2d_forward_out_tttttltll _output _finput _fgrad_input _self _weight _kernel_size _bias _stride _padding =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv2d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv2d_forward_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv2d_forward_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv2d_backward_out_ttttttllltt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv2d_backward_out_ttttttllltt _grad_input _grad_weight _grad_bias _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)));
  }|]

thnn_conv2d_backward_tttllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv2d_backward_tttllltta _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_conv_depthwise2d_out_tttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_out_tttltlll _out _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_depthwise2d_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_depthwise2d_forward_out_tttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_forward_out_tttltlll _out _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d_forward_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_depthwise2d_forward_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_forward_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv_depthwise2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_depthwise2d_backward_out_tttttllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor))
thnn_conv_depthwise2d_backward_out_tttttllll _grad_input _grad_weight _grad_output _self _weight _kernel_size _stride _padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::thnn_conv_depthwise2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_depthwise2d_backward_tttlllla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr (StdArray CBool 2)
  -> IO (Ptr (Tensor,Tensor))
thnn_conv_depthwise2d_backward_tttlllla _grad_output _self _weight _kernel_size _stride _padding _dilation _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::thnn_conv_depthwise2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::array<bool,2>* _output_mask)));
  }|]

thnn_conv3d_out_tttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv3d_out_tttltll _out _self _weight _kernel_size _bias _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv3d_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv3d_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv3d_forward_out_tttttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv3d_forward_out_tttttltll _output _finput _fgrad_input _self _weight _kernel_size _bias _stride _padding =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv3d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv3d_forward_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv3d_forward_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv3d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)));
  }|]

thnn_conv3d_backward_out_ttttttllltt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv3d_backward_out_ttttttllltt _grad_input _grad_weight _grad_bias _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)));
  }|]

thnn_conv3d_backward_tttllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv3d_backward_tttllltta _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_conv_dilated2d_out_tttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_dilated2d_out_tttltlll _out _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv_dilated2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_dilated2d_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_dilated2d_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv_dilated2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_dilated2d_forward_out_tttttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated2d_forward_out_tttttltlll _output _columns _ones _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_dilated2d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_dilated2d_forward_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated2d_forward_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_dilated2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_dilated2d_backward_out_ttttttlllltt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated2d_backward_out_ttttttlllltt _grad_input _grad_weight _grad_bias _grad_output _self _weight _kernel_size _stride _padding _dilation _columns _ones =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_dilated2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)));
  }|]

thnn_conv_dilated2d_backward_tttlllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated2d_backward_tttlllltta _grad_output _self _weight _kernel_size _stride _padding _dilation _columns _ones _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_dilated2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_conv_dilated3d_out_tttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_dilated3d_out_tttltlll _out _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv_dilated3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_dilated3d_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_conv_dilated3d_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_conv_dilated3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_dilated3d_forward_out_tttttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated3d_forward_out_tttttltlll _output _columns _ones _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_dilated3d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_dilated3d_forward_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated3d_forward_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_dilated3d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)));
  }|]

thnn_conv_dilated3d_backward_out_ttttttlllltt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated3d_backward_out_ttttttlllltt _grad_input _grad_weight _grad_bias _grad_output _self _weight _kernel_size _stride _padding _dilation _columns _ones =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_dilated3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)));
  }|]

thnn_conv_dilated3d_backward_tttlllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated3d_backward_tttlllltta _grad_output _self _weight _kernel_size _stride _padding _dilation _columns _ones _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::thnn_conv_dilated3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _stride)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_col2im_tlllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_col2im_tlllll _self _output_size _kernel_size _dilation _padding _stride =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_col2im(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

thnn_col2im_backward_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_col2im_backward_tllll _grad_output _kernel_size _dilation _padding _stride =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_col2im_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

thnn_im2col_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_im2col_tllll _self _kernel_size _dilation _padding _stride =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_im2col(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

thnn_im2col_backward_tlllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> Ptr IntArray
  -> IO (Ptr Tensor)
thnn_im2col_backward_tlllll _grad_output _input_size _kernel_size _dilation _padding _stride =
  [C.block| at::Tensor* { return new at::Tensor(at::thnn_im2col_backward(
    *$(at::Tensor* _grad_output)
  , *$(std::vector<int64_t>* _input_size)
  , *$(std::vector<int64_t>* _kernel_size)
  , *$(std::vector<int64_t>* _dilation)
  , *$(std::vector<int64_t>* _padding)
  , *$(std::vector<int64_t>* _stride)));
  }|]

